<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>AAC ADTS 格式分析</title>
    <link href="/2025/06/13/extract-aac/"/>
    <url>/2025/06/13/extract-aac/</url>
    
    <content type="html"><![CDATA[<h1 id="AAC-ADTS-格式分析"><a href="#AAC-ADTS-格式分析" class="headerlink" title="AAC ADTS 格式分析"></a>AAC ADTS 格式分析</h1><p>Advanced Audio Coding(⾼级⾳频解码)，是⼀种由MPEG-4标准定义的有损⾳频压缩格式，由Fraunhofer发展，Dolby, Sony和AT&amp;T是主要的贡献者。</p><h2 id="ADTS"><a href="#ADTS" class="headerlink" title="ADTS"></a>ADTS</h2><p>全称是Audio Data Transport Stream。是AAC⾳频的传输流格式。AAC⾳频格式在MPEG-2（ISO-13318-7 2003）中有定义。AAC后来⼜被采⽤到MPEG-4标准中。这种格式的特征是它是⼀个有同步字的⽐特流，解码可以在这个流中任何位置开始。它的特征类似于mp3数据流格式。简单说，<strong>ADTS可以在任意帧解码，也就是说它每⼀帧都有头信息</strong>。</p><p><img src="/2025/03/21/file-io/aac/image1.png" alt="ADTS的一般格式，空白处表示前后帧"></p><p>有的时候当你编码AAC裸流的时候，会遇到写出来的AAC⽂件并不能在PC和⼿机上播放，很⼤的可能就是AAC⽂件的每⼀帧⾥缺少了ADTS头信息⽂件的包装拼接。<br>只需要加⼊头⽂件ADTS即可。⼀个AAC原始数据块⻓度是可变的，对原始帧加上ADTS头进⾏ADTS的封装，就形成了ADTS帧。</p><p>AAC⾳频⽂件的每⼀帧由ADTS Header和AAC Audio Data组成。结构体如下：<br><img src="/2025/03/21/file-io/aac/image2.png"><br>注：ADTS Header的长度可能为7字节或9字节，protecttion_absent&#x3D;0时，9字节，protecttion_absent&#x3D;1时，为7字节</p><p>每⼀帧的ADTS的头⽂件都包含了⾳频的采样率，声道，帧⻓度等信息，这样解码器才能解析读取。<br>⼀般情况下ADTS的头信息都是7个字节，分为2部分：</p><ul><li>adts_fixed_header()</li><li>adts_variable_header()</li></ul><p>其⼀为固定头信息，紧接着是可变头信息。固定头信息中的数据每⼀帧都相同，⽽可变头信息则在帧与帧之间可变。</p><h2 id="adts-fixed-header"><a href="#adts-fixed-header" class="headerlink" title="adts_fixed_header"></a>adts_fixed_header</h2><p><img src="/2025/03/21/file-io/aac/image3.png"></p><ul><li>syncword: 同步头，总是为0xFFF，all bits must be 1，代表着一个ADTS帧的开始</li><li>ID: MPEG标识符，0表示MPEG-4，1表示MPEG-2</li><li>Layer: always: ‘00’</li><li>protection_absent: 表示是否误码校验。Warning, set to 1 if there is no CRC and 0 if there is CRC</li><li>profile: 表示使用哪个级别的ACC，如01 Low Complexity(LC) — AAC LC。有些芯片只支持ACC LC。</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>音视频</tag>
      
      <tag>ffmpeg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 vcpkg 下如何使用 pkg-config</title>
    <link href="/2025/06/10/how-use-pkgconfig/"/>
    <url>/2025/06/10/how-use-pkgconfig/</url>
    
    <content type="html"><![CDATA[<h1 id="在-vcpkg-下如何使用-pkg-config"><a href="#在-vcpkg-下如何使用-pkg-config" class="headerlink" title="在 vcpkg 下如何使用 pkg-config"></a>在 vcpkg 下如何使用 pkg-config</h1><p>笔主本人在用 vcpkg 安装 FFmpeg 的时候发现，安装完成的输出里面有对应库在cmake中的使用方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell">The following packages are already installed:<br>    ffmpeg[core,x265,x264,gpl,ffprobe,ffplay,ffmpeg,zlib,xml2,webp,vpx,vorbis,theora,tesseract,ssh,srt,speex,soxr,snappy,sdl2,qsv,opus,openmpt,openjpeg,openh264,opengl,opencl,nvcodec,mp3lame,modplug,lzma,ilbc,iconv,fribidi,freetype,fontconfig,dav1d,bzip2,ass,aom,amf,all,swscale,swresample,avformat,avfilter,avdevice,avcodec]:x64-windows@7.1.1#2<br>Total install time: 4.28 ms<br>ffmpeg provides CMake integration:<br><br>  find_package(FFMPEG REQUIRED)<br>  target_include_directories(main PRIVATE $&#123;FFMPEG_INCLUDE_DIRS&#125;)<br>  target_link_directories(main PRIVATE $&#123;FFMPEG_LIBRARY_DIRS&#125;)<br>  target_link_libraries(main PRIVATE $&#123;FFMPEG_LIBRARIES&#125;)<br><br>ffmpeg provides pkg-config modules:<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">FFmpeg codec library</span><br>  libavcodec<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">FFmpeg device handling library</span><br>  libavdevice<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">FFmpeg audio/video filtering library</span><br>  libavfilter<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">FFmpeg container format library</span><br>  libavformat<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">FFmpeg utility library</span><br>  libavutil<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">FFmpeg audio resampling library</span><br>  libswresample<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">FFmpeg image rescaling library</span><br>  libswscale<br><br></code></pre></td></tr></table></figure><p>使用第一种方法的时候，cmake会检索出所有的 ffmpeg 库，作为强迫症的我不太喜欢这种方式，感觉不优雅，于是发现第二种方法，通过 DeepSeek 的解释大致了解了用法</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(PkgConfig REQUIRED)<br>pkg_check_modules(AVCODEC REQUIRED libavcodec)<br>pkg_check_modules(AVFORMAT REQUIRED libavformat)<br><br><span class="hljs-keyword">target_link_libraries</span>(my_app PRIVATE<br>    <span class="hljs-variable">$&#123;AVCODEC_LIBRARIES&#125;</span><br>    <span class="hljs-variable">$&#123;AVFORMAT_LIBRARIES&#125;</span><br>)<br><span class="hljs-keyword">target_include_directories</span>(my_app PRIVATE <br>    <span class="hljs-variable">$&#123;AVCODEC_INCLUDE_DIRS&#125;</span><br>    <span class="hljs-variable">$&#123;AVFORMAT_INCLUDE_DIRS&#125;</span><br>)<br></code></pre></td></tr></table></figure><p>这样就可以精确控制 FFmpeg 的依赖项，而不会引入不必要的库</p><p><code>ls &lt;vcpkg-root&gt;/installed/&lt;triplet&gt;/lib/pkgconfig/</code><br>使用上述命令，就可以直接查看 pkgconfig&#x2F; 目录</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>CMake</tag>
      
      <tag>vcpkg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FFmpeg 解封装解码</title>
    <link href="/2025/06/10/ffmpeg-demux/"/>
    <url>/2025/06/10/ffmpeg-demux/</url>
    
    <content type="html"><![CDATA[<h1 id="FFmpeg-解封装解码"><a href="#FFmpeg-解封装解码" class="headerlink" title="FFmpeg 解封装解码"></a>FFmpeg 解封装解码</h1><h2 id="解封装"><a href="#解封装" class="headerlink" title="解封装"></a>解封装</h2><p><img src="/2025/03/21/file-io/emux/image1.png"></p><h2 id="封装格式相关函数"><a href="#封装格式相关函数" class="headerlink" title="封装格式相关函数"></a>封装格式相关函数</h2><ul><li><code>avformat_alloc_context();</code> 负责申请一个AVFormatContext结构的内存,并进行简单初始化</li><li><code>avformat_free_context();</code> 释放该结构里的所有东西以及该结构本身</li><li><code>avformat_close_input();</code> 关闭解复用器，关闭后就不再需要使用avformat_free_context 进行释放</li><li><code>avformat_open_input();</code> 打开输入视频文件</li><li><code>avformat_find_stream_info();</code> 获取视频文件信息</li><li><code>av_read_frame();</code> 读取音视频包</li><li><code>avformat_seek_file();</code> 定位文件</li><li><code>av_seek_frame();</code> 定位文件</li></ul><p><img src="/2025/03/21/file-io/emux/image2.png" alt="解封装流程图"></p><h2 id="FFmpeg-数据结构之间的关系"><a href="#FFmpeg-数据结构之间的关系" class="headerlink" title="FFmpeg 数据结构之间的关系"></a>FFmpeg 数据结构之间的关系</h2><h3 id="区分不同的码流"><a href="#区分不同的码流" class="headerlink" title="区分不同的码流"></a>区分不同的码流</h3><ul><li>AVMEDIA_TYPE_VIDEO 视频流: <code>videoIndex = av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);</code></li><li>AVMEDIA_TYPE_AUDIO 视频流: <code>videoIndex = av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO, -1, -1, NULL, 0);</code></li></ul><p>AVPacket 里面也有一个 index 字段</p><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p>avformat_open_input 和 avformat_find_stream_info 分别用于打开一个流和分析流信息。<br>在初始信息不足的情况下（比如FLV和H264文件），avformat_find_stream_info 接口需要在内部调用 read_frame_internal 接口读取流数据（音视频帧），然后再分析，设置核心数据结构 AVFomatContext。<br>由于需要读取数据包，avformat_find_stream_info 接口会带来很大的延迟。</p><p><a href="https://github.com/irisIsLove/LearnFFmpeg/tree/main/FFmpegDemux">解封装流程代码</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>音视频</tag>
      
      <tag>ffmpeg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FFmpeg 内存模型</title>
    <link href="/2025/06/09/ffmpeg-memory-model/"/>
    <url>/2025/06/09/ffmpeg-memory-model/</url>
    
    <content type="html"><![CDATA[<h1 id="FFmpeg-内存模型"><a href="#FFmpeg-内存模型" class="headerlink" title="FFmpeg 内存模型"></a>FFmpeg 内存模型</h1><ul><li>从现有的Packet拷贝一个新Packet的时候，有两种情况：<ol><li>两个Packet的buf引用的是同一数据缓存空间，这时候要注意数据缓存空间的释放问题；</li><li>两个Packet的buf引用不同的数据缓存空间，每个Packet都有数据缓存空间的copy</li></ol></li></ul><p><img src="/2025/03/21/file-io/emory-model/image1.png" alt="数据共享"> <img src="/2025/03/21/file-io/emory-model/image2.png" alt="数据独立"></p><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><ul><li>对于多个AVPacket共享同一个缓存空间，FFmpeg使用的引用计数的机制（reference-count）：<ul><li>初始化引用计数为0，只有真正分配AVBuffer的时候，引用计数初始化为1</li><li>当有新的Packet引用共享的缓存空间时，就将引用计数 +1</li><li>当释放了引用共享空间的Packet，就将引用计数-1；引用计数为0时，就释放掉引用的缓存空间AVBuffer</li></ul></li><li>AVFrame也是采用同样的机制</li></ul><h2 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h2><p><img src="/2025/03/21/file-io/emory-model/image3.png" alt="AVPacket 常用 API"> <img src="/2025/03/21/file-io/emory-model/image4.png" alt="AVFrame 常用 API"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>音视频</tag>
      
      <tag>ffmpeg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FFmpeg 库入门</title>
    <link href="/2025/06/09/ffmpeg-lib-base/"/>
    <url>/2025/06/09/ffmpeg-lib-base/</url>
    
    <content type="html"><![CDATA[<h1 id="FFmpeg-库入门"><a href="#FFmpeg-库入门" class="headerlink" title="FFmpeg 库入门"></a>FFmpeg 库入门</h1><h2 id="封装格式相关"><a href="#封装格式相关" class="headerlink" title="封装格式相关"></a>封装格式相关</h2><ul><li><code>avformat_alloc_context();</code> 负责申请一个AVFormatContext结构的内存,并进行简单初始化</li><li><code>avformat_free_context();</code> 释放该结构里的所有东西以及该结构本身</li><li><code>avformat_close_input();</code> 关闭解复用器,关闭后就不再需要使用 avformat_free_context 进行释放</li><li><code>avformat_open_input();</code> 打开输入视频文件</li><li><code>avformat_find_stream_info();</code> 获取音视频文件信息</li><li><code>av_read_frame();</code> 读取音视频包</li><li><code>avformat_seek_file();</code> 定位文件</li><li><code>av_seek_frame();</code> 定位文</li></ul><p><img src="/2025/03/21/file-io/ib-base/image1.png" alt="解封装流程图"></p><h2 id="解码器相关"><a href="#解码器相关" class="headerlink" title="解码器相关"></a>解码器相关</h2><ul><li><code>avcodec_alloc_context3();</code> 分配解码器上下文</li><li><code>avcodec_find_decoder();</code> 根据ID查找解码器</li><li><code>avcodec_find_decoder_by_name();</code> 根据解码器名字</li><li><code>avcodec_open2();</code> 打开编解码器</li><li><code>avcodec_send_packet();</code> 发送编码数据包</li><li><code>avcodec_receive_frame();</code> 接收解码后数据</li><li><code>avcodec_free_context();</code> 释放解码器上下文，包含了 avcodec_close()</li><li><code>avcodec_close();</code> 关闭解码器</li></ul><p><img src="/2025/03/21/file-io/ib-base/image2.png" alt="解码器流程图"></p><h2 id="FFmpeg-数据结构简介"><a href="#FFmpeg-数据结构简介" class="headerlink" title="FFmpeg 数据结构简介"></a>FFmpeg 数据结构简介</h2><ul><li>AVFormatContext<ul><li>封装格式上下文结构体，也是统领全局的结构体，保存了视频文件封装格式相关信息。</li></ul></li><li>AVInputFormat、AVOutputFormat<ul><li>每种封装格式（例如FLV, MKV, MP4, AVI）对应一个该结构体。</li></ul></li><li>AVStream<ul><li>视频文件中每个视频（音频）流对应一个该结构体。</li></ul></li><li>AVCodecContext<ul><li>编解码器上下文结构体，保存了视频（音频）编解码相关信息。</li></ul></li><li>AVCodec<ul><li>每种视频（音频）编解码器(例如H.264解码器)对应一个该结构体。</li></ul></li><li>AVPacket<ul><li>存储一帧压缩编码数据。</li></ul></li><li>AVFrame<ul><li>存储一帧解码后像素（采样）数据。</li></ul></li></ul><h2 id="FFmpeg-数据结构之间的关系"><a href="#FFmpeg-数据结构之间的关系" class="headerlink" title="FFmpeg 数据结构之间的关系"></a>FFmpeg 数据结构之间的关系</h2><p><img src="/2025/03/21/file-io/ib-base/image3.png"><br><img src="/2025/03/21/file-io/ib-base/image4.png"><br><img src="/2025/03/21/file-io/ib-base/image5.png"><br><img src="/2025/03/21/file-io/ib-base/image6.png"><br><img src="/2025/03/21/file-io/ib-base/image7.png"></p><h2 id="FFmpeg-数据结构分析"><a href="#FFmpeg-数据结构分析" class="headerlink" title="FFmpeg 数据结构分析"></a>FFmpeg 数据结构分析</h2><ul><li>AVFormatContext<ul><li>iformat：输入媒体的AVInputFormat，比如指向AVInputFormatff_flv_demuxer</li><li>nb_streams：输入媒体的AVStream 个数</li><li>streams：输入媒体的AVStream []数组</li><li>duration：输入媒体的时长（以微秒为单位），计算方式可以参考av_dump_format()函数。</li><li>bit_rate：输入媒体的码率</li></ul></li><li>AVInputFormat<ul><li>name：封装格式名称</li><li>extensions：封装格式的扩展名</li><li>id：封装格式ID</li><li>一些封装格式处理的接口函数,比如read_packet()</li></ul></li><li>AVStream<ul><li>index：标识该视频&#x2F;音频流</li><li>time_base：该流的时基，PTS*time_base&#x3D;真正的时间（秒）</li><li>avg_frame_rate：该流的帧率</li><li>duration：该视频&#x2F;音频流长度</li><li>codecpar：编解码器参数属性</li></ul></li><li>AVCodecParameters<ul><li>codec_type：媒体类型，比如AVMEDIA_TYPE_VIDEO、AVMEDIA_TYPE_AUDIO等</li><li>codec_id：编解码器类型， 比如AV_CODEC_ID_H264、AV_CODEC_ID_AAC等。</li></ul></li><li>AVCodecContext<ul><li>codec：编解码器的AVCodec，比如指向AVCodec ff_aac_latm_decoder</li><li>width, height：图像的宽高（只针对视频）</li><li>pix_fmt：像素格式（只针对视频）</li><li>sample_rate：采样率（只针对音频）</li><li>channels：声道数（只针对音频）</li><li>sample_fmt：采样格式（只针对音频）</li></ul></li><li>AVCodec<ul><li>name：编解码器名称</li><li>type：编解码器类型</li><li>id：编解码器ID</li><li>一些编解码的接口函数，比如int (*decode)()</li></ul></li><li>AVPacket<ul><li>pts：显示时间戳</li><li>dts：解码时间戳</li><li>data：压缩编码数据</li><li>size：压缩编码数据大小</li><li>pos:数据的偏移地址</li><li>stream_index：所属的AVStream</li></ul></li><li>AVFrame<ul><li>data：解码后的图像像素数据（音频采样数据）</li><li>linesize：对视频来说是图像中一行像素的大小；对音频来说是整个音频帧的大小</li><li>width, height：图像的宽高（只针对视频）</li><li>key_frame：是否为关键帧（只针对视频）</li><li>pict_type：帧类型（只针对视频） 。例如I， P， B</li><li>sample_rate：音频采样率（只针对音频）</li><li>nb_samples：音频每通道采样数（只针对音频）</li><li>pts：显示时间戳</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>音视频</tag>
      
      <tag>ffmpeg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL 播放 PCM 音频</title>
    <link href="/2025/06/05/sdl-pcm/"/>
    <url>/2025/06/05/sdl-pcm/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-播放-PCM-音频"><a href="#SDL-播放-PCM-音频" class="headerlink" title="SDL 播放 PCM 音频"></a>SDL 播放 PCM 音频</h1><h2 id="打开音频设备"><a href="#打开音频设备" class="headerlink" title="打开音频设备"></a>打开音频设备</h2><p><img src="/2025/03/21/file-io/image1.png"></p><h2 id="SDL-AudioCallback"><a href="#SDL-AudioCallback" class="headerlink" title="SDL_AudioCallback"></a>SDL_AudioCallback</h2><p><img src="/2025/03/21/file-io/image2.png"></p><h2 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;SDL.h&gt;</span></span><br><br><span class="hljs-comment">// 每次读取 2 帧数据，以 1024 个采样点为单位 2 通道 16bit 采样点</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PCM_BUFFER_SIZE (1024 * 2 * 2 * 2)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span>* sAudioBuf = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 音频 PCM 数据缓存</span><br><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span>* sAudioPos = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 目前读取的位置</span><br><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span>* sAudioEnd = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 缓存结束的位置</span><br><br><span class="hljs-type">void</span> <span class="hljs-comment">// 音频设备回调函数</span><br>onFillAudioPcm(<span class="hljs-type">void</span>* userdata, <span class="hljs-type">uint8_t</span>* stream, <span class="hljs-type">int</span> len)<br>&#123;<br>  SDL_memset(stream, <span class="hljs-number">0</span>, len);<br><br>  <span class="hljs-comment">// 数据读取完毕</span><br>  <span class="hljs-keyword">if</span> (sAudioPos &gt;= sAudioEnd) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 数据够了就读预设长度，不够就只读部分</span><br>  <span class="hljs-type">int</span> remainBufLen = (<span class="hljs-type">int</span>)(sAudioEnd - sAudioPos);<br>  len = (len &lt; remainBufLen) ? len : remainBufLen;<br><br>  <span class="hljs-comment">// 拷贝数据到 stream 并调整音量</span><br>  SDL_MixAudio(stream, sAudioPos, len, SDL_MIX_MAXVOLUME / <span class="hljs-number">8</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[onFillAudioPcm] len: %d\n&quot;</span>, len);<br>  sAudioPos += len;<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>  FILE* audio = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* audioPath = <span class="hljs-string">&quot;44100_16bit_2ch.pcm&quot;</span>;<br><br>  <span class="hljs-keyword">if</span> (SDL_Init(SDL_INIT_AUDIO)) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Could not initialize SDL - %s\n&quot;</span>, SDL_GetError());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  fopen_s(&amp;audio, audioPath, <span class="hljs-string">&quot;rb&quot;</span>);<br>  <span class="hljs-keyword">if</span> (!audio) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to open pcm file.\n&quot;</span>);<br>    <span class="hljs-keyword">goto</span> END;<br>  &#125;<br><br>  sAudioBuf = (<span class="hljs-type">uint8_t</span>*)<span class="hljs-built_in">malloc</span>(PCM_BUFFER_SIZE);<br><br>  <span class="hljs-comment">// 打开音频设备</span><br>  SDL_AudioSpec audioSpec;<br>  audioSpec.freq = <span class="hljs-number">44100</span>;          <span class="hljs-comment">// 采样频率</span><br>  audioSpec.format = AUDIO_S16SYS; <span class="hljs-comment">// 采样点格式</span><br>  audioSpec.channels = <span class="hljs-number">2</span>;          <span class="hljs-comment">// 通道数</span><br>  audioSpec.samples = <span class="hljs-number">1024</span>; <span class="hljs-comment">// 每次读取的样本数，多久产生一次回调和 samples 有关</span><br>                            <span class="hljs-comment">// 用 freq / sample 算出最多延迟多少毫秒</span><br>  audioSpec.callback = onFillAudioPcm;<br>  audioSpec.userdata = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">if</span> (SDL_OpenAudio(&amp;audioSpec, <span class="hljs-literal">NULL</span>)) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to open audio device - %s\n&quot;</span>, SDL_GetError());<br>    <span class="hljs-keyword">goto</span> END;<br>  &#125;<br><br>  <span class="hljs-comment">// 播放音频</span><br>  SDL_PauseAudio(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-type">size_t</span> dataCount = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// 从文件中读取数据</span><br>    <span class="hljs-type">size_t</span> readBufLen = fread(sAudioBuf, <span class="hljs-number">1</span>, PCM_BUFFER_SIZE, audio);<br>    <span class="hljs-keyword">if</span> (readBufLen &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    dataCount += readBufLen; <span class="hljs-comment">// 统计读取的数据总字节数</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now palying %10zu bytes.\n&quot;</span>, dataCount);<br>    sAudioEnd = sAudioBuf + readBufLen; <span class="hljs-comment">// 更新 buffer 起始位置</span><br>    sAudioPos = sAudioBuf;<br><br>    <span class="hljs-keyword">while</span> (sAudioPos &lt; sAudioEnd) &#123;<br>      SDL_Delay(<span class="hljs-number">2</span>); <span class="hljs-comment">// 等待 PCM 数据消耗</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Play over.\n&quot;</span>);<br>  SDL_CloseAudio();<br><br>END:<br>  <span class="hljs-keyword">if</span> (audio) &#123;<br>    fclose(audio);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (sAudioBuf) &#123;<br>    <span class="hljs-built_in">free</span>(sAudioBuf);<br>  &#125;<br>  SDL_Quit();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>音视频</tag>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL YUV 视频播放</title>
    <link href="/2025/06/05/sdl-yuv/"/>
    <url>/2025/06/05/sdl-yuv/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-YUV-视频播放"><a href="#SDL-YUV-视频播放" class="headerlink" title="SDL YUV 视频播放"></a>SDL YUV 视频播放</h1><h2 id="SDL-视频显示流程"><a href="#SDL-视频显示流程" class="headerlink" title="SDL 视频显示流程"></a>SDL 视频显示流程</h2><p><img src="/2025/03/21/file-io/image1.png" alt="SDL 视频显示流程"></p><h2 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;SDL.h&gt;</span></span><br><br><span class="hljs-comment">// 自定义消息类型</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REFRESH_EVENT (SDL_USEREVENT + 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> QUIT_EVENT (SDL_USEREVENT + 1)</span><br><br><span class="hljs-comment">// 定义分辨率</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> YUV_WIDTH 320</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> YUV_HEIGHT 240</span><br><br><span class="hljs-type">int</span> threadExitFlag = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">refreshVideoTimer</span><span class="hljs-params">(<span class="hljs-type">void</span>* data)</span><br>&#123;<br><br>  <span class="hljs-keyword">while</span> (!threadExitFlag) &#123;<br>    SDL_Event event;<br>    event.type = REFRESH_EVENT;<br>    SDL_PushEvent(&amp;event);<br>    SDL_Delay(<span class="hljs-number">40</span>);<br>  &#125;<br><br>  threadExitFlag = <span class="hljs-number">0</span>;<br><br>  SDL_Event event;<br>  event.type = QUIT_EVENT;<br>  SDL_PushEvent(&amp;event);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (SDL_Init(SDL_INIT_VIDEO)) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Could not initialize SDL - %s\n&quot;</span>, SDL_GetError());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  SDL_Event event;                           <span class="hljs-comment">// 事件</span><br>  SDL_Rect rect;                             <span class="hljs-comment">// 矩形</span><br>  SDL_Window* window = <span class="hljs-literal">NULL</span>;                 <span class="hljs-comment">// 窗口</span><br>  SDL_Renderer* renderer = <span class="hljs-literal">NULL</span>;             <span class="hljs-comment">// 渲染</span><br>  SDL_Texture* texture = <span class="hljs-literal">NULL</span>;               <span class="hljs-comment">// 纹理</span><br>  SDL_Thread* timerThread = <span class="hljs-literal">NULL</span>;            <span class="hljs-comment">// 刷新线程</span><br>  <span class="hljs-type">uint32_t</span> pixFormat = SDL_PIXELFORMAT_IYUV; <span class="hljs-comment">// YUV420P</span><br><br>  <span class="hljs-comment">// YUV分辨率</span><br>  <span class="hljs-type">int</span> videoWidth = YUV_WIDTH;<br>  <span class="hljs-type">int</span> videoHeight = YUV_HEIGHT;<br>  <span class="hljs-comment">// 窗口分辨率</span><br>  <span class="hljs-type">int</span> winWidth = YUV_WIDTH;<br>  <span class="hljs-type">int</span> winHeight = YUV_HEIGHT;<br><br>  <span class="hljs-comment">// YUV 文件句柄</span><br>  FILE* video = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* videoPath = <span class="hljs-string">&quot;yuv420p_320x240.yuv&quot;</span>;<br><br>  <span class="hljs-type">size_t</span> videoBufferLen = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">uint8_t</span>* videoBuffer = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-comment">// 帧长度 yuv420p 四个亮度搭一个色度</span><br>  <span class="hljs-type">uint32_t</span> yFrameLen = videoWidth * videoHeight;<br>  <span class="hljs-type">uint32_t</span> uFrameLen = yFrameLen / <span class="hljs-number">4</span>;<br>  <span class="hljs-type">uint32_t</span> vFrameLen = yFrameLen / <span class="hljs-number">4</span>;<br>  <span class="hljs-type">uint32_t</span> frameLen = yFrameLen + uFrameLen + vFrameLen;<br><br>  <span class="hljs-comment">// 创建窗口</span><br>  window = SDL_CreateWindow(<span class="hljs-string">&quot;SDL YUV Player&quot;</span>,<br>                            SDL_WINDOWPOS_UNDEFINED,<br>                            SDL_WINDOWPOS_UNDEFINED,<br>                            winWidth,<br>                            winHeight,<br>                            SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);<br>  <span class="hljs-keyword">if</span> (!window) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SDL: Could not create window - %s\n&quot;</span>, SDL_GetError());<br>    <span class="hljs-keyword">goto</span> END;<br>  &#125;<br><br>  renderer = SDL_CreateRenderer(window, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>  texture = SDL_CreateTexture(<br>    renderer, pixFormat, SDL_TEXTUREACCESS_TARGET, videoWidth, videoHeight);<br><br>  videoBuffer = (<span class="hljs-type">uint8_t</span>*)<span class="hljs-built_in">malloc</span>(frameLen);<br>  <span class="hljs-keyword">if</span> (!videoBuffer) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to alloc yuv frame space.\n&quot;</span>);<br>    <span class="hljs-keyword">goto</span> END;<br>  &#125;<br><br>  fopen_s(&amp;video, videoPath, <span class="hljs-string">&quot;rb&quot;</span>);<br>  <span class="hljs-keyword">if</span> (!video) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to open yuv file.\n&quot;</span>);<br>    <span class="hljs-keyword">goto</span> END;<br>  &#125;<br><br>  timerThread = SDL_CreateThread(refreshVideoTimer, <span class="hljs-string">&quot;RefreshVideoTimer&quot;</span>, <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-keyword">if</span> (!timerThread) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SDL: Could not create thread - %s\n&quot;</span>, SDL_GetError());<br>    <span class="hljs-keyword">goto</span> END;<br>  &#125;<br><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    SDL_WaitEvent(&amp;event);<br><br>    <span class="hljs-keyword">if</span> (event.type == REFRESH_EVENT) &#123;<br>      videoBufferLen = fread(videoBuffer, <span class="hljs-number">1</span>, frameLen, video);<br>      <span class="hljs-keyword">if</span> (videoBufferLen &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to read data from yuv file.\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> END;<br>      &#125;<br><br>      <span class="hljs-comment">// 设置纹理</span><br>      SDL_UpdateTexture(texture, <span class="hljs-literal">NULL</span>, videoBuffer, videoWidth);<br><br>      <span class="hljs-comment">// 显示区域，通过修改宽高来进行缩放</span><br>      rect.x = <span class="hljs-number">0</span>;<br>      rect.y = <span class="hljs-number">0</span>;<br>      <span class="hljs-type">float</span> wRatio = winWidth * <span class="hljs-number">1.0f</span> / videoWidth;<br>      <span class="hljs-type">float</span> hRatio = winHeight * <span class="hljs-number">1.0f</span> / videoHeight;<br>      rect.w = (<span class="hljs-type">int</span>)(videoWidth * wRatio);<br>      rect.h = (<span class="hljs-type">int</span>)(videoHeight * hRatio);<br><br>      <span class="hljs-comment">// 清空渲染器</span><br>      SDL_RenderClear(renderer);<br>      <span class="hljs-comment">// 渲染纹理</span><br>      SDL_RenderCopy(renderer, texture, <span class="hljs-literal">NULL</span>, &amp;rect);<br>      <span class="hljs-comment">// 更新渲染器</span><br>      SDL_RenderPresent(renderer);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.type == SDL_WINDOWEVENT) &#123;<br>      <span class="hljs-comment">// 获取窗口大小，更新窗口拖动</span><br>      SDL_GetWindowSize(window, &amp;winWidth, &amp;winHeight);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[SDL_WINDOWEVENT] width: %d, height: %d\n&quot;</span>, winWidth, winHeight);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.type == SDL_QUIT) &#123;<br>      threadExitFlag = <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.type == QUIT_EVENT) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>END:<br>  <span class="hljs-keyword">if</span> (videoBuffer) &#123;<br>    <span class="hljs-built_in">free</span>(videoBuffer);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (video) &#123;<br>    fclose(video);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (timerThread) &#123;<br>    SDL_WaitThread(timerThread, <span class="hljs-literal">NULL</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (texture) &#123;<br>    SDL_DestroyTexture(texture);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (renderer) &#123;<br>    SDL_DestroyRenderer(renderer);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (window) &#123;<br>    SDL_DestroyWindow(window);<br>  &#125;<br>  SDL_Quit();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>音视频</tag>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL 多线程</title>
    <link href="/2025/06/05/sdl-thread/"/>
    <url>/2025/06/05/sdl-thread/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-多线程"><a href="#SDL-多线程" class="headerlink" title="SDL 多线程"></a>SDL 多线程</h1><h2 id="SDL-多线程接口"><a href="#SDL-多线程接口" class="headerlink" title="SDL 多线程接口"></a>SDL 多线程接口</h2><p><img src="/2025/03/21/file-io/ad/image1.png" alt="SDL 多线程接口"></p><h2 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;SDL.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br>SDL_mutex* gLock = <span class="hljs-literal">NULL</span>;<br>SDL_cond* gCond = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">threadWork</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span><br>&#123;<br>  SDL_LockMutex(gLock);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;                                 &lt;========== ThreadWork Sleep.\n&quot;</span>);<br>  SDL_Delay(<span class="hljs-number">10000</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;                                 &lt;========== ThreadWork Wait.\n&quot;</span>);<br><br>  SDL_CondWait(<br>    gCond, gLock); <span class="hljs-comment">// 进入等待状态，释放锁，等到被唤醒时且锁被释放才会继续进行</span><br>  <span class="hljs-built_in">printf</span>(<br>    <span class="hljs-string">&quot;                                 &lt;========== ThreadWork Receive Signal, &quot;</span><br>    <span class="hljs-string">&quot;Continue to do ~_~!!!.\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;                                 &lt;========== ThreadWork Done.\n&quot;</span>);<br><br>  SDL_UnlockMutex(gLock);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>  gLock = SDL_CreateMutex();<br>  gCond = SDL_CreateCond();<br><br>  SDL_Thread* t = SDL_CreateThread(threadWork, <span class="hljs-string">&quot;ThreadWork&quot;</span>, <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-keyword">if</span> (!t) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  %s\n&quot;</span>, SDL_GetError());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; ++i) &#123;<br>    SDL_Delay(<span class="hljs-number">2000</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MainThread Execute. ==========&gt;\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MainThread LockMutex before. ==========&gt;\n&quot;</span>);<br>  SDL_LockMutex(gLock); <span class="hljs-comment">// 等待子线程进入 CondWait 状态才能拿到锁</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MainThread ready send signal. ==========&gt;\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MainThread CondSignal before. ==========&gt;\n&quot;</span>);<br>  SDL_CondSignal(gCond); <span class="hljs-comment">// 获取到锁，发送信号，唤醒等待线程</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MainThread CondSignal after. =========&gt;\n&quot;</span>);<br>  SDL_UnlockMutex(gLock); <span class="hljs-comment">// 释放锁，子线程才能拿到锁</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MainThread UnlockMutex after. =========&gt;\n&quot;</span>);<br><br>  <span class="hljs-comment">// 资源销毁</span><br>  SDL_WaitThread(t, <span class="hljs-literal">NULL</span>);<br>  SDL_DestroyCond(gCond);<br>  SDL_DestroyMutex(gLock);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>音视频</tag>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL 事件处理</title>
    <link href="/2025/06/04/sdl-event/"/>
    <url>/2025/06/04/sdl-event/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-事件处理"><a href="#SDL-事件处理" class="headerlink" title="SDL 事件处理"></a>SDL 事件处理</h1><h2 id="SDL-事件处理接口"><a href="#SDL-事件处理接口" class="headerlink" title="SDL 事件处理接口"></a>SDL 事件处理接口</h2><p><img src="/2025/03/21/file-io/t/image1.png"></p><h2 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;SDL.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CUSTOM_QUIT_EVENT (SDL_USEREVENT + 0) <span class="hljs-comment">// 用户自定义事件</span></span><br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>  SDL_Window* window = <span class="hljs-literal">NULL</span>;<br>  SDL_Renderer* renderer = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-comment">// 初始化SDL</span><br>  SDL_Init(SDL_INIT_VIDEO);<br><br>  <span class="hljs-comment">// 创建窗口</span><br>  window = SDL_CreateWindow(<span class="hljs-string">&quot;SDL Event Window&quot;</span>,<br>                            SDL_WINDOWPOS_UNDEFINED,<br>                            SDL_WINDOWPOS_UNDEFINED,<br>                            <span class="hljs-number">640</span>,<br>                            <span class="hljs-number">480</span>,<br>                            SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);<br>  <span class="hljs-keyword">if</span> (!window) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Can&#x27;t create window, err: %s&quot;</span>, SDL_GetError());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 创建渲染器</span><br>  renderer = SDL_CreateRenderer(window, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (!renderer) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Can&#x27;t create renderer, err: %s&quot;</span>, SDL_GetError());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  SDL_SetRenderDrawColor(renderer, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>); <span class="hljs-comment">// 设置窗口为红色</span><br>  SDL_RenderClear(renderer);<br>  SDL_RenderPresent(renderer);<br><br>  SDL_Event event;<br>  <span class="hljs-type">int</span> quit = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    SDL_WaitEvent(&amp;event); <span class="hljs-comment">// 等待事件</span><br>    <span class="hljs-keyword">switch</span> (event.type) &#123;<br>      <span class="hljs-keyword">case</span> SDL_KEYDOWN: <span class="hljs-comment">// 处理键盘按下</span><br>        <span class="hljs-keyword">switch</span> (event.key.keysym.sym) &#123;<br>          <span class="hljs-keyword">case</span> SDLK_a:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;key down a\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">case</span> SDLK_s:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;key down s\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">case</span> SDLK_d:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;key down d\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">case</span> SDLK_q:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;key down q and push quit event\n&quot;</span>);<br>            SDL_Event quitEvent;<br>            quitEvent.type = CUSTOM_QUIT_EVENT;<br>            SDL_PushEvent(&amp;quitEvent);<br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">default</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;key down 0x%x\n&quot;</span>, event.key.keysym.sym);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> SDL_MOUSEBUTTONDOWN: <span class="hljs-comment">// 处理鼠标按下</span><br>        <span class="hljs-keyword">if</span> (event.button.button == SDL_BUTTON_LEFT) &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mouse down left\n&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.button.button == SDL_BUTTON_RIGHT) &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mouse down right\n&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mouse down %d\n&quot;</span>, event.button.button);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> SDL_MOUSEMOTION: <span class="hljs-comment">// 处理鼠标移动</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mouse move (%d, %d)\n&quot;</span>, event.button.x, event.button.y);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> CUSTOM_QUIT_EVENT: <span class="hljs-comment">// 处理自定义事件</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;receive quit event\n&quot;</span>);<br>        quit = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (quit) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  SDL_DestroyRenderer(renderer);<br>  SDL_DestroyWindow(window);<br>  SDL_Quit();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>音视频</tag>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL 基础</title>
    <link href="/2025/06/04/sdl-base/"/>
    <url>/2025/06/04/sdl-base/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-基础"><a href="#SDL-基础" class="headerlink" title="SDL 基础"></a>SDL 基础</h1><h2 id="SDL-视频显示函数"><a href="#SDL-视频显示函数" class="headerlink" title="SDL 视频显示函数"></a>SDL 视频显示函数</h2><p><img src="/2025/03/21/file-io/image1.png" alt="SDL 视频显示函数介绍"><br><img src="/2025/03/21/file-io/image2.png" alt="SDL 数据结构介绍"></p><h2 id="直接上代码"><a href="#直接上代码" class="headerlink" title="直接上代码"></a>直接上代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;SDL.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>  <span class="hljs-type">int</span> run = <span class="hljs-number">1</span>;<br>  SDL_Window* window = <span class="hljs-literal">NULL</span>;<br>  SDL_Renderer* renderer = <span class="hljs-literal">NULL</span>;<br>  SDL_Texture* texture = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-comment">// 显示小方块的大小</span><br>  SDL_Rect rect;<br>  rect.w = <span class="hljs-number">50</span>;<br>  rect.h = <span class="hljs-number">50</span>;<br><br>  <span class="hljs-comment">// 初始化SDL</span><br>  SDL_Init(SDL_INIT_VIDEO);<br><br>  <span class="hljs-comment">// 创建窗口</span><br>  window = SDL_CreateWindow(<span class="hljs-string">&quot;SDL Window&quot;</span>,<br>                            SDL_WINDOWPOS_UNDEFINED,<br>                            SDL_WINDOWPOS_UNDEFINED,<br>                            <span class="hljs-number">640</span>,<br>                            <span class="hljs-number">480</span>,<br>                            SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);<br>  <span class="hljs-keyword">if</span> (!window) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Can&#x27;t create window, err: %s&quot;</span>, SDL_GetError());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 创建渲染器</span><br>  renderer = SDL_CreateRenderer(window, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (!renderer) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Can&#x27;t create renderer, err: %s&quot;</span>, SDL_GetError());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 创建纹理</span><br>  texture = SDL_CreateTexture(<br>    renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_TARGET, <span class="hljs-number">640</span>, <span class="hljs-number">480</span>);<br>  <span class="hljs-keyword">if</span> (!texture) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Can&#x27;t create texture, err: %s&quot;</span>, SDL_GetError());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-type">int</span> showCount = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (run) &#123;<br>    rect.x = rand() % <span class="hljs-number">600</span>;<br>    rect.y = rand() % <span class="hljs-number">400</span>;<br><br>    SDL_SetRenderTarget(renderer, texture);         <span class="hljs-comment">// 设置渲染目标为纹理</span><br>    SDL_SetRenderDrawColor(renderer, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>); <span class="hljs-comment">// 纹理背景色为黑色</span><br>    SDL_RenderClear(renderer);                      <span class="hljs-comment">// 清空纹理</span><br><br>    SDL_RenderDrawRect(renderer, &amp;rect); <span class="hljs-comment">// 在纹理上绘制一个矩形</span><br>    SDL_SetRenderDrawColor(renderer, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>); <span class="hljs-comment">// 设置颜色为白色</span><br>    SDL_RenderFillRect(renderer, &amp;rect);                  <span class="hljs-comment">// 在纹理上填充矩形</span><br><br>    SDL_SetRenderTarget(renderer, <span class="hljs-literal">NULL</span>);           <span class="hljs-comment">// 设置渲染目标为窗口</span><br>    SDL_RenderCopy(renderer, texture, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 拷贝纹理到 CPU</span><br><br>    SDL_RenderPresent(renderer); <span class="hljs-comment">// 输出到目标窗口上</span><br>    SDL_Delay(<span class="hljs-number">300</span>);<br>    <span class="hljs-keyword">if</span> (showCount++ &gt; <span class="hljs-number">30</span>) &#123;<br>      run = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br><br>  SDL_DestroyTexture(texture);<br>  SDL_DestroyRenderer(renderer);<br>  SDL_DestroyWindow(window);<br>  SDL_Quit();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>音视频</tag>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FFmpeg 基础命令</title>
    <link href="/2025/06/04/ffmpeg-base-cmd/"/>
    <url>/2025/06/04/ffmpeg-base-cmd/</url>
    
    <content type="html"><![CDATA[<h1 id="FFmpeg-基础命令"><a href="#FFmpeg-基础命令" class="headerlink" title="FFmpeg 基础命令"></a>FFmpeg 基础命令</h1><h2 id="ffmpeg-ffplay-ffprobe-区别"><a href="#ffmpeg-ffplay-ffprobe-区别" class="headerlink" title="ffmpeg &#x2F; ffplay &#x2F; ffprobe 区别"></a>ffmpeg &#x2F; ffplay &#x2F; ffprobe 区别</h2><ul><li>ffmpeg<ul><li>Hyper fast Audio and Video encoder</li><li>超快音视频解码器 (类似爱剪辑)</li></ul></li><li>ffplay<ul><li>Simple media player</li><li>简单媒体播放器</li></ul></li><li>ffprobe<ul><li>Simple multimedia streams analyzer</li><li>简单多媒体流分析器</li></ul></li></ul><h2 id="基础使用方法"><a href="#基础使用方法" class="headerlink" title="基础使用方法"></a>基础使用方法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">ffmpeg</span><br>ffmpeg [options] [[infile options] -i infile]... &#123;[outfile options] outfile&#125;...<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ffplay</span><br>ffplay [options] input_file<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ffprobe</span><br>ffprobe [OPTIONS] [INPUT_FILE]<br></code></pre></td></tr></table></figure><h2 id="文档查看命令"><a href="#文档查看命令" class="headerlink" title="文档查看命令"></a>文档查看命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">ffmpeg</span><br>ffmpeg -h # 基本信息<br>ffmpeg -h long # 高级信息<br>ffmpeg -h full # 所有信息<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ffply</span><br>ffmpeg -h <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ffprobe</span><br>ffprobe -h<br></code></pre></td></tr></table></figure><h2 id="FFmpeg-音视频处理流程"><a href="#FFmpeg-音视频处理流程" class="headerlink" title="FFmpeg 音视频处理流程"></a>FFmpeg 音视频处理流程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将一个 1920x1080 的 mp4 文件转换成 1280x720 的 flv 文件</span><br>ffmpeg -i test_1920x1080.mp4 -acodec copy -vcodec libx264 -s 1280x720 test_1280x720.flv<br></code></pre></td></tr></table></figure><p><img src="/2025/03/21/file-io/ase-cmd/image1.png" alt="FFmpeg 音视频处理流程图"></p><h2 id="FFmpeg-常用命令分类"><a href="#FFmpeg-常用命令分类" class="headerlink" title="FFmpeg 常用命令分类"></a>FFmpeg 常用命令分类</h2><p><img src="/2025/03/21/file-io/ase-cmd/image2.png" alt="FFmpeg 常用命令分类"></p><ul><li>查看具体分类所支持的参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">语法</span><br>ffmpeg -h type=name<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">例子</span><br>ffmpeg -h muxer=flv<br>ffmpeg -h filter=atempo # atempo 调整音频播放速率<br>ffmpeg -h encoder=libx264<br></code></pre></td></tr></table></figure><h2 id="FFplay-播放控制"><a href="#FFplay-播放控制" class="headerlink" title="FFplay 播放控制"></a>FFplay 播放控制</h2><p>下列快捷键需要配合 alt 使用<br><img src="/2025/03/21/file-io/ase-cmd/image3.png"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>音视频</tag>
      
      <tag>ffmpeg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 vscode 中是用 CTest 进行单测调试</title>
    <link href="/2025/05/15/ctest-debug/"/>
    <url>/2025/05/15/ctest-debug/</url>
    
    <content type="html"><![CDATA[<h1 id="在-vscode-中是用-CTest-进行单测调试"><a href="#在-vscode-中是用-CTest-进行单测调试" class="headerlink" title="在 vscode 中是用 CTest 进行单测调试"></a>在 vscode 中是用 CTest 进行单测调试</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果没有进行特别的配置的话，在 vscode 中的 CTest 是无法进行单测调试的。</p><p><img src="/2025/03/21/file-io/bug/image1.png"></p><p>如上图所示，会显示 <code>未找到启动配置</code>。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在 .vscode 目录中添加一个 launch.json 文件来进行调试配置，文件内容如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">// 使用 IntelliSense 了解相关属性。 </span><br>    <span class="hljs-comment">// 悬停以查看现有属性的描述。</span><br>    <span class="hljs-comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(ctest) Launch&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppvsdbg&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;cmake.testProgram&#125;&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;$&#123;cmake.testArgs&#125;&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;cmake.testWorkingDirectory&#125;&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;console&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integratedTerminal&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>配置成功后，再进行调试，就成功了。</p><p><img src="/2025/03/21/file-io/bug/image2.png"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake 中使用 grpc ( 使用 vcpkg 安装 grpc )</title>
    <link href="/2025/05/09/grpc-cmake/"/>
    <url>/2025/05/09/grpc-cmake/</url>
    
    <content type="html"><![CDATA[<h1 id="CMake-中使用-grpc-使用-vcpkg-安装-grpc"><a href="#CMake-中使用-grpc-使用-vcpkg-安装-grpc" class="headerlink" title="CMake 中使用 grpc ( 使用 vcpkg 安装 grpc )"></a>CMake 中使用 grpc ( 使用 vcpkg 安装 grpc )</h1><p>用 vcpkg 安装 grpc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vcpkg install grpc<br></code></pre></td></tr></table></figure><p>cmake 文件中源码</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(gRPC CONFIG REQUIRED)  <span class="hljs-comment"># 查找库</span><br><br><span class="hljs-comment"># 查找工具链</span><br><span class="hljs-keyword">get_target_property</span>(PROTOC protobuf::protoc LOCATION)<br><span class="hljs-keyword">get_target_property</span>(GRPC_PLUGIN gRPC::grpc_cpp_plugin LOCATION)<br><br><span class="hljs-keyword">set</span>(PROTO_SRCS <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">set</span>(PROTO_HDRS <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">set</span>(GRPC_SRCS <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">set</span>(GRPC_HDRS <span class="hljs-string">&quot;&quot;</span>)<br><br><span class="hljs-comment"># 创建生成文件夹</span><br><span class="hljs-keyword">file</span>(<span class="hljs-keyword">MAKE_DIRECTORY</span> messages)<br><span class="hljs-comment"># 查找 proto 源文件</span><br><span class="hljs-keyword">file</span>(GLOB PROTO_FILES <span class="hljs-string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/protos/*.proto&quot;</span>)<br><br><span class="hljs-comment"># 遍历源文件</span><br><span class="hljs-keyword">foreach</span>(PROTO_FILE <span class="hljs-variable">$&#123;PROTO_FILES&#125;</span>)<br>    <span class="hljs-keyword">get_filename_component</span>(PROTO_NAME <span class="hljs-variable">$&#123;PROTO_FILE&#125;</span> NAME) <span class="hljs-comment"># 获取文件名 (带扩展)</span><br>    <span class="hljs-keyword">get_filename_component</span>(PROTO_NAME_WE <span class="hljs-variable">$&#123;PROTO_FILE&#125;</span> NAME_WE) <span class="hljs-comment"># 获取文件名 (不带扩展)</span><br><br>    <span class="hljs-comment"># 生成 proto 对应的 .cc 文件和 .h 文件</span><br>    <span class="hljs-keyword">add_custom_command</span>(<br>        OUTPUT <span class="hljs-string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/messages/$&#123;PROTO_NAME_WE&#125;.pb.h&quot;</span> <span class="hljs-string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/messages/$&#123;PROTO_NAME_WE&#125;.pb.cc&quot;</span><br>        <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;PROTOC&#125;</span><br>        ARGS<br>        -I<span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/protos<br>        --cpp_out=<span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/messages<br>        <span class="hljs-variable">$&#123;PROTO_NAME&#125;</span><br>        DEPENDS <span class="hljs-variable">$&#123;PROTO_FILE&#125;</span><br>        COMMENT <span class="hljs-string">&quot;Generating proroto sources for $&#123;PROTO_NAME&#125;&quot;</span><br>    )<br>    <span class="hljs-comment"># 装入对应的 proto 列表中</span><br>    <span class="hljs-keyword">list</span>(APPEND PROTO_SRCS <span class="hljs-string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/messages/$&#123;PROTO_NAME_WE&#125;.pb.cc&quot;</span>)<br>    <span class="hljs-keyword">list</span>(APPEND PROTO_HDRS <span class="hljs-string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/messages/$&#123;PROTO_NAME_WE&#125;.pb.h&quot;</span>)<br><br>    <span class="hljs-comment"># 生成 gRPC 对应的 .cc 文件和 .h 文件</span><br>    <span class="hljs-keyword">add_custom_command</span>(<br>        OUTPUT <span class="hljs-string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/messages/$&#123;PROTO_NAME_WE&#125;.grpc.pb.h&quot;</span> <span class="hljs-string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/messages/$&#123;PROTO_NAME_WE&#125;.grpc.pb.cc&quot;</span><br>        <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;PROTOC&#125;</span><br>        ARGS<br>        -I<span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/protos<br>        --cpp_out=<span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/messages<br>        --plugin=protoc-gen-grpc=<span class="hljs-variable">$&#123;GRPC_PLUGIN&#125;</span><br>        --grpc_out=<span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/messages<br>        <span class="hljs-variable">$&#123;PROTO_NAME&#125;</span><br>        DEPENDS <span class="hljs-variable">$&#123;PROTO_FILE&#125;</span><br>        COMMENT <span class="hljs-string">&quot;Generating gRPC sources for $&#123;PROTO_NAME&#125;&quot;</span><br>    )<br><br>    <span class="hljs-comment"># 装入对应的 grpc 列表中</span><br>    <span class="hljs-keyword">list</span>(APPEND GRPC_SRCS <span class="hljs-string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/messages/$&#123;PROTO_NAME_WE&#125;.grpc.pb.cc&quot;</span>)<br>    <span class="hljs-keyword">list</span>(APPEND GRPC_HDRS <span class="hljs-string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/messages/$&#123;PROTO_NAME_WE&#125;.grpc.pb.h&quot;</span>)<br><span class="hljs-keyword">endforeach</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>grpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络编程 (四)</title>
    <link href="/2025/04/10/net-prog4/"/>
    <url>/2025/04/10/net-prog4/</url>
    
    <content type="html"><![CDATA[<h1 id="网络编程-四"><a href="#网络编程-四" class="headerlink" title="网络编程 (四)"></a>网络编程 (四)</h1><h2 id="多路-IO-poll"><a href="#多路-IO-poll" class="headerlink" title="多路 IO - poll"></a>多路 IO - poll</h2><ul><li>函数原型：<code>int poll(struct pollfd *fds, nfds_t nfds, int timeout);</code><ul><li>函数说明：跟 select 相似，监控多路 IO，但 poll 不能跨平台</li><li>参数说明：<ul><li>fds：传入传出参数，实际上是一个结构体数组</li><li>fds.events：<ul><li>POLLIN —&gt; 读事件</li><li>POLLOUT —&gt; 写事件</li></ul></li><li>nfds：数组实际有效内容个数</li><li>timeout：超时时间，单位是毫秒<ul><li>-1：永久阻塞，知道监控的事件发生</li><li>0：不管是否有事件发生，立刻返回</li><li>&gt;0：直到监控的事件发生或者超时</li></ul></li></ul></li><li>返回值：<ul><li>成功：返回就绪事件的个数</li><li>失败：返回 -1 <br> 若 timeout &#x3D; 0，poll 函数不阻塞，且没有事件发生，此时返回 -1，并且 errno &#x3D; EAGAIN，这种情况不应该视为错误</li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> </span><br><span class="hljs-class">&#123;</span><br>   <span class="hljs-type">int</span>   fd;         <span class="hljs-comment">/* file descriptor */</span>   监控的文件描述符<br>   <span class="hljs-type">short</span> events;     <span class="hljs-comment">/* requested events */</span>  要监控的事件---不会被修改<br>   <span class="hljs-type">short</span> revents;    <span class="hljs-comment">/* returned events */</span>   返回发生变化的事件 ---由内核返回<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>说明：<ol><li>当 poll 函数返回的时候，结构体当中的 fd 和 event是 没有发生变化，究竟有没有事件发生由 revents 来判断，所以 poll 是请求和返回分离。</li><li>struct pollfd 结构体中的 fd 成员若赋值为 -1，则 poll 不会监控</li><li>相对于 select，poll 没有本质上的改变；但是 poll 可以突破 1024 的限制</li></ol></li></ul><h2 id="多路-IO-epoll"><a href="#多路-IO-epoll" class="headerlink" title="多路 IO - epoll"></a>多路 IO - epoll</h2><p>将检测文件描述符的变化委托给内核去处理，然后内核将发生变化的文件描述符对应的事件返回给应用程序。</p><ul><li>函数原型：<code>int epoll_create(int size);</code><ul><li>函数说明：创建一个树根</li><li>参数说明：<ul><li>size：最大节点数，次参数再 linux 2.6.8 已被忽略，但必须传递一个大于 0 的数。</li></ul></li><li>返回值：<ul><li>成功：返回一个大于 0 的文件描述符，待变整个树的树根</li><li>失败：返回 -1，并设置 errno</li></ul></li></ul></li><li>函数原型：<code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code><ul><li>函数说明：将要监听的节点在 epoll 树上添加，删除和修改</li><li>参数说明：<ul><li>epfd：epoll 树根</li><li>op：<ul><li>EPOLL_CTL_ADD：添加事件节点到树上</li><li>EPOLL_CTL_DEL：从树上删除事件节点</li><li>EPOLL_CTL_MOD：修改树上对应的事件节点</li></ul></li><li>fd：事件节点对应的文件描述符</li><li>event：要操作的事件节点<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">epoll_data</span> &#123;</span><br>  <span class="hljs-type">void</span>        *ptr;<br>  <span class="hljs-type">int</span>          fd;<br>  <span class="hljs-type">uint32_t</span>     u32;<br>  <span class="hljs-type">uint64_t</span>     u64;<br>&#125; <span class="hljs-type">epoll_data_t</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> &#123;</span><br>  <span class="hljs-type">uint32_t</span>     events;      <span class="hljs-comment">/* Epoll events */</span><br>  <span class="hljs-type">epoll_data_t</span> data;        <span class="hljs-comment">/* User data variable */</span><br>&#125;;<br></code></pre></td></tr></table></figure>event-&gt;events 常用的有：<ul><li>EPOLLIN：读事件</li><li>EPOLLOUT：写事件</li><li>EPOLLERR：错误事件</li><li>EPOLLET：边缘触发模式<br>event-&gt;fd：要监控的事件对应的文件描述符</li></ul></li></ul></li></ul></li><li>函数原型：<code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</code><ul><li>函数说明：等待内核返回事件发生</li><li>参数说明：<ul><li>epfd：epoll 树根</li><li>events：传出参数，其实是一个事件结构体数组</li><li>maxevents：数组大小</li><li>timeout：<ul><li>-1：表示永久阻塞</li><li>0：立即返回</li><li>&gt;0：表示超时等待事件</li></ul></li></ul></li><li>返回值：<ul><li>成功：返回发生事件的个数</li><li>失败：若 timeout &#x3D; 0，没有事件发生则返回；返回 -1，设置 errno 值</li></ul></li></ul></li></ul><p>epoll_wait 的 events 是一个传出参数，调用 epoll_ctl 传递给内核什么值，epoll_wait 返回的时候，内核就传回什么值，不糊对 struct event 的结构体变量的值做任何修改</p><h2 id="进阶-epoll"><a href="#进阶-epoll" class="headerlink" title="进阶 epoll"></a>进阶 epoll</h2><h3 id="epoll-的两种工作模式"><a href="#epoll-的两种工作模式" class="headerlink" title="epoll 的两种工作模式"></a>epoll 的两种工作模式</h3><p>LT ：水平触发，高电平代表 1，只要缓冲区有数据，就一直通知<br>ET ：边缘触发，电平有变化就代表 1，缓冲区有数据就只会通知一次，之后再有数据才会通知。(若是读数据的时候没有读完，则剩余的数据不会再通知，直到有新的数据到来)。</p><p>ET 模式由于只通知一次，所以在读的时候要循环读，直到读完，但是当读完之后 read 就会阻塞，所以应该将该文件描述符设置为非阻塞模式</p><p>read 函数在非阻塞模式下读的时候，若返回 -1，且 errno 为 EAGAIN，则表示当前资源不可用，也就是说缓冲区无数据 (缓冲区的数据已经读完了)；或者当 read 返回的读到的数据长度小于请求的数据长度时，就可以确定此时缓冲区已没有数据可读了，也就可以认为此时读事件已经处理完毕。</p><h3 id="epoll-反应堆"><a href="#epoll-反应堆" class="headerlink" title="epoll 反应堆"></a>epoll 反应堆</h3><p>反应堆：一个小时件出发一系列反应</p><p>epoll 反应堆的思想：</p><ul><li>将描述符，事件，对应的处理方法封装在一起</li><li>当描述符对应的事件发生了，自动调用处理方法 (原理就是回调函数)<br><img src="/2025/03/21/file-io/4/image1.png"></li></ul><p>核心思想：在调用 epoll_ctl 函数的时候，将 events 上树的时候，利用 epoll_data_t 的 ptr 成员，将一个文件描述符，事件和回调函数封装成一个结构体，然后让 ptr 指向这个结构体，然后 调用 epoll_wait 函数返回的手，可以的到具体的 events，然后获得 events 结构体中的 events.data.ptr 指针，ptr 中有回调函数，最终可以调用这个回调函数<br><img src="/2025/03/21/file-io/4/image2.png"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>C/C++</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络编程 (三)</title>
    <link href="/2025/04/10/net-prog3/"/>
    <url>/2025/04/10/net-prog3/</url>
    
    <content type="html"><![CDATA[<h1 id="网络编程-三"><a href="#网络编程-三" class="headerlink" title="网络编程 (三)"></a>网络编程 (三)</h1><h2 id="TCP-状态转换"><a href="#TCP-状态转换" class="headerlink" title="TCP 状态转换"></a>TCP 状态转换</h2><p><img src="/2025/03/21/file-io/3/image1.png" alt="TCP 状态转换图"></p><p>说明：上图中粗线表示主动方，虚线便是被动方，细线部分表示一些特殊情况，了解即可，不必深入研究<br>对于建立连接的过程客户端属于主动方，服务端数据被动接收方 (图的上半部分)<br>对于关闭 (图的下半部分)，客户端和服务端都可以先进行关闭<br>处于 ESTABLISHED 状态的升级后就可以收发数据了，双方在通信过程中一直处于 ESTABLISHED 状态，数据传输期间没有状态变化。</p><p>TIME_WAIT 状态一定是出现在主动关闭的一方<br>主动关闭的 socket 端会进入 TIME_WAIT 状态，并且持续 2MSL 时间长度，MSL 就是 maximum segment lifetime (最大分节生命期)，这是一个 IP 数据包能在互联网上生存的最长时间，超过这个时间将在网络中消失。</p><p>使用 <code>netstat -anp</code> 可以查看连接状态</p><p><img src="/2025/03/21/file-io/3/image2.png"><br>注：数据传输的时候带了一个字节的数据，所以 server 发送给client 的 ACK &#x3D; x + 2</p><p>为什么需要 2MSL？</p><ol><li>让四次挥手的过程更可靠，确保最后一个发送给对方的 ACK 到达；若对方没有收到 ACK 应答，对方再次发送 FIN 请求关闭，此时在 2MSL 时间内被动关闭方仍然可以发送 ACK 给对方</li><li>为了保证在 2MSL 时间内，不能启动相同的 socket-pair。TIME_WAIT 一定是出现在主动关闭的乙方，也就是说 2MSL 是针对主动关闭的一方来说的；由于 TCP 有可能存在丢包重传，丢包重传若发给了已经断开连接之后相同的 socket-pair (该连接是新建的，与原来的 socket-pair 完全相同，双方使用的是相同的 IP 和端口)，这样会对之后的连接造成困扰，严重可能引起程序异常。</li></ol><h2 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h2><p>当出现 <code>bind error: Address already in use</code> 这样的问题后，就可以使用端口复用来解决</p><p>函数原型：<code>int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);</code><br>使用例子：<code>setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(int));</code></p><p>具体函数说明可以参考 《UNIX 环境高级编程》</p><h2 id="半关闭状态"><a href="#半关闭状态" class="headerlink" title="半关闭状态"></a>半关闭状态</h2><h3 id="半关闭的概念"><a href="#半关闭的概念" class="headerlink" title="半关闭的概念"></a>半关闭的概念</h3><p>如果一方 close，另一方没有 close，则认为是半关闭状态，处于半关闭状态的时候，可以接收数据，但是不能发送数据。相当于把文件描述符的写缓冲区操纵关闭了。<br>注意：半关闭一定是出现在主动关闭的一方</p><h3 id="shutdown-函数"><a href="#shutdown-函数" class="headerlink" title="shutdown 函数"></a>shutdown 函数</h3><p>长连接和短链接的概念：<br> 连接建立后一直不关闭为长连接 <br> 连接收发数据完毕之后就关闭为短链接</p><h3 id="shutdown-和-close-的区别"><a href="#shutdown-和-close-的区别" class="headerlink" title="shutdown 和 close 的区别"></a>shutdown 和 close 的区别</h3><p>shutdown 能够把文件描述符上的读或者写操作关闭，而 close 关闭文件描述符只是将连接的引用计数的值减一，当减到零就真正关闭文件描述符了。</p><p>如：调用 dup 函数或者 dup2 函数可以复制一个文件描述符，close 其中一个并不影响另一个文件描述符，而 shutdown 就不同了，一旦 shutdown 了其中一个文件描述符，对所有的文件描述符都有影响。</p><h2 id="心跳包"><a href="#心跳包" class="headerlink" title="心跳包"></a>心跳包</h2><p>一般心跳包用于长连接，用于检查与对方网络连接是否正常</p><ul><li>方法一：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> keepAlive = <span class="hljs-number">1</span>;<br>setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (<span class="hljs-type">void</span>*)&amp;keepAlive, <span class="hljs-keyword">sizeof</span>(keepAlive));<br></code></pre></td></tr></table></figure>由于不能实时的检查网络情况，一般不用这种方法</li><li>方法二： <br> 在应用程序中自己定义心跳包，使用灵活，能够实时把控。</li></ul><h2 id="高并发服务器模型-–-select"><a href="#高并发服务器模型-–-select" class="headerlink" title="高并发服务器模型 – select"></a>高并发服务器模型 – select</h2><p>多路 IO 技术：select，同时监听多个文件描述符，将监控的操作交给内核去处理。</p><p>数据类型：<br>fd_set：文件描述符集合 – 本质是位图</p><p>位图操作函数：</p><ul><li><code>void FD_CLR(int fd, fd_set *set);</code> <br> 将 fd 从  set 集合钟清楚</li><li><code>int FD_ISSET(int fd, fd_set *set);</code> <br> 判断 fd 是否在集合中 <br> 如果 fd 在 set 集合中，返回 1，否则返回 0.</li><li><code>void FD_SET(int fd, fd_set* set);</code> <br> 将 fd 设置到 set 集合中</li><li><code>void FD_ZERO(fd_set *set);</code> <br> 初始化set集合</li></ul><p><code>int select(int nfds, fd_set * readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code></p><ul><li>函数介绍：委托内核监听该文件描述符对应的读、写或者错误事件的发生</li><li>参数说明：<ul><li>nfds：最大的文件描述符 + 1</li><li>readfds：读集合，是一个传入传出参数 <br> 传入：指的是告诉内核哪些文件描述符需要监控 <br> 传出：指的是内核告诉应用程序哪些文件描述符发生了变化。</li><li>writefds：写入文件描述符集合 (传入传出参数)</li><li>exceptfds：异常文件描述符集合 (传入传出参数)</li><li>timeout：<ul><li>NULL – 表示永久阻塞，直到有事件发生</li><li>0 – 表示不阻塞，立刻返回，不管是否有监听的事件发生</li><li>&gt;0 – 到指定事件或者有事件发生了就返回</li></ul></li></ul></li><li>返回值：<br> 成功返回发生变化的文件描述符的个数 <br> 失败返回 -1，并设置 errno</li></ul><p>调用 select 函数其实就是委托内核帮我们去检测哪些文件描述符有可读数据，可写，错误发生。</p><p>代码思路：<br>可以使用发生事件的总数进行控制，减少循环次数<br>调用 select 涉及到了用户空间和内核空间数值交互过程<br>事件一共包括两个部分，一类是新连接事件，一类是有数据可读事件</p><ul><li>select 优点：<ul><li>一个进程可以支持多个客户端</li><li>select 支持跨平台</li></ul></li><li>select 缺点：<ul><li>代码编写困难</li><li>会涉及到用户区和内核区的来回拷贝</li><li>当客户端多个连接，但少数活跃的情况，select 效率较低 <br> 利润也：作为极端的一种情况，3 - 1023 有发送数据，select 就显得效率低下</li><li>最大支持 1024 个客户端连接 <br> select 最大支持 1024 个客户端连接不是有文件描述符最多可以支持 1024 个文件描述符限制的，而是 <code>FD_SETSIZE=1024</code> 限制的</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>C/C++</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络编程 (二)</title>
    <link href="/2025/04/09/net-prog2/"/>
    <url>/2025/04/09/net-prog2/</url>
    
    <content type="html"><![CDATA[<h1 id="网络编程-二"><a href="#网络编程-二" class="headerlink" title="网络编程 (二)"></a>网络编程 (二)</h1><h2 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h2><p>TCP 是面向连接的安全的数据传输，在客户端与服务端建立连接的时候要经过三次握手的过程，在客户端与服务端断开连接的时候要经历四次挥手 的过程，下图是客户端与服务端的三次握手建立连接，数据传输和断开连接四次挥手 的全过程。</p><p><img src="/2025/03/21/file-io/2/image1.png" alt="TCP 时序"></p><p>上图中 ACK 表示确认序号，确认序号的值是对方发送得到序号值 + 数据长度，特别注意的是 SYN 和 FIN 本身也会占用一位<br>注：<br>SYN —&gt; synchronous<br>ACK —&gt; acknowledgement<br>FIN —&gt; finish</p><p>三次挥手和四次握手的过程都是在内核实现的。</p><p><img src="/2025/03/21/file-io/2/image3.png"></p><p>通信的时候不再需要 SYN 标识位了，只有在请求连接的时候需要 SYN 标识位</p><p>传输数据的时候随即序号 seq 就是最近一次对方发送给自己的 ACK 的随即序号值，而发给对方的 ACK 就是上次刚刚发给对方的 ACK 值<br><img src="/2025/03/21/file-io/2/image4.png"></p><p>图中发送的 ACK 确认包表示给对方发送数据的一个确认，表示你发送的数据我都收到了，同时告诉对方下次发送该序号开始的数据<br>由于每次发送数据都会受到对方发来的确认包，所以可以确认对方是否收到了，如果没有收到对方发来的确认包，则会进行重发。</p><p>mss：最大报文长度, 只是在建立连接的时候, 告诉对方我最大能够接收多少数据, 在数据通信的过程中就没有mss了<br>win：表示告诉对方我这边缓存大小最大是多少</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>主要作用：段东窗口主要是进行流量控制的<br>见下图：如果发送端发送的速度较快，接收端接收到数据后处理的速度较慢，而接收缓冲区的大小是固定的，就会导致接受缓冲区满而丢失数据。TCP 协议通过 “滑动窗口 (Sliding Window)” 机制解决这一问题<br><img src="/2025/03/21/file-io/2/image5.png"></p><p>在客户端给服务端发包的时候，不一定是非要等到服务端发送响应包，由于客户端知道服务端的窗口大小，所以可以持续多次发送，当发送数据达到对方窗口大小了就不再发送，需要等到对方进行处理，对方处理之后可继续发送。</p><p>MTU：最大传输单元 (Maximum Transmission Unit)<br>是指一种通信协议的某一层上面所能通过的最大数据包大小 (以字节为单位)。最大传输单元这个参数通常与通信接口有关 (网络接口卡、串口等)，这个值如果设置为太大会导致丢包重传的数据较大，图中的最大值是 1500，其实是一个经验值。<br><img src="/2025/03/21/file-io/2/image6.png"></p><h3 id="粘包的概念"><a href="#粘包的概念" class="headerlink" title="粘包的概念"></a>粘包的概念</h3><p>粘包：多次数据发送，首尾相连，接收端接受的时候不能正确区分第一次发送多少，第二次发送多少。</p><p>解决方案：</p><ul><li>方案1：包头 + 数据 <br> 如 4 位的数据长度 + 数据 —-&gt; 00101234567890 <br> 其中 0010 表示长度，1234567890 表示 10 个字节长度的数据。 <br> 另外，发送端和接收端可以协商更为复杂的报文机构，这个报文结构就相当于双方约定的一个协议。</li><li>方案2：添加结尾标记 <br> 如结尾最后一个字符为 \n $ 等</li><li>方案3：数据包定长 <br> 如发送方和接收方约定，每次只发送 128 个字节的内容，接收方接受定长 128 个字节就可以了。</li></ul><h2 id="高并发服务"><a href="#高并发服务" class="headerlink" title="高并发服务"></a>高并发服务</h2><p>由于 accept 和 read 函数都会阻塞，如当 read 的时候，不能调用 accept 接受新的连接，当 accept 阻塞等待的时候不能 read 读数据</p><p>如何支持多并发的服务：</p><ul><li>第一种方案：使用多进程，可以让父进程接受新连接，让子进程处理与客户端通信<ul><li>思路：让父进程 accpet 接收新连接，然后 fork 子进程，让子进程处理通信，子进程处理完成后退出，父进程使用 SIGCHLD 信号回收子进程。</li></ul></li><li>第二种方案：使用多线程，让主线程接收新连接，让子线程处理与客户端通信；使用多线程要将线程设置为分离属性，让子线程在退出之后自己回收资源。</li><li>第三种方案：可以将 accept 和 read 函数设置为非阻塞，调用 fcntl 函数可以将文件描述符设置为非阻塞，然后再 while 循环中忙轮询。</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>C/C++</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络编程 (一)</title>
    <link href="/2025/04/08/net-prog1/"/>
    <url>/2025/04/08/net-prog1/</url>
    
    <content type="html"><![CDATA[<h1 id="网络编程-一"><a href="#网络编程-一" class="headerlink" title="网络编程 (一)"></a>网络编程 (一)</h1><h2 id="网络基础概念"><a href="#网络基础概念" class="headerlink" title="网络基础概念"></a>网络基础概念</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>概念：协议事先约定好，打架共同遵守的一组规则，如交通信号灯。从应用程序的角度来看，协议可理解为数据传输喝数据解释的规则；可以简单的理解为各个主机之间通信所使用的语言。</p><p>假设，A、B 双方欲传输文件。规定：<br>第一次：传输文件名，接收方接受到文件名，应答 OK 给传输方；<br>第二次：发送文件的尺寸，接收方收到数据再次应答一个 OK；<br>第三次：传输文件内容。同样，接收方接收数据完成后应答 OK 表示文件内容接收成功。<br><img src="/2025/03/21/file-io/1/image1.png"></p><p>这种在 A 和 B 之间被遵守的协议称之为原始协议，后来经过不断增加完善改进，最终形成了一个稳定的完整的传输协议，被广泛用于各种文件传输，该协议逐渐就成了一个标准协议。</p><h3 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h3><p>OSI 是 Open System Interconnection 的缩写，意为开放式系统互联，国际标注化祖师 (ISO) 制定了 OSI 模型，该模型定义了不同计算机互联的标准，是设计和描述计算机网络通信的基本框架。</p><p>网络分层 OSI 7 层模型：</p><ul><li>物理层 — 双绞线，光纤 (传输介质)，将模拟信号转换为数字信号</li><li>数据链路层 — 数据校验，定义了网络传输的基本单位-帧</li><li>网络层 — 定义网络，两台机器之间传输的路径选择点到点的传输</li><li>传输层 — 传输数据 TCP，UDP，端到端的传输</li><li>会话层 — 通过传输层建立数据传输的通道</li><li>表示层 — 编解码，翻译工作</li><li>应用层 — 为客户提供各种应用服务，email 服务，ftp 服务，ssh 服务</li></ul><p><img src="/2025/03/21/file-io/1/image2.png"> <img src="/2025/03/21/file-io/1/image3.png"> <img src="/2025/03/21/file-io/1/image4.png"></p><h3 id="数据通信过程"><a href="#数据通信过程" class="headerlink" title="数据通信过程"></a>数据通信过程</h3><p>通信过程：其实就是发送端层层打包，接收方层层解包<br>注意：这些操作不是用户自己做的，而是底层帮我们做好的。<br><img src="/2025/03/21/file-io/1/image5.png"> <img src="/2025/03/21/file-io/1/image6.png"></p><h3 id="网络应用程序的设计模式"><a href="#网络应用程序的设计模式" class="headerlink" title="网络应用程序的设计模式"></a>网络应用程序的设计模式</h3><h4 id="CS-设计模式优缺点"><a href="#CS-设计模式优缺点" class="headerlink" title="CS 设计模式优缺点"></a>CS 设计模式优缺点</h4><ul><li>优点：<ul><li>客户端在本机上可以保证性能，可以将数据缓存到本地，提高数据的传输效率，提高用户体验效果</li><li>客户端和服务端程序都是由同一个团队开发，协议选择比较灵活</li></ul></li><li>缺点：<ul><li>服务器和客户端都需要开发，工作量相对较大，调试困难，开发周期长</li><li>从用户的角度看，需要将客户端安装到用户的主机上，对用户主机的安全构成威胁</li></ul></li></ul><h4 id="BS-设计模式优缺点"><a href="#BS-设计模式优缺点" class="headerlink" title="BS 设计模式优缺点"></a>BS 设计模式优缺点</h4><ul><li>优点：<ul><li>无需安装客户端，可以使用标准的浏览器作为客户端</li><li>只需要开发服务器，工作量相对较小</li><li>由于采用标准客户端，所以移植性好，不受平台限制</li><li>相对安全，不用安装软件</li></ul></li><li>缺点：<ul><li>由于没有客户端，数据缓冲不尽人意，数据传输有限制，用户体验较差</li><li>通信协议选择只能使用 HTTP 协议，协议选择不够灵活</li></ul></li></ul><h3 id="以太帧格式"><a href="#以太帧格式" class="headerlink" title="以太帧格式"></a>以太帧格式</h3><p>以太帧格式就是包装在网络接口层 (数据链路层) 的协议<br><img src="/2025/03/21/file-io/1/image7.png"></p><p>以 APR 为例介绍以太网帧格式<br><img src="/2025/03/21/file-io/1/image8.png"><br>目的端 mac 地址是通过发送端发送 ARP 广播，接收到该 ARP 数据的主机先判断是否是自己的 IP，若是则应答一个 ARP 应答报文，并将 mac 地址填入应答报文中；若目的 IP 不是自己的主机，则直接丢弃该 ARP 请求报文。</p><h4 id="IP-格式段"><a href="#IP-格式段" class="headerlink" title="IP 格式段"></a>IP 格式段</h4><p><img src="/2025/03/21/file-io/1/image9.png"></p><ul><li>协议版本：IPv4，IPv6</li><li>16 位总长度：最大 65536</li><li>8 位生存时间 ttl (网络连接到下一跳的次数)：为了防止网络阻塞</li><li>32 位源 IP 地址，共 4 个字节！我们熟悉的 IP 都是点分十进制，4 字节，每字节对应一个点分- 位，最大为 255，实际上就是整型数。</li><li>32 位目的 IP 地址</li><li>8 位协议：用来区分上层协议是 TCP，UDP，ICMP 还是 IGMP 协议。</li><li>16 位首部校验和：只校验 IP 首部，数据的校验是由更高层协议负责</li></ul><h4 id="UDP-数据报格式"><a href="#UDP-数据报格式" class="headerlink" title="UDP 数据报格式"></a>UDP 数据报格式</h4><p><img src="/2025/03/21/file-io/1/image10.png"></p><p>通过 IP 地址来确定网络环境中的唯一的一台主机；<br>主机上使用端口号来区分不同的应用程序。<br>IP + 端口唯一确定唯一一台主机上的一个应用程序</p><h4 id="TCP-数据流格式"><a href="#TCP-数据流格式" class="headerlink" title="TCP 数据流格式"></a>TCP 数据流格式</h4><p><img src="/2025/03/21/file-io/1/image11.png"></p><ul><li>序号：TCP 是安全可靠的，每个数据包都带有序号，当数据包丢失的时候，需要重传，要使用序号进行重传，控制数据有序，丢包重拾。</li><li>确认序号：使用确认序号可以知道对方是否已经收到了，通过确认序号可以知道哪个序号的数据需要重传</li><li>16 位窗口大小 – 滑动窗口 (主要进行流量控制)</li></ul><h2 id="SOCKET-编程"><a href="#SOCKET-编程" class="headerlink" title="SOCKET 编程"></a>SOCKET 编程</h2><p>传统的进程间通信借助内核提供的 IPC 机制进行，但是只能限于本机通信，若要跨机通信，就必须使用网络通信。(本质上借助内核 - 内核提供了 socket 伪文件机制实现通信 — 实际上是使用文件描述符)，这就需要使用内核给用户提供的 socket API 函数库</p><p>既然提到 socket 伪文件，所以可以使用文件描述符相关的函数 read、write<br>可以对比 pipe 管道讲述 socket 文件描述符的区别</p><p>如下图，一个文件描述符操作两个缓冲区，这点跟管道是不同的，管道是两个文件描述符操作一个内核缓冲区。</p><p><img src="/2025/03/21/file-io/1/image14.png"></p><h3 id="socket-编程预备知识"><a href="#socket-编程预备知识" class="headerlink" title="socket 编程预备知识"></a>socket 编程预备知识</h3><ul><li>网络字节序：<ul><li>大端：低位地址存放高位数据，高位地址存放低位数据</li><li>小端：低位地址存放低位数据，高位地址存放高位数据</li></ul></li><li>大端和小端的使用场合<ul><li>大端和小端只是对数据类型长度是两个及以上的，如 int、short，对于单字节没限制，在网络中经常考虑大端和小端的是 IP 和端口。</li></ul></li></ul><p>大小端验证程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">isLittleEndian</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> num = <span class="hljs-number">0x01020304</span>;<br>  <span class="hljs-type">char</span>* p = (<span class="hljs-type">char</span>*)&amp;num;<br>  <span class="hljs-keyword">if</span> (*p == <span class="hljs-number">0x04</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (isLittleEndian()) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Little Endian\n&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Big Endian\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>网络传输用的是大端法，如果机器用的是小端法，则需要进行大小端转换<br>下面 4 个函数就是进行大小端转换的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">htonl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> hostlong)</span>;<br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">htons</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> hostshort)</span>;<br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ntohl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> netlong)</span>;<br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">ntohs</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> netshort)</span>;<br></code></pre></td></tr></table></figure><p>函数名的 h 表示主机 host，n 表示网络 network，s 表示 short，l 表示 long<br>上述的几个函数如果本来不需要转换函数就不会做转换</p><h4 id="IP-地址转换函数"><a href="#IP-地址转换函数" class="headerlink" title="IP 地址转换函数"></a>IP 地址转换函数</h4><p>p -&gt; 表示点分十进制的字符串形式<br>to -&gt; 到<br>n -&gt; 表示 network 网路</p><ul><li><code>int inet_pton(int af, const char *src, void *dst);</code><ul><li>函数说明：将字符串形式的点分十进制 IP 转换为大端模式的网络 IP (整形 4 字节数)</li><li>参数说明：<ul><li>af：AF_INET</li><li>src：字符串形式的点分十进制 IP </li><li>dst：存放转换后的变量的地址</li></ul></li></ul></li></ul><p>手工也可以计算：<br>如 192.168.232.145, 先将4个正数分别转换为16进制数,<br>192 –&gt; 0xC0  168 –&gt; 0xA8   232 –&gt; 0xE8   145 –&gt; 0x91<br>最后按照大端字节序存放: 0x91E8A8C0，这个就是4字节的整形值</p><ul><li><code>const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</code><ul><li>函数说明：网络IP转换为字符串形式的点分十进制的IP</li><li>参数说明：<ul><li>af：AF_INET</li><li>src：网络的整形的 IP 地址</li><li>dst：转换后的 IP 地址,一般为字符串数组</li><li>size：dst 的长度</li><li>返回值：<ul><li>成功 – 返回指向 dst 的指针</li><li>失败 – 返回 NULL，并设置 errno</li></ul></li></ul></li></ul></li></ul><p>例如：<br>IP 地址为 010aa8c0，转换为点分十进制的格式：<br>01 –&gt; 1    0a –&gt; 10   a8 –&gt; 168   c0 –&gt; 192<br>由于从网络中的 IP 地址是高端模式, 所以转换为点分十进制后应该为：192.168.10.1</p><h4 id="结构体-struct-sockaddr"><a href="#结构体-struct-sockaddr" class="headerlink" title="结构体 struct sockaddr"></a>结构体 struct sockaddr</h4><p><img src="/2025/03/21/file-io/1/image15.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// sockaddr 结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> &#123;</span><br>    <span class="hljs-type">sa_family_t</span> sa_family;<br>    <span class="hljs-type">char</span>     sa_data[<span class="hljs-number">14</span>];<br>&#125;;<br><br><span class="hljs-comment">// sockaddr_in 结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> &#123;</span><br>    <span class="hljs-type">sa_family_t</span>    sin_family; <span class="hljs-comment">/* address family: AF_INET */</span><br>    <span class="hljs-type">in_port_t</span>      sin_port;   <span class="hljs-comment">/* port in network byte order */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span>   <span class="hljs-comment">/* internet address */</span><br>&#125;;<br><br><span class="hljs-comment">/* Internet address. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span>  s_addr;     <span class="hljs-comment">/* address in network byte order */</span><br>&#125;;<span class="hljs-comment">//网络字节序IP--大端模式</span><br></code></pre></td></tr></table></figure><p>可通过 <code>man 7 ip</code> 可以查看相关说明</p><h3 id="socket-变成主要的-API-函数介绍"><a href="#socket-变成主要的-API-函数介绍" class="headerlink" title="socket 变成主要的 API 函数介绍"></a>socket 变成主要的 API 函数介绍</h3><ul><li>创建socket<ul><li>函数原型：<code>int socket(int domain, int type, int protocol);</code></li><li>参数说明：<ul><li>domain：协议版本<ul><li>AF_INET – IPv4</li><li>AF_INET6 – IPv6</li><li>AF_UNIX AF_LOCAL 本地套接字使用</li></ul></li><li>type：协议类型<ul><li>SOCK_STREAM 流式，默认使用的协议是 TCP 协议</li><li>SOCK_DGRAM 报式，默认使用的协议是 UDP 协议</li></ul></li><li>protocol：一般填 0，表示使用对应类型的默认协议</li></ul></li><li>返回值：<ul><li>成功：返回一个大于 0 的文件描述符</li><li>失败：返回 -1，并设置 errno</li></ul></li></ul></li></ul><p>当调用 socket 函数以后，返回一个文件描述符，内核会提供与该文件描述符对用的读和写缓冲区，同时还有两个队列，分别是请求连接队列和已连接队列</p><p><img src="/2025/03/21/file-io/1/image14.png"></p><ul><li><p>绑定套接字</p><ul><li>函数原型：<code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></li><li>参数说明：<ul><li>socket：调用 socket 函数返回的文件描述符</li><li>addr：本地服务器的 IP 地址和 PORT</li><li>addrlen：addr 变量的占用内存大小</li></ul></li><li>返回值：<ul><li>成功返回 0，失败返回 -1，并设置 errno</li></ul></li></ul></li><li><p>监听套接字</p><ul><li>函数原型：<code>int listen(int sockfd, int backlog);</code></li><li>参数说明：<ul><li>socket：调用 socket 函数返回的文件描述符</li><li>backlog：同时请求连接的最大个数 (还未建立连接)</li></ul></li><li>返回值：<ul><li>成功返回 0，失败返回 -1，并设置 errno</li></ul></li></ul></li><li><p>接收连接</p><ul><li>函数原型：<code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);    </code></li><li>函数参数：<ul><li>sockfd：调用 socket 函数返回的文件描述符</li><li>addr：传出参数，保存客户端的地址信息</li><li>addrlen：传入参数，addr 变量所占内存空间大小</li></ul></li><li>返回值：<ul><li>成功：返回一个新的文件描述符，用于和客户端通信</li><li>失败：返回 -1，并设置 errno</li></ul></li></ul></li></ul><p>accept 函数是一个阻塞函数，若没有新的连接请求，则一直阻塞。<br>从已连接队列中获取一个新的连接，并获得一个新的文件描述符，该文件描述符用于和客户端通信。(内核会负责将请求队列中的连接拿到已连接队列中)</p><ul><li>连接服务器<ul><li>函数原型：<code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></li><li>函数参数：<ul><li>sockfd：调用 socket 函数返回的文件描述符</li><li>addr：服务器的地址信息</li><li>addrlen：addr 变量的内存大小</li></ul></li><li>返回值：成功返回 0，失败返回 -1，并设置 errno</li></ul></li></ul><p>接下来就是读取和发送数据了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recv</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">send</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-comment">// 对应 recv 和 send 这两个函数 flags 直接填 0 就可以了。</span><br></code></pre></td></tr></table></figure><p>使用 socket 的 API 函数编写服务端和客户端程序的步骤图示：<br><img src="/2025/03/21/file-io/1/image16.png"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>C/C++</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程同步</title>
    <link href="/2025/04/07/thread-sync/"/>
    <url>/2025/04/07/thread-sync/</url>
    
    <content type="html"><![CDATA[<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><h3 id="互斥锁使用步骤"><a href="#互斥锁使用步骤" class="headerlink" title="互斥锁使用步骤"></a>互斥锁使用步骤</h3><ol><li>创建一把互斥锁 <br> <code>pthread_mutex_t mutex;</code></li><li>初始化互斥锁 <br> <code>pthread_mutex_init(&amp;mutex);</code> — 相当于mutex&#x3D;1</li><li>在代码中寻找共享资源 (也称为临界区) <br></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">pthread_mutex_lock(&amp;mutex);  <span class="hljs-comment">// mutex = 0</span><br>[临界区代码]<br>pthread_mutex_unlock(&amp;mutex); <span class="hljs-comment">// mutex = 1</span><br></code></pre></td></tr></table></figure><ol start="4"><li>释放互斥锁资源 <br> <code>pthread_mutex_destroy(&amp;mutex);</code></li></ol><p>注意：必须在所有操作共享资源的线程上都加上锁斗则不能起到同步的效果</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁并不是 Linux 提供给用户的一种使用方法，而是由于用户是用互斥锁不当引起的一种现象。</p><h4 id="常见死锁种类"><a href="#常见死锁种类" class="headerlink" title="常见死锁种类"></a>常见死锁种类</h4><ol><li>自己锁自己，如下图代码片段：</li></ol><p><img src="/2025/03/21/file-io/ync/image3.png"></p><ol start="2"><li>线程 A 拥有 A 锁，请求获得 B 锁；线程 B 拥有 B 锁，请求获得 A 锁，这样造成线程 A 和线程 B 都不释放自己的锁，而且还想得到对方的锁，从而产生死锁，如下图所示：</li></ol><p><img src="/2025/03/21/file-io/ync/image4.png"></p><h4 id="如何解决死锁"><a href="#如何解决死锁" class="headerlink" title="如何解决死锁"></a>如何解决死锁</h4><ul><li>让线程按照一定的顺序去访问共享资源</li><li>在访问其他锁的时候，需要先将自己的锁解开</li><li>调用 pthread_mutex_trylock，如果加锁不成功会立刻返回</li></ul><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><h3 id="什么是读写锁"><a href="#什么是读写锁" class="headerlink" title="什么是读写锁"></a>什么是读写锁</h3><p>读写锁也叫共享 - 独占锁。当读写锁以读模式锁住时，它是以共享模式锁住得到；当它以写模式锁住时，它是以独占模式锁住的。<strong>写独占、读共享。</strong></p><h3 id="读写锁使用场合"><a href="#读写锁使用场合" class="headerlink" title="读写锁使用场合"></a>读写锁使用场合</h3><p>读写锁非常适合于对数据结构读的次数远大于写的情况。</p><h3 id="读写锁特性"><a href="#读写锁特性" class="headerlink" title="读写锁特性"></a>读写锁特性</h3><ul><li>读写锁是 “写模式加锁” 时，解锁前，所有对该锁加锁的线程都会被阻塞。</li><li>读写锁是 “读模式加锁” 时，如果线程以读模式对其加锁会成功；如果以写模式加锁会阻塞。</li><li>读写锁时 “读模式加锁” 时，既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式请求。优先满足写模式。<strong>读锁、写锁并行阻塞，写锁优先级高。</strong></li></ul><p>总结：读并行，写独占，当读写同时等待锁的时候写的优先级高。</p><h3 id="读写锁主要操作函数"><a href="#读写锁主要操作函数" class="headerlink" title="读写锁主要操作函数"></a>读写锁主要操作函数</h3><ul><li>定义一把读写锁：<br> <code>pthread_rwlock_t rwlock;</code></li><li>初始化读写锁：<ul><li><code>int pthread_wrlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code></li><li>函数参数：<ul><li>rwlock - 读写锁</li><li>attr - 读写锁属性，传 NULL 为默认属性</li></ul></li></ul></li><li>销毁读写锁：<br> <code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code></li><li>加读锁：<br> <code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code></li><li>尝试加读锁：<br> <code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</code></li><li>加写锁：<br> <code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code></li><li>尝试加写锁：<br> <code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code></li><li>解锁：<br> <code>int pthread_rwlock_unlock(&amp;pthread_rwlock_t *rwlock);</code></li></ul><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>条件变量本身不是锁！但它可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会和的场所。</p><ul><li>使用互斥量保护共享资源</li><li>使用条件变量可以使线程阻塞，等待某个条件的发生，当条件满足的时候解除阻塞。</li></ul><h3 id="条件变量的两个动作"><a href="#条件变量的两个动作" class="headerlink" title="条件变量的两个动作"></a>条件变量的两个动作</h3><ul><li>条件不满足，阻塞线程</li><li>条件满足，通知阻塞的线程解除阻塞，开始工作</li></ul><h3 id="条件变量相关函数"><a href="#条件变量相关函数" class="headerlink" title="条件变量相关函数"></a>条件变量相关函数</h3><ul><li>定义一个条件变量：<br> <code>pthread_cond_t  cond;</code></li><li>条件变量初始化：<ul><li>函数原型：<code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code></li><li>函数参数：<ul><li>cond：条件变量</li><li>attr：条件变量属性，通常传 NULL</li></ul></li><li>函数返回值：成功返回 0，失败返回错误号</li></ul></li><li>销毁条件变量：<ul><li>函数原型：<code>int pthread_cond_destroy(pthread_cond_t *cond);</code></li><li>函数参数：条件变量</li><li>函数返回值：成功返回 0，失败返回错误号</li></ul></li><li>条件变量等待函数：<ul><li>函数描述：条件不满足，引起线程阻塞并解锁 <br> 条件满足，解除线程阻塞，并加锁</li><li>函数原型：<code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code></li><li>函数参数：<ul><li>cond：条件变量</li><li>mutex：互斥锁变量</li></ul></li><li>函数返回值：成功返回 0，失败返回错误号</li></ul></li><li>条件变量唤醒函数：<ul><li>函数描述：唤醒至少一个阻塞再该条件变量上的线程</li><li>函数原型：<code>int pthread_cond_signal(pthread_cond_t *cond);</code></li><li>函数参数：条件变量</li><li>函数返回值：成功返回 0，失败返回错误号</li></ul></li></ul><h3 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h3><p><img src="/2025/03/21/file-io/ync/image5.png"></p><p>上述代码中，生产者线程调用 pthread_cond_signal 函数会使消费者线程在 pthread_cond_wait 处解除阻塞。</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><h3 id="信号量介绍"><a href="#信号量介绍" class="headerlink" title="信号量介绍"></a>信号量介绍</h3><p>信号量相当于多把锁，可以理解为是加强版的互斥锁。</p><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><ul><li>定义信号量：<code>sem_t sem;</code></li><li>初始化信号量：<ul><li>函数原型：<code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code></li><li>函数参数：<ul><li>sem：信号量变量</li><li>pshared：0 表示线程同步，1 表示进程同步</li><li>value：最多几个线程操作共享数据</li></ul></li><li>函数返回值：成功返回 0，失败返回 -1，并设置 errno</li></ul></li><li>信号量加锁：<ul><li>函数原型：<code>int sem_wait(sem_t *sem);</code></li><li>函数描述：调用该函数一次，相当于 sem–，当 sem 为 0 的时候，引起阻塞</li><li>函数参数：信号量变量</li><li>函数返回值：成功返回 0，失败返回 -1，并设置 errno</li></ul></li><li>信号量解锁：<ul><li>函数原型：<code>int sem_post(sem_t *sem);</code></li><li>函数描述：调用一次，相当于 sem++</li><li>函数参数：信号量变量</li><li>函数返回值：成功返回 0，失败返回 -1，并设置 errno</li></ul></li><li>信号量尝试加锁：<ul><li>函数原型：<code>int sem_trywait(sem_t *sem);</code></li><li>函数描述：尝试加锁, 若失败直接返回, 不阻塞</li><li>函数参数：信号量变量</li><li>函数返回值：成功返回 0，失败返回 -1，并设置 errno</li></ul></li><li>销毁信号量：<ul><li>函数原型：<code>int sem_destroy(sem_t *sem);</code></li><li>函数参数：信号量变量</li><li>函数返回值：成功返回 0，失败返回 -1，并设置 errno</li></ul></li></ul><h3 id="代码片段-1"><a href="#代码片段-1" class="headerlink" title="代码片段"></a>代码片段</h3><p><img src="/2025/03/21/file-io/ync/image6.png"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>守护进程和线程</title>
    <link href="/2025/04/06/daemons-threads/"/>
    <url>/2025/04/06/daemons-threads/</url>
    
    <content type="html"><![CDATA[<h1 id="守护进程和线程"><a href="#守护进程和线程" class="headerlink" title="守护进程和线程"></a>守护进程和线程</h1><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><h3 id="守护线程介绍"><a href="#守护线程介绍" class="headerlink" title="守护线程介绍"></a>守护线程介绍</h3><p>Daemon (精灵) 进程，是 Linux 中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字，如 vsftpd。<br> Linux 后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行着，他们都是守护进程。如：预读入缓存输出机制；ftp 服务器；nfs 服务器等。</p><ul><li>总结守护进程的特点：<ul><li>Linux 后台服务进程</li><li>独立于控制终端</li><li>周期性的执行某种任务</li><li>不受用户登录和注销的影响</li><li>一般采用以 d 结尾的名字</li></ul></li></ul><h3 id="进程组和会话"><a href="#进程组和会话" class="headerlink" title="进程组和会话"></a>进程组和会话</h3><h4 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h4><ul><li>进程组是一个或者多个进程的集合，每个进程都属于一个进程组，引入进程组是为了简化对进程的管理。当父进程创建子进程的时候，默认子进程与父进程属于同一个进程组。<br> 进程组 ID &#x3D;&#x3D; 第一个进程 ID (组长进程)。如父进程创建了多个子进程，父进程和多个子进程同属于一个组，而由于父进程是进程组里的第一个进程，所以父进程就是这个组的组长。</li><li>可以使用 <code>kill -SIGKILL -进程组 ID (负的)</code>来将整个进程组内的程序全部杀死</li><li>只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关</li><li>进程组生存期：从进程组创建到最后一个进程离开</li></ul><h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><ul><li>一个会话是一个或多个进程组的集合。</li><li>创建会话的进程不能是进程组组长</li><li>创建会话的进程称为一个进程组的组长进程，同时也成为会话的会长。</li><li>需要有 root 权限 (Ubuntu 不需要)</li><li>新创建的会话丢弃原有的控制终端</li><li>建立新会话时，先调用 fork，父进程终止，子进程调用 setsid 函数</li></ul><p>可以使用 <code>ps ajx</code> 来查看进程组 ID 和会话 ID。</p><p><img src="/2025/03/21/file-io/threads/image1.png" alt="进程组和会话的关系图"></p><h3 id="创建守护进程的模型"><a href="#创建守护进程的模型" class="headerlink" title="创建守护进程的模型"></a>创建守护进程的模型</h3><ol><li>fork 子进程，父进程退出<ul><li>子进程继承了父进程的进程组 ID，但具有一个新的进程 ID，这样就保证了子进程不是一个进程组的组长 ID，这对于下面要做的 setsid 函数的调用时必要的前提条件</li></ul></li><li>子进程调用 setsid 函数创建新会话<ul><li>该进程会称为新会话的首进程，是会话的会长</li><li>称为一个新进程组的组长进程，是进程组组长</li><li>不受控制终端的影响</li></ul></li><li>改变当前工作目录 chdir<ul><li>如：a.out 在 U 盘上，启动这个程序，这个程序的当前的工作目录就是这个 U 盘，如果 U 盘拔掉后进程的当前工作目录将消失，a.out 将不能正常工作。</li></ul></li><li>重设文件掩码 <code>mode &amp; ~umask</code><ul><li>子进程会继承父进程的掩码</li><li>增加子进程程序操作的灵活性</li><li><code>umask(0000);</code></li></ul></li><li>关闭文件描述符<ul><li>守护进程不受控制终端的影响，所以可以关闭，以释放资源</li><li><code>close(STDIN_FILENO);</code> <br> <code>close(STDOUT_FILENO);</code> <br> <code>close(STDERR_FILENO);</code></li></ul></li><li>执行核心工作<ul><li>守护进程的核心代码逻辑</li></ul></li></ol><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><ul><li>轻量级的进程 (LWP：light weight process)，在 Linux 环境下线程的本质任然是进程。</li><li>进程：拥有独立的地址空间，拥有 PCB，相当于独居。</li><li>线程：有 PCB，但没有独立的地址空间，多个线程共享进程空间，相当于合租。</li></ul><p><img src="/2025/03/21/file-io/threads/image2.png"></p><ul><li>在 Linux 操作系统下：<ul><li>线程：最小的执行单位</li><li>进程：最小分配资源单位，可看成是只有一个线程的进程。</li></ul></li><li>线程的特点：<ul><li>类 Unix 系统中，早期是没有 “线程” 概念的，80 年代猜将引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</li><li>线程是轻量级进程，也有 PCB，创建线程使用的底层函数和进程一样，都是 clone。</li><li>从内核里看进程和线程是一样的，都有各自不同的 PCB</li><li>进程可以蜕变成线程</li><li>在 Linux 下，线程是最小执行单位；进程是最小的分配资源单位</li></ul></li></ul><p><img src="/2025/03/21/file-io/threads/image3.png"></p><ul><li>查看指定线程的 LWP 号：<code>ps -Lf pid</code> <br> 实际上，无论是创建进程的 fork，还是创建线程的 pthread_create，底层实现都是调用同一个内核函数 clone</li><li>如果复制对方的地址空间，那么就产出一个 “进程”</li><li>如果共享对方的地址空间，那么就产出一个 “线程”</li></ul><p>所以，Linux 内核是不区分进程和线程的，只在用户层面上进行区分。线程的所有操作函数 pthread_* 是库函数，而非系统调用。</p><h3 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="线程共享资源"></a>线程共享资源</h3><ul><li>文件描述符</li><li>每种信号的处理方式</li><li>当前工作目录</li><li>用户 ID 和组 ID</li><li>内存地址空间 (.text&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F;共享库)</li></ul><h3 id="线程非共享资源"><a href="#线程非共享资源" class="headerlink" title="线程非共享资源"></a>线程非共享资源</h3><ul><li>线程 id</li><li>处理器现场和栈指针 (内核栈)</li><li>独立的栈空间 (用户空间栈)</li><li>errno 变量</li><li>信号屏蔽字</li><li>调度优先级</li></ul><h3 id="线程优、缺点"><a href="#线程优、缺点" class="headerlink" title="线程优、缺点"></a>线程优、缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>提高程序并发性</li><li>开销小</li><li>数据通信、共享数据方便</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>库函数，不稳定</li><li>gdb 调试、编写困难</li><li>对信号支持不好</li></ul><p>优点相对突出，缺点均不是硬伤。Linux 下由于实现方法导致进程、线程差别不是很大。</p><h3 id="pthread-create-函数"><a href="#pthread-create-函数" class="headerlink" title="pthread_create 函数"></a>pthread_create 函数</h3><ul><li>函数作用：<ul><li>创建一个新线程</li></ul></li><li>函数原型：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *thread, <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr,</span><br><span class="hljs-params">                      <span class="hljs-type">void</span> *(*start_routine) (<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)</span>;<br></code></pre></td></tr></table></figure></li><li>返回值：<ul><li>成功，返回 0</li><li>失败，返回错误号</li></ul></li><li>函数参数<ul><li>pthread_t：传出参数，保存系统为我们分配号的线程 ID<ul><li>当前 Linux 中可理解为：<code>typedef unsigned long int pthread_t</code></li></ul></li><li>attr：通常传 NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数</li><li>start_routine：函数指针，指向线程主函数 (线程体)，该函数运行结束，则线程结束</li><li>arg：线程主函数执行期间所使用的参数</li></ul></li><li>注意点：<ul><li>由于 pthread_create 的错误码不保存在 errno 中，因此不能直接用 perror() 打印错误信息，可以先用 strerror() 把错误码转换成错误信息再打印</li><li>如果任一一个线程调用了 exit 或 _exit，则整个进程的所有线程都终止。</li></ul></li></ul><h3 id="pthread-exit-函数"><a href="#pthread-exit-函数" class="headerlink" title="pthread_exit 函数"></a>pthread_exit 函数</h3><p>在线程中禁止调用 exit 函数，否则会导致整个进程退出，取而代之的是调用 pthread_exit 函数，这个函数是使一个线程退出，如果主线程调用 pthread_exit 函数也不会使整个进程退出，不影响其他线程的执行。</p><ul><li>函数描述：将单个线程退出</li><li>函数原型：<code>void pthread_exit(void *retval);</code></li><li>函数参数：retval 表示线程退出状态，通常传 NULL <br> 另注意，pthread_exit 或者 return 返回的指针所指向的内存单元必须是全局的或者是用 malloc 分配的，不能在线程函数的栈上分配，因为当其他线程得到这个返回指针时线程函数已经退出了，栈空间就会被回收。</li></ul><h3 id="pthread-join-函数"><a href="#pthread-join-函数" class="headerlink" title="pthread_join 函数"></a>pthread_join 函数</h3><ul><li>函数描述：阻塞等待线程退出，获取线程退出状态。其作用，对应进程中的 waitpid() 函数。</li><li>函数原型：<code>int pthread_join(pthread_t thread, void **retval);</code></li><li>函数返回值：<ul><li>成功：0</li><li>失败：错误号</li></ul></li><li>函数参数：<ul><li>thread：线程 ID</li><li>retval：存储线程结束状态，整个指针和 pthread_exit 的参数是同一块内存地址</li></ul></li></ul><h3 id="pthread-detach-函数"><a href="#pthread-detach-函数" class="headerlink" title="pthread_detach 函数"></a>pthread_detach 函数</h3><p>线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。 <br> 进程若有该机制，将不会产生僵尸进程，僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。 <br> 也可是用 pthread_create 函数参 2 (线程属性) 来设置线程分离。pthread_detach 函数是在创建线程之后调用的</p><ul><li>函数描述：实现线程分离</li><li>函数原型：<code>int pthread_detach(pthread_t thread);</code></li><li>函数返回值：<ul><li>成功：0</li><li>失败：错误号</li></ul></li></ul><p>一般情况下，程序终止后，其终止状态一直保留到其他线程调用 pthread_join 获取它的状态为止。但是线程也可以被设置为 detach 状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。不能对一个已经处于 detach 状态的线程调用 pthread_join，这样的调用将返回 EINVAL 错误。也就是说，如果已经对一个线程调用了 detach 就不能再调用 join。</p><h3 id="pthread-cancel-函数"><a href="#pthread-cancel-函数" class="headerlink" title="pthread_cancel 函数"></a>pthread_cancel 函数</h3><ul><li>函数描述：杀死 (取消) 线程。其作用，对应进程中 kill() 函数</li><li>函数原型：<code>int pthread_cancel(pthread_t thread);</code></li><li>函数返回值：<ul><li>成功：0</li><li>失败：错误号</li></ul></li><li>注意：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点 (检查点)。 <br> 类似于玩游戏存档，必须到达指定的场所才能存储进度。杀死线程也不是立刻就能完成的，必须到达取消点。<br> 取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用：create，open，pause，close，read，write…… 执行命令 <code>man 7 pthreads</code> 可以查看具备这些取消点的系统调用列表。可以粗略认为一个系统调用 (进入内核) 即为一个取消点。还以通过调用 pthread_testcancel 函数设置一个取消点。</li></ul><h3 id="pthread-equal-函数"><a href="#pthread-equal-函数" class="headerlink" title="pthread_equal 函数"></a>pthread_equal 函数</h3><ul><li>函数描述：比较两个线程 ID 是否相等</li><li>函数原型：<code>int pthread_equal(pthread_t t1, pthread_t t2);</code></li><li>注意：这个函数是为了以后能够扩展使用的，有可能 Linux 在未来线程 ID pthread_t 类型被修改为结构体实现。</li></ul><h3 id="进程函数和线程函数比较"><a href="#进程函数和线程函数比较" class="headerlink" title="进程函数和线程函数比较"></a>进程函数和线程函数比较</h3><table><thead><tr><th align="center">进程</th><th align="center">线程</th></tr></thead><tbody><tr><td align="center">fork</td><td align="center">pthread_create</td></tr><tr><td align="center">exit</td><td align="center">phread_exit</td></tr><tr><td align="center">wait&#x2F;waitpid</td><td align="center">pthread_join</td></tr><tr><td align="center">kill</td><td align="center">pthread_cancel</td></tr><tr><td align="center">getpid</td><td align="center">pthread_self</td></tr></tbody></table><h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>Linux 下现成的属性是可以根据实际项目需要，进行设置，之前讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题，如果对程序的性能提出更高的要求，则需要设置线程属性。</p><ul><li>线程的分离状态决定一个线程以什么样的方式来终止自己，有两种状态：<ul><li>非分离状态：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当 pthread_join 函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</li><li>分离状态：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。</li></ul></li><li>设置线程属性分为以下步骤：<ol><li>定义线程属性类型的变量：<br> <code>pthread_attr_t attr;</code></li><li>对线程属性变量进行初始化：<br> <code>int pthread_attr_init(pthread_attr_t *attr);</code></li><li>设置线程为分离属性：<br> <code>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</code><ul><li>attr：线程属性</li><li>detachstate：<ul><li><code>PTHREAD_CREATE_DETACHED (分离)</code></li><li><code>PTHREAD_CREATE_JOINABLE (非分离)</code></li></ul></li></ul></li></ol><ul><li>注意：这一步完成之后调用 pthread_create 函数创建线程，则创建出来的线程就是分离线程；其实上述三步 pthread_create 的第二个参数做准备工作</li></ul><ol start="4"><li>释放线程属性资源：<br> <code>int pthread_attr_destroy(pthread_attr_t *attr);</code></li></ol></li></ul><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="线程同步的概念"><a href="#线程同步的概念" class="headerlink" title="线程同步的概念"></a>线程同步的概念</h3><p>线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其他线程为保证数据一致性，不能调用该功能。</p><h3 id="线程同步的例子"><a href="#线程同步的例子" class="headerlink" title="线程同步的例子"></a>线程同步的例子</h3><p>创建两个线程，让两个线程共享一个全局变量 int number，然后让每一个线程数 5000 次数，看最后打印出这个 number 值是多少</p><p><img src="/2025/03/21/file-io/threads/image7.png" alt="线程 A 代码片段"> <img src="/2025/03/21/file-io/threads/image8.png" alt="线程 B 代码片段"></p><ul><li>代码片段说明<ul><li>代码中是用调用 usleep 是为了让两个子线程能够轮流使用 CPU，避免一个子线程在一个时间片内完成 5000 次数数。</li><li>对 number 执行 ++ 操作，使用了中间变量 cur 是为了尽可能地模拟 CPU 时间片用完而让出 CPU 地情况</li></ul></li><li>测试机过<ul><li>经过多次测试最后地结果显示，有可能会出现 number 值少于 5000*2&#x3D;10000 的情况</li></ul></li><li>分析原因<ul><li>假如子线程 A 执行完了 cur++ 操作，还没有将 cur 的值赋给 number 失去了 CPU 的执行权，子线程 B 得到了 CPU 执行权，而子线程 B 最后执行完了 number &#x3D; cur，而后失去了 CPU 的执行权；此时子线程 A 又重新得到了 CPU 的执行权，并执行了 number &#x3D; cur 操作，这样会把线程 B 刚刚写回 number 的值被覆盖了，造成了 number 不符合预期的值</li></ul></li></ul><p><img src="/2025/03/21/file-io/threads/image9.png"></p><ul><li>数据混乱的原因<ul><li>资源共享 (独享资源则不会)</li><li>调度的随机 (线程操作共享资源的先后顺序不确定)</li><li>线程间缺乏必要的同步机制</li></ul></li></ul><p>以上三点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。</p><ul><li>如何解决问题<ul><li>原子操作的概念：<br> 原子操作指的是该操作要么不做，要么就完成。</li><li>是用互斥锁解决同步问题：<br> 使用互斥锁其实是模拟原子操作。</li></ul></li></ul><p>Linux 中提供一把互斥锁 mutex (也称之为互斥量)。每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。</p><p>资源还是共享的，线程间也还是竞争的，但通过 “锁” 将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。</p><p><img src="/2025/03/21/file-io/threads/image10.png" alt="互斥锁示意图"></p><p>线程 1 访问共享资源的时候要先判断锁是否锁着，如果锁着就阻塞等待；若锁是解开的就将这把锁加锁，此时可以访问共享资源，访问完成后释放锁，这样其他线程就有机会获得锁。</p><p>应该注意：图中同一时刻，只能有一个线程持有该锁，只要该线程未完成操作就不释放锁。</p><p>是用互斥锁之后，两个线程由并行操作编程了串行操作，效率降低了，但是数据不一致的问题得到了解决。</p><h3 id="互斥锁主要相关函数"><a href="#互斥锁主要相关函数" class="headerlink" title="互斥锁主要相关函数"></a>互斥锁主要相关函数</h3><h4 id="pthread-mutex-t-类型"><a href="#pthread-mutex-t-类型" class="headerlink" title="pthread_mutex_t 类型"></a>pthread_mutex_t 类型</h4><ul><li>其本质是一个结构体，为简化理解，应用时可忽略其实现细节，简单当成正数看待。</li><li><code>pthread_mutex_t mutex;</code>变量 mutex 只有两种取值 1、0</li></ul><h4 id="pthread-mutex-init-函数"><a href="#pthread-mutex-init-函数" class="headerlink" title="pthread_mutex_init 函数"></a>pthread_mutex_init 函数</h4><ul><li>函数描述：初始化一个互斥锁 (互斥量) —&gt; 初值可看作 1</li><li>函数原型：<code>int pthread_mutex_init(pthread_mutex_t *restrict mutex const pthread_mutexattr_t *restrict attr);</code></li><li>函数参数<ul><li>mutex：传出参数，调用时应传 &amp;mutex</li><li>attr：互斥锁属性。是一个传入参数，通常传 NULL，选用默认属性 (线程间共享) <br> restrict 关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改 <br> 互斥锁 mutex 的两种初始化方式：<ul><li>静态初始化：如果互斥锁 mutex 是静态分配的 (定义在全局，或加了 static 关键字修饰)，可以直接是用宏进行初始化。<br> <code>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</code></li><li>动态初始化：局部变量应采用动态初始化。<br> <code>pthread_mutex_init(&amp;mutex, NULL);</code></li></ul></li></ul></li></ul><h4 id="pthread-mutex-destroy-函数"><a href="#pthread-mutex-destroy-函数" class="headerlink" title="pthread_mutex_destroy 函数"></a>pthread_mutex_destroy 函数</h4><ul><li>函数描述：销毁一个互斥锁</li><li>函数原型：<code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></li><li>函数参数：mutex – 互斥锁变量</li></ul><h4 id="pthread-mutex-lock-函数"><a href="#pthread-mutex-lock-函数" class="headerlink" title="pthread_mutex_lock 函数"></a>pthread_mutex_lock 函数</h4><ul><li>函数描述：对互斥锁加锁，可理解为将 mutex–</li><li>函数原型：<code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code></li><li>函数参数：mutex – 互斥锁变量</li></ul><h4 id="pthread-mutex-unlock-函数"><a href="#pthread-mutex-unlock-函数" class="headerlink" title="pthread_mutex_unlock 函数"></a>pthread_mutex_unlock 函数</h4><ul><li>函数描述：对互斥锁解锁，可理解为将 mutex++</li><li>函数原型：<code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></li></ul><h4 id="pthread-mutex-trylock-函数"><a href="#pthread-mutex-trylock-函数" class="headerlink" title="pthread_mutex_trylock 函数"></a>pthread_mutex_trylock 函数</h4><ul><li>函数描述：尝试加锁</li><li>函数原型：<code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code></li><li>函数参数：mutex – 互斥锁变量</li></ul><h3 id="加锁和解锁"><a href="#加锁和解锁" class="headerlink" title="加锁和解锁"></a>加锁和解锁</h3><ul><li>lock 尝试加锁，如果加锁不成功，线程阻塞，阻塞到持有该互斥量的其他线程解锁为止</li><li>unlock 主动解锁函数，同时将阻塞在该锁上的所有线程全部唤醒，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒</li></ul><p><img src="/2025/03/21/file-io/threads/image11.png"> <img src="/2025/03/21/file-io/threads/image12.png"></p><p>总结：是用互斥锁之后，两个线程由并行变成了串行，效率降低了，但是可以使用两个线程同步操作共享资源，从而解决数据不一致的问题。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跟随鼠标移动的小球</title>
    <link href="/2025/04/06/easyx-demo/"/>
    <url>/2025/04/06/easyx-demo/</url>
    
    <content type="html"><![CDATA[<h1 id="跟随鼠标移动的小球"><a href="#跟随鼠标移动的小球" class="headerlink" title="跟随鼠标移动的小球"></a>跟随鼠标移动的小球</h1><h2 id="绘制边框"><a href="#绘制边框" class="headerlink" title="绘制边框"></a>绘制边框</h2><p>EasyX 绘图函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">HWND <span class="hljs-title">initgraph</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> width,          <span class="hljs-comment">// 窗口宽度</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> height,         <span class="hljs-comment">// 窗口高度</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> flag = <span class="hljs-literal">NULL</span>     <span class="hljs-comment">// 窗口样式</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>使用该函数创建窗口后，屏幕会闪过一个窗口后，程序就结束运行了。<br> 通用的方法就是使用一个死循环来卡住程序。</p><p><img src="/2025/03/21/file-io/mo/image1.png" alt="通用游戏框架"></p><p>所有的游戏都依赖一个循环来不断更新画面、读入玩家操作事件，而这个循环就叫做游戏的“主循环”</p><h2 id="绘制小球"><a href="#绘制小球" class="headerlink" title="绘制小球"></a>绘制小球</h2><p><code>solidcircle</code> 函数用于画无边框的填充圆</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solidcircle</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> x,          <span class="hljs-comment">// 圆心 x 坐标</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> y,          <span class="hljs-comment">// 圆心 y 坐标</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> radius      <span class="hljs-comment">// 圆的半径</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>在窗口的 (300, 300) 位置绘制一个半径为 100 的圆：<code>solidcircle(300, 300, 100);</code></p><h2 id="处理鼠标移动事件"><a href="#处理鼠标移动事件" class="headerlink" title="处理鼠标移动事件"></a>处理鼠标移动事件</h2><p><code>peekmessage</code> 函数用于获取一个消息，并立即返回</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">peekmessage</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    ExMessage *msg,         <span class="hljs-comment">// 指向消息结构体 ExMessage 的指针，用来保存获取到的消息</span></span></span><br><span class="hljs-params"><span class="hljs-function">    BYTE filter = <span class="hljs-number">-1</span>,       <span class="hljs-comment">// 指定要获取的消息范围，默认 -1 获取所有类别的消息</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">bool</span> removemsg = <span class="hljs-literal">true</span>   <span class="hljs-comment">// 在 peekmessage 处理完消息后，是否将其从消息队列中移除</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><br><br></code></pre></td></tr></table></figure><p>在 EasyX 中鼠标的移动、点击或者是键盘的按键操作都称作为“消息”。</p><p><img src="/2025/03/21/file-io/mo/image2.png"></p><p>当我们触发这些消息的时候，EasyX 会将其放置到自己的消息队列中</p><p><img src="/2025/03/21/file-io/mo/image3.png"></p><p>当我们每次调用 peekmessage 函数便尝试从消息队列中拉去一个消息，如果成功拉去到了消息，那么函数则会返回 true，反之则返回 false</p><p><img src="/2025/03/21/file-io/mo/image4.png"></p><p>这样，我们不断地从队列中拉去已有的消息进行处理</p><p><img src="/2025/03/21/file-io/mo/image5.png"></p><p>现在开始就需要对存储消息的结构体进行分析 &lt;<a href="https://docs.easyx.cn/zh-cn/exmessage">ExMessage 结构体</a>&gt; <br> 查看文档可知，结构体中的 <code>message</code> 成员对应的 <code>WM_MOUSEMOVE</code> 就是鼠标移动对应的消息。</p><p>我们定义两个变量 x 和 y，用来保存圆心位置，当鼠标移动的时候将当前鼠标坐标赋值给它们。这样写好后，就会导致窗口中的圆越来越多。这是因为在绘制新圆的时候，没有将旧的圆擦除。解决的方法很简单，在每次循环绘制圆的之前，将整个窗口清空一次就可以了。</p><p>画出圆后屏幕上的圆会不断闪烁，这是因为没有使用双缓冲绘图导致的。在代码中添加三行代码就可以解决：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">BeginBatchDraw</span>();<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 游戏主循环</span><br>    <span class="hljs-built_in">FlushBatchDraw</span>();<br>&#125;<br><span class="hljs-built_in">EndBatchDraw</span>();<br></code></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/BV1iQ4y1s7Qj?vd_source=d3a8a2f439156e68b612ac4b2fcf649a">视频教程</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>游戏开发</tag>
      
      <tag>EasyX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号</title>
    <link href="/2025/03/27/signals/"/>
    <url>/2025/03/27/signals/</url>
    
    <content type="html"><![CDATA[<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><h2 id="信号介绍"><a href="#信号介绍" class="headerlink" title="信号介绍"></a>信号介绍</h2><h3 id="信号的概念"><a href="#信号的概念" class="headerlink" title="信号的概念"></a>信号的概念</h3><p>信号是信息的载体，Linux&#x2F;Unix 环境下，古老、经典的通信方式，现下依然是主要的通信手段。</p><ul><li>信号在我们的生活中随处可见，例如：<ul><li>古代战争中摔杯为号</li><li>现代战争中的信号弹</li><li>体育比赛中使用的信号强……</li></ul></li><li>信号的特点<ul><li>简单</li><li>不能携带大量信息</li><li>满足某个特定条件参会产生</li></ul></li></ul><h2 id="信号的机制"><a href="#信号的机制" class="headerlink" title="信号的机制"></a>信号的机制</h2><p>进程 A 给进程 B 发送信号，进程 B 收到信号之前执行自己的代码，收到信号后不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕后再继续执行。与硬件中断类似 —— 异步模式。但信号是软件层面上实现的终端，早期常被称为“软中断”。</p><p><strong>每个进程收到的所有信号，都是由内核负责发送的。</strong></p><p><img src="/2025/03/27/signals/image1.png" alt="进程 A 给进程 B 发送信号示意图"></p><h3 id="信号的状态"><a href="#信号的状态" class="headerlink" title="信号的状态"></a>信号的状态</h3><p>信号由三种状态：产生、未决和递达</p><ul><li>信号的产生<ul><li>按键产生，如：Ctrl + c、Ctrl + z、Ctrl + \</li><li>系统调用产生，如：kill、raise、abort</li><li>软件条件山城，如：定时器 alarm</li><li>硬件异常产生，如：非法访问内存 (错误段)、除 0 (浮点数例外)、内存对齐出错 (总线错误)</li><li>命令产生，如：kill 命令</li></ul></li><li>未决： 产生和递达之间的状态。主要由于阻塞 (屏蔽) 导致该状态</li><li>递达：递送并且达到进程</li></ul><h3 id="信号处理方式"><a href="#信号处理方式" class="headerlink" title="信号处理方式"></a>信号处理方式</h3><ul><li>执行默认动作</li><li>忽略信号 (丢弃不处理)</li><li>捕捉信号 (调用用户的自定义的处理函数)</li></ul><h3 id="信号的特质"><a href="#信号的特质" class="headerlink" title="信号的特质"></a>信号的特质</h3><p>信号的实现手段导致信号<strong>有很强的延时性</strong>，但对于用户来说，时间非常短，不易察觉。</p><p>Linux 内核的进程控制块 PCB 是一个结构体，task_struct，除了包含进程 id，状态，工作目录，用户 id，组 id，文件描述符表，还包含了信号相关的信息，主要指<strong>阻塞信号集和未决信号集</strong>。</p><h3 id="阻塞信号集和未决信号集"><a href="#阻塞信号集和未决信号集" class="headerlink" title="阻塞信号集和未决信号集"></a>阻塞信号集和未决信号集</h3><ul><li>阻塞信号集中保存的都是被当前进程阻塞的信号。若当前进程收到的是阻塞信号集中的某些信号，这些信号需要暂时被阻塞，不予处理。</li><li>信号产生后由于某些原因 (主要是阻塞) 不能抵达，这类信号的集合称之为未决信号集。在屏蔽解除之前，信号一直处于未决状态；若是信号从阻塞信号集中解除阻塞，则该信号会被处理，并从未决信号集中去除。</li></ul><h3 id="信号的四要素"><a href="#信号的四要素" class="headerlink" title="信号的四要素"></a>信号的四要素</h3><ul><li>通过 <code>man 7 signal</code> 可以查看相关信号信息<ul><li>1 信号的编号<ul><li>使用 <code>kill -l</code> 命令可以查看当前系统有哪些信号，不存在编号为 0 的信号。其中 1-31 号信号称之为常规信号 (也叫普通信号或标准信号)，34-64 称之为实时信号，驱动变成与硬件相关。</li></ul></li><li>信号的名称</li><li>产生信号的事件</li><li>信号的默认处理动作：<ul><li>Term：终止进程</li><li>Ign：忽略信号 (默认即使对该种信号忽略操作)</li><li>Core：终止进程，生成 Core 文件。(查验死亡原因，用于 gdb 调试)</li><li>Stop：停止 (暂停) 进程</li><li>Cont：继续运行进程</li></ul></li></ul></li><li>特别需要注意的是：<code>The signals SIGKILL and SIGSTOP connot be caught, blocked, or ignored.</code></li><li>几个常用到的信号：<br>SIGINT、SIGQUIT、SIGKILL、SIGSEGV、SIGUSR1、SIGUSR2、SIGPIPE、SIGALRM、SIGTERM、SIGCHLD、SIGSTOP、SIGCONT</li></ul><h2 id="信号相关函数"><a href="#信号相关函数" class="headerlink" title="信号相关函数"></a>信号相关函数</h2><h3 id="signal-函数"><a href="#signal-函数" class="headerlink" title="signal 函数"></a>signal 函数</h3><ul><li>函数作用：注册新号捕捉函数</li><li>函数原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*<span class="hljs-type">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">sighandler_t</span> <span class="hljs-title function_">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signul, <span class="hljs-type">sighandler_t</span> handler)</span>;<br></code></pre></td></tr></table></figure></li><li>函数参数：<ul><li>signum：信号编号</li><li>handler：信号处理函数</li></ul></li></ul><h3 id="kill-函数-命令"><a href="#kill-函数-命令" class="headerlink" title="kill 函数&#x2F;命令"></a>kill 函数&#x2F;命令</h3><ul><li>描述：给指定进程发送指定信号</li><li>kill 命令：<code>kill -SIGKILL 进程 PID</code></li><li>kill 函数原型：<code>int kill(pid_t pid, int sig);</code></li><li>函数返回值：<ul><li>成功：0</li><li>失败：-1，设置 errno</li></ul></li><li>函数参数：<ul><li>sig 信号参数：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</li><li>pid 参数：<ul><li>pid &gt; 0：发送信号给指定进程</li><li>pid &#x3D; 0：发送信号给与调用 kill 函数进程属于同一组的所有进程</li><li>pid &lt; -1：取 pid 发给对应进程组</li><li>pid &#x3D; -1：发送给进程有权限发送的系统中所有进程</li></ul></li></ul></li></ul><p>进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们互相关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组 ID 与组长 ID 相同。</p><h3 id="abort-函数-raise-函数"><a href="#abort-函数-raise-函数" class="headerlink" title="abort 函数&#x2F; raise 函数"></a>abort 函数&#x2F; raise 函数</h3><h4 id="raise-函数"><a href="#raise-函数" class="headerlink" title="raise 函数"></a>raise 函数</h4><ul><li>函数描述：给当前进程发送指定信号 (自己给自己发)</li><li>函数原型：<code>int raise(int sig);</code></li><li>函数返回值：成功：0，失败非 0 值</li><li>函数拓展：<code>raise(signo) == kill(getpid(), signo);</code></li></ul><h4 id="abort-函数"><a href="#abort-函数" class="headerlink" title="abort 函数"></a>abort 函数</h4><ul><li>函数描述：给自己发送异常终止信号 (SIGABRT)，并产生 core 文件</li><li>函数原型：<code>void abort();</code></li><li>函数拓展：<code>abort() == kill(getpid(), SIGABRT);</code></li></ul><h3 id="alarm-函数"><a href="#alarm-函数" class="headerlink" title="alarm 函数"></a>alarm 函数</h3><ul><li>函数描述：设置定时器 (闹钟)。在指定 seconds 后，内核会给当前进程发送 SIGALRM 信号。进程收到该信号，默认动作终止。<strong>每个进程都有且只有唯一一个定时器</strong>。</li><li>函数原型：<code>unsigned int alarm(unsigned int seconds);</code></li><li>函数返回值：返回 0 或剩余的秒数，无失败。例如：<br><img src="/2025/03/27/signals/image2.png"></li><li>常用操作：取消定时去 alarm(0)，返回旧闹钟余下秒数。<br> alarm 使用的是自然定时器，与进程状态无关，就绪、运行、挂起 (阻塞、暂停)、终止、僵尸…无论进程处于何种状态，alarm 都计时。</li></ul><h3 id="setitimer-函数"><a href="#setitimer-函数" class="headerlink" title="setitimer 函数"></a>setitimer 函数</h3><ul><li>函数原型：<code>int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);</code></li><li>函数描述：设置定时器去 (闹钟)，可替代 alarm 函数，精度微秒 us，可以实现周期定时</li><li>函数返回值：<ul><li>成功：0</li><li>失败：-1，设置 errno</li></ul></li><li>函数参数：<ul><li>which：指定定时方式<ul><li>自然定时：ITIMER_REAL -&gt; SIGALRM 计算自然时间</li><li>虚拟空间计时 (用户空间)：ITIMER_VIRTUAL -&gt; SIGVTALRM 只计算进程占用 cpu 时间</li><li>运行时即使 (用户 + 内核)：ITIMER_PROF -&gt; SIGPROF 计算占用 cpu 及执行系统调用时间</li></ul></li><li>new_value：struct itimerval，负责设定 timeout 时间<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">itimerval</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timerval</span> <span class="hljs-title">it_interval</span>;</span> <span class="hljs-comment">// 闹钟触发周期</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timerval</span> <span class="hljs-title">it_value</span>;</span>   <span class="hljs-comment">// 闹钟触发时间</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timerval</span> &#123;</span><br>    <span class="hljs-type">long</span> tv_sec;    <span class="hljs-comment">// 秒</span><br>    <span class="hljs-type">long</span> tv_usec;   <span class="hljs-comment">// 微秒</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li>old_value：存放旧的 timeout 值，一般指定为 NULL</li></ul></li></ul><h2 id="信号集相关"><a href="#信号集相关" class="headerlink" title="信号集相关"></a>信号集相关</h2><h3 id="未决信号集和阻塞信号集得关系"><a href="#未决信号集和阻塞信号集得关系" class="headerlink" title="未决信号集和阻塞信号集得关系"></a>未决信号集和阻塞信号集得关系</h3><p>阻塞信号集是当前进程要阻塞的信号的集合，未决信号集是当前进程中还处于未决状态的信号的集合，这两个集合存储在内核的 PCB 中。</p><ul><li>下面以 SIGINT 为例说明未决信号集和阻塞信号集的关系：<br>当进程收到一个 SIGINT (信号编号为2) 信号，首先这个信号灰保存在未决信号集合中，此时对应的 2 号编号的这个位置上置为 1，表示处于未决状态；在这个信号需要被处理之前首先要在阻塞信号集中的编号为 2 的位置上去检查该值是否为 1：<ul><li>如果为 1，表示 SIGINT 信号被当前进程阻塞了，这个信号暂时不被处理，所以未决信号集上该位置上的值保持为 1，表示该信号处于未决状态；</li><li>如果为 0，表示 SIGINT 信号没有被当前进程阻塞，这个信号需要被处理，内核会对 SIGINT 信号进程处理 (执行默认动作，忽略或者执行用户自定义的信号处理函数)，并将未决信号集中编号为 2 的位置上将 1 变为 0，表示该信号已经处理了，这个时间非常短暂，用户感知不到。</li></ul></li></ul><p>当 SIGINT 信号从阻塞信号集中接触阻塞之后，该信号就会被处理。<br><img src="/2025/03/27/signals/image3.png"></p><h3 id="信号集相关函数"><a href="#信号集相关函数" class="headerlink" title="信号集相关函数"></a>信号集相关函数</h3><p>由于信号集属于内核的一块区域，用户不能直接操作内核空间，为此，内核提供了一些信号集相关的接口函数，使用这些函数用户就可以完成对于信号集的相关操作。</p><p>信号集是一个能表示多个信号的数据类型，<code>sigset_t set</code>，set 即一个信号集。既然是一个集合，就需要对集合进行添加、删除等操作。</p><p>sigset_t 类型的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">__sigset_t</span> <span class="hljs-type">sigset_t</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int)))</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> __val[_SIGSET_NWORDS];<br>&#125; <span class="hljs-type">__sigset_t</span>;<br></code></pre></td></tr></table></figure><h4 id="信号集相关函数-1"><a href="#信号集相关函数-1" class="headerlink" title="信号集相关函数"></a>信号集相关函数</h4><ul><li><code>int sigemptyset(sigset_t *set);</code> <br> 函数说明：将某个信号清 0 <br> 函数返回值：成功：0，失败：-1，设置 errno</li><li><code>int sigfillset(sigset_t *set);</code> <br> 函数说明：将某个信号集置 1 <br> 函数返回值：成功：0，失败：-1，设置 errno</li><li><code>int sigaddset(sigset_t *set, int signum);</code> <br> 函数说明：将某个信号加入信号集中 <br> 函数返回值：成功：0，失败：-1，设置 errno</li><li><code>int sigdelset(sigset_t *set, int signum);</code> <br> 函数说明：将某个信号从信号集中清除 <br> 函数返回值：成功：0，失败：-1，设置 errno</li><li><code>int sigismember(const sigset_t *set, int signum);</code> <br> 函数说明：判断某个信号是否在信号集中 <br> 函数返回值：在：1；不在：0；出错：-1，设置 errno</li><li>sigprocmask 函数<ul><li>函数说明：用来屏蔽信号、接触屏蔽也是用该函数。其本质，读取或修改进程控制块中的信号屏蔽字 (阻塞信号集)。<br> <strong>特别注意，屏蔽信号只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢弃处理。</strong></li><li>函数原型：<code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</code></li><li>函数返回值：成功：0；失败：-1，设置 errno</li><li>函数参数：<ul><li>how 参数取值：假设当前的信号屏蔽字为 mask<ul><li>SIG_BLOCK：当 how 这只为此，set 表示需要屏蔽的信号。相当于 mask &#x3D; mask | let</li><li>SIG_UNBLOCK：当 how 设置为此，set 表示需要解除屏蔽的信号。相当于 mask &#x3D; mask &amp; ~set;</li><li>SIG_SETMASK：当 how 设置为此，set 表示用于替代原始屏蔽集的额新屏蔽集。相当于 mask &#x3D; set 若，调用 sigprocmask 解除了对当前若干个信号的阻塞，则在 sigprocmask 返回前，至少将其中一个信号递达。</li></ul></li><li>set：传入参数，是一个自定义信号集合。由参数 how 来指示如何修改当前信号屏蔽字。</li><li>oldset：传出参数，保存旧的信号屏蔽字。</li></ul></li></ul></li><li>sigpending 函数<ul><li>函数原型：<code>int sigpending(sigset_t *set);</code></li><li>函数说明：读取当前进程的未决信号集</li><li>函数参数：set 传出参数</li><li>函数返回值：成功：0；失败：-1，设置 errno</li></ul></li></ul><h2 id="信号捕捉函数"><a href="#信号捕捉函数" class="headerlink" title="信号捕捉函数"></a>信号捕捉函数</h2><ul><li>signal 函数</li><li>sigaction 函数<ul><li>函数说明：注册一个信号处理函数</li><li>函数原型：<code>int sigaction(int signum, const struct sigaction *act, struct sigaction* oldact);</code></li><li>函数参数：<ul><li>signum：捕捉信号</li><li>act：传入参数，新的处理方式</li><li>oldact：传出参数，旧的处理方式</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> &#123;</span><br>  <span class="hljs-type">void</span> (*sa_handler)(<span class="hljs-type">int</span>);  <span class="hljs-comment">// 信号处理函数</span><br>  <span class="hljs-type">void</span> (*sa_sigaction)(<span class="hljs-type">int</span>, <span class="hljs-type">siginfo_t</span> *, <span class="hljs-type">void</span> *); <span class="hljs-comment">// 信号处理函数</span><br>  <span class="hljs-type">sigset_t</span> sa_mask; <span class="hljs-comment">// 信号处理函数执行期间需要阻塞的信号</span><br>  <span class="hljs-type">int</span> sa_flags; <span class="hljs-comment">// 通常为 0，表示使用默认表示</span><br>  <span class="hljs-type">void</span> (*sa_restore)(<span class="hljs-type">void</span>);<br>&#125;;<br></code></pre></td></tr></table></figure></li><li>总结：<ul><li>sa_handler：指定信号捕捉后的处理函数名 (既注册函数)。也可复制为 SIG_IGN 表忽略或 SIG_DFL 表执行默认动作。</li><li>sa_mask：用来指定在信号处理函数执行期间需要被屏蔽的信号，特别是当某个信号被处理时，它自身会被自动放入进程的信号掩码，因此在信号处理函数执行期间这个信号不会再度发生。注意：仅在处理函数被调用期间屏蔽生效，是临时性设置。</li><li>sa_flags：通常设置为 0，使用默认属性。</li><li>sa_restore：已不再使用</li></ul></li><li>知识点：<ul><li>在 XXX 信号处理函数执行期间，XXX 信号是被阻塞的，如果该信号产生了多次，在 XXX 信号处理函数结束之后，该 XXX 信号只被处理一次。</li><li>在 XXX 信号处理函数执行期间，如果阻塞了 YYY 信号，若 YYY 信号产生了多次，当 XXX 信号处理函数结束后，YYY 信号只会被处理一次。</li></ul></li><li>内核实现信号捕捉过程 <br> 如果信号的处理动作是用户自定义函数，在信号递达时旧调用这个函数，这称为捕捉信号，由于信号处理函数的代码是在用户空间的，处理过程比较复杂，距离如下：<ol><li>用户程序注册了 SIGQUIT 信号的处理函数 sighandler</li><li>当前正在执行 main 函数，这时发生中断或异常切换到内核态</li><li>在终端处理完毕后要返回用户态的 main 函数之前检查到有信号 SIGQUIT 递达</li><li>内核决定返回用户态后不是恢复 main 函数的上下文继续执行，而是执行 sighandler 函数，sighandler 和 main 函数使用不同的堆栈空间，他们之间不存在调用和被调用的关系，是两个独立的控制流程，</li><li>sighandler 函数返回后自动执行特殊的系统调用 sigreturn 再次进入内核态</li><li>如果没有新的信号要递达，这次再返回用户态就是恢复 main 函数的上下文继续执行了。</li></ol></li></ul></li></ul><p><img src="/2025/03/27/signals/image4.png"></p><h2 id="SIGCHLD-信号"><a href="#SIGCHLD-信号" class="headerlink" title="SIGCHLD 信号"></a>SIGCHLD 信号</h2><h3 id="产生-SIGCHLD-信号的条件"><a href="#产生-SIGCHLD-信号的条件" class="headerlink" title="产生 SIGCHLD 信号的条件"></a>产生 SIGCHLD 信号的条件</h3><ul><li>子进程结束的时候</li><li>子进程收到 SIGSTOP 信号</li><li>当子进程停止时，收到 SIGCONT 信号</li></ul><h3 id="SIGCHLD-信号的作用"><a href="#SIGCHLD-信号的作用" class="headerlink" title="SIGCHLD 信号的作用"></a>SIGCHLD 信号的作用</h3><p>子进程推出后，内核会给它的父进程发送 SIGCHLD 信号，父进程收到这个信号后可以对子进程进行回收</p><p>使用 SIGCHLD 信号完成对子进程的回收可以避免父进程阻塞等待而不能执行其他操作，只有当父进程收到 SIGCHLD 信号之后采取调用信号捕捉函数完成对子进程的回收，未收到 SIGCHLD 信号之前可以处理其他操作。</p><h3 id="使用-SIGCHLD-信号完成对子进程的回收"><a href="#使用-SIGCHLD-信号完成对子进程的回收" class="headerlink" title="使用 SIGCHLD 信号完成对子进程的回收"></a>使用 SIGCHLD 信号完成对子进程的回收</h3><h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><ul><li>有可能未完成信号处理函数的注册，子进程都退出了<ul><li>解决办法：可以在 fork 之前先将 SIGCHLD 信号阻塞，当完成信号处理函数的注册而后再解除阻塞</li></ul></li><li>当 SIGCHLD 信号函数处理期间，SIGCHLD 信号若再次产生是被阻塞的，而且若产生了多次，则该信号只会被处理一次，这样可能会产生僵尸进程。<ul><li>解决办法：可以在信号处理函数里面使用 while(1) 循环回收，这样就有可能出现不过一次 SIGCHLD 信号但是回收了多个子进程的情况，从而避免僵尸进程的产生。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程间通信</title>
    <link href="/2025/03/26/process-communicate/"/>
    <url>/2025/03/26/process-communicate/</url>
    
    <content type="html"><![CDATA[<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h2 id="进程间通信相关概念"><a href="#进程间通信相关概念" class="headerlink" title="进程间通信相关概念"></a>进程间通信相关概念</h2><h3 id="什么是进程间通信"><a href="#什么是进程间通信" class="headerlink" title="什么是进程间通信"></a>什么是进程间通信</h3><p>Linux 环境下，进程地址空间相互独立，每个进程各自由不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核种开辟一块缓冲区，进程 1 把数据从用户空间拷贝到内核缓冲区，进程 2 再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信 (IPC，InterProcess Communication)。</p><p><img src="/2025/03/26/process-communicate/image1.png"></p><h3 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h3><p>在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用，现今常用的进程间通信方式有：</p><ul><li>管道 (使用最简单)</li><li>信号 (开销最小)</li><li>共享映射区 (无血缘关系)</li><li>本地套接字 (最稳定)</li></ul><h2 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道 - pipe"></a>管道 - pipe</h2><h3 id="管道的概念"><a href="#管道的概念" class="headerlink" title="管道的概念"></a>管道的概念</h3><p>管道是一种最基本的 IPC 机制，也称匿名管道，应用于有血缘关系的进程之间，完成数据传递。调用 pipe 函数即可创建一个管道。</p><p><img src="/2025/03/26/process-communicate/image2.png"></p><p>有如下特质：</p><ul><li>管道的本质是一块内核缓冲区</li><li>由两个文件描述符引用，一个表示读端，一个表示写端</li><li>规定数据从管道的写端流入管道，从读端流出。</li><li>当两个进程都终结的时候，管道也自动消失</li><li>管道的读端和写端默认都是阻塞的。</li></ul><h3 id="管道的原理"><a href="#管道的原理" class="headerlink" title="管道的原理"></a>管道的原理</h3><ul><li>管道的实质是内核缓冲区，内部使用环形队列实现。</li><li>默认缓冲区大小为 4K，可以使用 <code>ulimit -a</code> 命令获取大小</li><li>实际操作过程中缓冲区会根据数据压力做适当调整</li></ul><h3 id="管道的局限性"><a href="#管道的局限性" class="headerlink" title="管道的局限性"></a>管道的局限性</h3><ul><li>数据一旦被读走，便不在管道中存在，不可反复读取</li><li>数据只能在一个方向上流动，若要实现双向流动，必须使用两个管道。</li><li>只能在有血缘关系的进程间使用管道。</li></ul><h3 id="创建管道-pipe-函数"><a href="#创建管道-pipe-函数" class="headerlink" title="创建管道 - pipe 函数"></a>创建管道 - pipe 函数</h3><ul><li>函数作用：创建一个管道</li><li>函数原型：<code>int pipe(int fd[2]);</code></li><li>函数参数：若函数调用成功，fd[0] 存放管道的读端，fd[1] 存放管道的写端</li><li>返回值：<ul><li>成功返回 0</li><li>失败返回 -1，并设置 errno 值</li></ul></li></ul><p>函数调用成功返回读端和写端的文件描述符，其中 fd[0] 是读端，fd[1] 是写端，向管道读写数据是通过使用这两个文件描述符进行的，读写管道的实质是操作内核缓冲区。</p><p>管道创建成功以后，创建该管道的进程 (父进程) 同时掌握着管道的读端和写端。</p><h3 id="父子进程使用管道通信"><a href="#父子进程使用管道通信" class="headerlink" title="父子进程使用管道通信"></a>父子进程使用管道通信</h3><p>一个进程在由 pipe() 创建管道后，一般再 fork 一个子进程，然后通过管道实现父子进程间的通信 (因此也不难推出，只要两个进程种存在血缘关系，这里的血缘关系指的是具有共同的祖先，都可以采用管道方式进行通信)。<strong>父子进程间具有相同的文件描述符，且指向同一个管道 pipe</strong>，其他没有关系的进程不能获取 pipe() 产生的两个文件描述符，也就不能利用同一个管道进行通信。</p><ol><li>父进程创建管道 <br><img src="/2025/03/26/process-communicate/image3.png"></li><li>父进程 fork 处子进程 <br><img src="/2025/03/26/process-communicate/image4.png"></li><li>父进程关闭 fd[0]，子进程关闭 fd[1] <br><img src="/2025/03/26/process-communicate/image5.png"></li></ol><p>关键步骤总结：</p><ul><li>父进程调用 pipe 函数创建管道，得到两个文件描述符 fd[0] 和 fd[1]，分别指向管道的读端和写端</li><li>父进程调用 fork 创建子进程，那么子进程也有两个文件描述符指向同一管道。</li><li>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出，这样就实现了父子进程间通信。</li></ul><h3 id="管道的读写行为"><a href="#管道的读写行为" class="headerlink" title="管道的读写行为"></a>管道的读写行为</h3><ul><li>读操作<ul><li>有数据 <br>read 正常读，返回读出的字节数</li><li>无数据<ul><li>写端全部关闭 <br> read 解除阻塞，返回 0，相当于读文件到了尾部</li><li>没有全部关闭 <br> read 阻塞</li></ul></li></ul></li><li>写操作<ul><li>读端全部关闭 <br> 管道破裂，进程终止，内核给当前进程发 SIGPIPE 信号</li><li>读端没有全部关闭<ul><li>缓冲区写满了 <br> write 阻塞</li><li>缓冲区没有满 <br> 继续 write</li></ul></li></ul></li></ul><h3 id="如何设置管道为非阻塞"><a href="#如何设置管道为非阻塞" class="headerlink" title="如何设置管道为非阻塞"></a>如何设置管道为非阻塞</h3><p>默认情况下，管道的读写两端都是阻塞的，若要设置读或者写为非阻塞，则可参考下列三个步骤：</p><ol><li><code>int flags = fcntl(fd[0], F_GETTL, 0);</code></li><li><code>flags |= O_NONBLOCK;</code></li><li><code>fcntl(fd[0], F_SETFL, flags);</code></li></ol><p>若是读端设置为非阻塞：</p><ul><li>写端没有关闭，管道中没有数据可读，则 read 返回 -1；</li><li>写端没有关闭，<strong>管道中数据可读</strong>，则 read 返回实际读到的字节数</li><li>写端已经关闭，<strong>管道中有数据可读</strong>，则 read 返回实际督导的字节数</li><li>写端已经关闭，管道中没有数据可读，则 read 返回 0</li></ul><h3 id="如何查看管道缓冲区大小"><a href="#如何查看管道缓冲区大小" class="headerlink" title="如何查看管道缓冲区大小"></a>如何查看管道缓冲区大小</h3><ul><li>命令 <br> <code>ulimit -a</code></li><li>函数 <br> <code>long fpathconf(int fd, int name);</code> <br> <code>printf(&quot;pipe size == [%ld]\n&quot;, fd[0], _PC_PIPE_BUF);</code> <br> <code>printf(&quot;pipe size == [%ld]\n&quot;, fd[1], _PC_PIPE_BUF);</code></li></ul><h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><h3 id="FIFO-介绍"><a href="#FIFO-介绍" class="headerlink" title="FIFO 介绍"></a>FIFO 介绍</h3><p><strong>FIFO 常被称为命名管道</strong>，以区分管道 (pipe)。管道 (pipe) 只能用于 “有血缘关系”的进程间通信。<strong>但通过 FIFO，不相关的进程也能交换数据</strong>。</p><p>FIFO 是 Linux <strong>基础文件类星</strong>中的一种 (<strong>文件类型为 p</strong>，可通过 ls -l 查看文件类型)。但 FIFO 文件在磁盘上没有数据块，文件大小为 0，仅仅用来表示内核中一条通道。进程间可以打开这个文件进行 read&#x2F;write，实际上是在读写内核缓冲区，这样就实现了进程间通信。</p><h3 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h3><ul><li>方式1 - 使用命令 mkfifo <br> 命令格式：mkfifo 管道名 <br> 例如：<code>mkfifo myfifo</code></li><li>方式2 - 使用函数 <br> <code>int mkfifo(const char* pathname, mode_t mode);</code> <br> 参数说明和返回值可以查看 <code>man 3 mkfifo</code></li></ul><p>当创建了一个 FIFO，就可以使用 open 函数打开它，常见的文件 I&#x2F;O 函数都可用于 FIFO。如：close、read、write、unlink 等。</p><p>FIFO 严格遵循先进先出 (first in first out)，对 FIFO 的读总是从开始处返回数据，对他们的写则把数据添加到末尾。<strong>它们不支持诸如 lseek() 等文件定位操作。</strong></p><h3 id="使用-FIFO-完成两个进程通信"><a href="#使用-FIFO-完成两个进程通信" class="headerlink" title="使用 FIFO 完成两个进程通信"></a>使用 FIFO 完成两个进程通信</h3><p><img src="/2025/03/26/process-communicate/image6.png" alt="使用 FIFO 完成两个进程通信示意图"></p><p>思路：</p><ul><li>进程 A：<ul><li>创建一个 fifo 文件：myfifo</li><li>调用 open 函数打开 myfifo 文件</li><li>调用 write 函数写入一个字符串如： “hello world” (其实就是将数据写入到内核缓冲区) </li><li>调用 close 函数关闭 myfifo 文件</li></ul></li><li>进程 B：<ul><li>调用 open 函数打开 myfifo 文件</li><li>调用 read 函数读取文件内容 (其实就是从内核中读取数据)</li><li>打印显示读取内容</li><li>调用 close 函数关闭 myfifo 文件</li></ul></li></ul><h2 id="内存映射区"><a href="#内存映射区" class="headerlink" title="内存映射区"></a>内存映射区</h2><h3 id="存储映射区介绍"><a href="#存储映射区介绍" class="headerlink" title="存储映射区介绍"></a>存储映射区介绍</h3><p>存储映射 I&#x2F;O (Memory-mapped I&#x2F;O) 使一个磁盘文件与存储空间中的一个缓冲区像映射。从缓冲区中取数据，就相当于读文件中的相应字节；将数据写入缓冲区，则会将数据写入文件。这样，就可在不使用 read 和 write 函数的情况下，使用地址 (指针) 完成 I&#x2F;O 操作。</p><p>使用存储映射这种方法，首先应通知内核，将一个指定文件映射到存储区域中，这个映射工作可以通过 mmap 函数来实现。</p><p><img src="/2025/03/26/process-communicate/image7.png"></p><h3 id="mmap-函数"><a href="#mmap-函数" class="headerlink" title="mmap 函数"></a>mmap 函数</h3><ul><li>函数作用：建立存储映射区</li><li>函数原型：<code>void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);</code></li><li>函数返回值：<ul><li>成功：返回创建的映射区首地址</li><li>失败：MAP_FAILED 、宏</li></ul></li><li>参数：<ul><li>addr：指定映射的起始地址，通常设为 NULL，由系统指定</li><li>length：映射到内存的额文件长度</li><li>prot：映射区的保护方式，最常用：<ul><li>读：PROT_READ</li><li>写：PROT_WRITE</li><li>读写：PROT_READ | PROT_WRITE</li></ul></li><li>flags：映射区的特性，可以是<ul><li>MAP_SHARED：写入映射区的数据会写回文件，且允许其他映射该文件的进程共享</li><li>MAP_PRIVATE：对映射区的写入操作会产生一个映射区的复制 (copy-on-write)，对此区域所做的修改不会写回原文件</li></ul></li><li>fd：由 open 返回的文件描述符，代表要映射的文件。</li><li>offset：以文件开始处的偏移量，<strong>必须是 4K 的正数倍</strong>，通常为 0，表示从文件头开始映射</li></ul></li></ul><h3 id="munmap-函数"><a href="#munmap-函数" class="headerlink" title="munmap 函数"></a>munmap 函数</h3><ul><li>函数作用：释放由 mmap 函数建立的存储映射区</li><li>函数原型：<code>int munmap(void *addr, size_t length)</code></li><li>返回值：<ul><li>成功：返回 0</li><li>失败：返回 -1，设置 errno 值</li></ul></li><li>函数参数：<ul><li>addr：调用 mmap 函数成功返回的映射区首地址</li><li>length：映射区大小 (mmap 函数的第二个参数)</li></ul></li></ul><h3 id="mmap-注意事项"><a href="#mmap-注意事项" class="headerlink" title="mmap 注意事项"></a>mmap 注意事项</h3><ul><li>创建映射区的过程中，隐含着一次对映射文件的读操作，将文件内容读取到映射区</li><li>当 MAP_SHARED 时，要求：映射区的权限应 &lt;&#x3D; 文件打开的权限 (出于对映射区的保护)。而 MAP_PRIVATE 则不所谓，因为 mmap 中的权限是对内存的限制。</li><li>映射区的释放与文件关闭无关，只要映射建立成功，文件可以立即关闭。</li><li>特别注意，当映射文件大小为 0 时，不能创建映射区。所以，用于映射的文件必须要有实际大小；mmap 使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。</li><li>munmap 传入的地址一定是 mmap 的返回地址。坚决杜绝指针 ++ 操作</li><li>文件偏移量必须为 0 或者 4K 的整数倍</li><li>mmap 创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</li></ul><h3 id="有关-mmap-函数的使用总结"><a href="#有关-mmap-函数的使用总结" class="headerlink" title="有关 mmap 函数的使用总结"></a>有关 mmap 函数的使用总结</h3><ul><li>第一个参数写成 NULL</li><li>第二个参数要映射的文件大小 &gt; 0</li><li>第三个参数：PROT_READ、PROT_WRITE</li><li>第四个参数：MAP_SHARED 或者 MAP_PRIVATE</li><li>第五个参数：打开的文件对应的文件描述符</li><li>第六个参数：4k 的正数倍</li></ul><p>使用 mmap 函数建立匿名映射：<br><code>mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</code></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程控制</title>
    <link href="/2025/03/25/process-control/"/>
    <url>/2025/03/25/process-control/</url>
    
    <content type="html"><![CDATA[<h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><h2 id="进程相关概念"><a href="#进程相关概念" class="headerlink" title="进程相关概念"></a>进程相关概念</h2><h3 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h3><ul><li>程序，是指编译好的二进制文件，在磁盘上，占用磁盘空间，是一个静态概念</li><li>进程，一个启动的程序，进程占用的是系统资源，如：物理内存，CPU，终端等，是一个动态的概念</li><li>程序 -&gt; 剧本(纸)</li><li>进程 -&gt; 戏(舞台、演员、灯光、道具……)</li></ul><p>同一个剧本可以在多个舞台同时上演。同样，一个程序也可以加载为不同的进程(彼此之间互不影响)</p><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><ul><li><p>并发，在一个短时间内，是在同一个 CPU 上，同时运行多个程序</p><p>如：若将 CPU 的 1S 的时间分成 1000 个时间片，每个进程执行完一个时间片必须无条件让出 CPU 的使用权，这样 1S 中就可以执行 1000 个进程。</p><p><img src="/2025/03/25/process-control/image1.png"></p><p><img src="/2025/03/25/process-control/image2.png"></p><p><img src="/2025/03/25/process-control/image3.png"></p><p><img src="/2025/03/25/process-control/image4.png"></p></li><li><p>并行是指两个或两个以上的程序在同一时刻发生(需要有多颗CPU核心)</p><p><img src="/2025/03/25/process-control/image5.png"></p><p><img src="/2025/03/25/process-control/image6.png"></p></li></ul><h3 id="PCB-进程控制块"><a href="#PCB-进程控制块" class="headerlink" title="PCB - 进程控制块"></a>PCB - 进程控制块</h3><p>每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。以下为常用成员：</p><ul><li>进程 id。系统中每个进程有唯一的 id，在 C 语言中用 pid_t 类型表示，其实就是一个非负整数。</li><li>进程的状态，有就绪、运行、挂起、停止等状态。</li><li>进程切换时需要保存和回复的一些 CPU 寄存器。</li><li>描述虚拟地址空间的信息。</li><li>描述控制终端的信息。</li><li>当前工作目睹 (Current Working Directory)<ul><li>getcwd –pwd</li></ul></li><li>umask 掩码</li><li>文件描述符，包含很多指向 file 结构体的指针</li><li>和信号相关的信息</li><li>用户 id 和组 id</li><li>会话 (Session) 和进程组</li><li>进程可以使用的资源上限 (Resource Limit)<ul><li>ulimit -a</li></ul></li></ul><h3 id="进程状态-面试考"><a href="#进程状态-面试考" class="headerlink" title="进程状态 (面试考)"></a>进程状态 (面试考)</h3><p>进程基本的状态有 5 种。分别为初始态、就绪态、运行态、挂起态与终止态。其中初始态为进程准备阶段，常与就绪太结合来看。</p><p><img src="/2025/03/25/process-control/image7.png"></p><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><h3 id="fork-函数"><a href="#fork-函数" class="headerlink" title="fork 函数"></a>fork 函数</h3><ul><li><p>函数作用：创建子进程</p></li><li><p>原型：<code>pit_t fort();</code></p></li><li><p>函数参数：无</p></li><li><p>返回值：</p><ul><li>调用成功：父进程返回子进程的 PID，子进程返回 0；</li><li>调用失败：返回 -1，设置 errno 值。</li></ul></li><li><p>fork 函数代码片段实例</p><p><img src="/2025/03/25/process-control/image8.png"></p></li><li><p>调用 fork 函数的内核实现原理：</p><p><img src="/2025/03/25/process-control/image9.png"></p></li><li><p>fork 函数总结</p><ul><li><p>fork 函数的返回值：</p><p>父进程返回子进程的 PID，是一个大于 0 的数；<br> 子进程返回0；<br> 特别需要注意的是：不是 fork 函数在一个进程种返回 2 个值，二十在父子进程各自返回一个值。</p></li><li><p>子进程创建成功后，代码的执行位置：</p><p>父进程执行到什么位置，子进程就从哪里执行</p></li><li><p>如何区分父子进程：</p><p>通过 fork 函数的返回值</p></li><li><p>父子进程的执行顺序</p><p>不一定，哪个进程先抢到 CPU，哪个进程就先执行</p></li><li><p>父子进程不能共享全局变量；</p><p>但是如果父子进程只是对全局变量做读操作，则步子进程在内存种只有一份，属于共享，但是如果父子进程中的任何一个进程对该变量做修改操作；会在内存种拷贝一个副本没然后在这个副本上进行修改，修改完成后再映射回去。</p></li></ul></li></ul><h3 id="ps-命令和kill-命令"><a href="#ps-命令和kill-命令" class="headerlink" title="ps 命令和kill 命令"></a>ps 命令和kill 命令</h3><ul><li><code>ps aux | grep &quot;xxx&quot;</code></li><li><code>ps ajx | grep &quot;xxx&quot;</code><ul><li>-a：(all) 当前系统所有用户的进程</li><li>-u：查看进程所有者以及其他信息</li><li>-x：显示没有控制终端的进程 – 不能与用户进行交互的进程 [输入、输出]</li><li>-j：列出与作业控制相关的信息</li></ul></li><li><code>kill -l</code> 查看系统有哪些信号</li><li><code>kill -9 pid</code> 杀死某个线程</li></ul><h3 id="getpid-getppid"><a href="#getpid-getppid" class="headerlink" title="getpid &#x2F; getppid"></a>getpid &#x2F; getppid</h3><ul><li><p>getpid - 得到当前进程的 PID</p><p><code>pid_t getpid();</code></p></li><li><p>getppid - 得到当前进程的父进程的 PID</p><p><code>pid_t getppid();</code></p></li></ul><h2 id="exec-函数族"><a href="#exec-函数族" class="headerlink" title="exec 函数族"></a>exec 函数族</h2><h3 id="函数作用和函数介绍"><a href="#函数作用和函数介绍" class="headerlink" title="函数作用和函数介绍"></a>函数作用和函数介绍</h3><p>有时候需要再一个进程里面执行其他的命令或者是用户自定义的应用程序，此时就用到了 exec 函数族当中的函数。</p><p>使用方法一般都是再父进程里面调用 fork 创建处子进程，然后在子进程里面 调用 exec 函数。</p><h3 id="execl-函数"><a href="#execl-函数" class="headerlink" title="execl 函数"></a>execl 函数</h3><ul><li>函数原型：<code>int execl(const char *pathname, const char *arg, .../* (char  *) NULL */);</code></li><li>参数介绍：<ul><li>path：要执行的程序的绝对路径</li><li>变参 arg：要执行的程序的需要的参数</li><li>arg：占位，通常写应用程序的名字</li><li>arg 后面的：命令的额参数</li><li>参数写完之后：NULL</li></ul></li><li>返回值：<ul><li>若是成功，则不反悔，不会再执行 exec 函数后面的代码；</li><li>若是失败：会执行 execl 后面的代码，可以用 perror 打印错误原因。</li></ul></li></ul><p>execl 函数一般执行自己写的程序。</p><h3 id="execlp-函数"><a href="#execlp-函数" class="headerlink" title="execlp 函数"></a>execlp 函数</h3><ul><li>函数原型：<code>int execlp(const char *file, const char *arg, .../* (char  *) NULL */);</code></li><li>参数介绍：<ul><li>file：执行命令的名字，根据 PATH 环境变量来搜索该命令</li><li>arg：占位</li><li>arg 后面的：命令参数</li><li>参数写完之后：NULL</li></ul></li><li>返回值：<ul><li>若是成功，则不反悔，不会再执行 exec 函数后面的代码；</li><li>若是失败：会执行 execl 后面的代码，可以用 perror 打印错误原因。</li></ul></li></ul><p>execlp 函数一般是执行系统自带的程序或者命令。</p><h3 id="exec-函数族原理介绍"><a href="#exec-函数族原理介绍" class="headerlink" title="exec 函数族原理介绍"></a>exec 函数族原理介绍</h3><p>exec 族函数的实现原理图：</p><p>如：<code>execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL);</code></p><p><img src="/2025/03/25/process-control/image10.png"></p><p>总结：<br><br>exec 函数是用一个新程序替换了当前进程的代码段、数据段、堆和栈；原有的进程空间没有发生变化，并没有创建新的进程，进程的 PID 没有发生变化。</p><p>注意：当 execl 和 execlp 函数执行成功后，不返回，并且不会执行 execl 后面的代码逻辑，原因是调用 execl 函数成功以后，exec 函数指定的代码段已经将原有的代码段替换了。</p><h2 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h2><h3 id="为什么要进行进程资源回收"><a href="#为什么要进行进程资源回收" class="headerlink" title="为什么要进行进程资源回收"></a>为什么要进行进程资源回收</h3><p>当一个进程推出之后，进程能够回收自己的用户区资源，但是不能回收内核空间的 PCB 资源，必须由它的父进程调用 wait 或者 waitpid 函数完成对子进程的回收，避免造成系统资源的浪费。</p><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><ul><li>孤儿进程的额概念：<br>若子进程的父进程已经死掉，而子进程还存活者，这个进程就成了孤儿进程。</li><li>为了保证每个进程都有一个父进程，孤儿进程会被 init 进程领养，init 进程成为了孤儿进程的养父进程，当孤儿进程退出之后，由 init 进程完成对孤儿进程的回收。</li></ul><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><ul><li>僵尸进程的概念：<br> 若子进程死了，父进程还活着，但是父进程没有调用 wait 或 waitpid函数完成对子进程的回收，则该子进程就成了僵尸进程。</li><li>如何解决僵尸进程：<ul><li>由于僵尸进程是一个已经死亡的进程，所以不能使用 kill 命令将其杀死</li><li>通过杀死其父进程的方法可以消除僵尸进程。<br>杀死其父进程后，这个僵尸进程会被 init 进程领养，由 init 进程完成对僵尸进程的回收</li></ul></li></ul><h3 id="进程回收函数"><a href="#进程回收函数" class="headerlink" title="进程回收函数"></a>进程回收函数</h3><h4 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait 函数"></a>wait 函数</h4><ul><li>函数原型：<code>pid_t wait(int* status);</code></li><li>函数作用：<ul><li>阻塞并等待子进程退出</li><li>回收子进程残留资源</li><li>获取子进程结束状态 (退出原因)</li></ul></li><li>返回值：<ul><li>成功：清理掉的子进程 ID</li><li>失败：-1 (没有子进程)</li></ul></li><li>status 参数：子进程的退出状态 – 传出参数<ul><li>WIFEXITED(status)：为非 0  -&gt; 进程正常结束 <br> WEXITSTATUS(status)：获取进程退出状态</li><li>WIFSIGNALED(status)：为非 0  -&gt; 进程异常终止 <br> WTERMSIG(status)：取得进程终止的信号编号</li></ul></li></ul><h4 id="waitpid-函数"><a href="#waitpid-函数" class="headerlink" title="waitpid 函数"></a>waitpid 函数</h4><ul><li>函数原型：<code>pid_t waitpid(pid_t pid, int *wstatus, int options);</code></li><li>函数作用：同 wait 函数</li><li>函数参数：<ul><li>pid：<ul><li>pid &#x3D; -1 等待任一子进程。与 wait 等效。</li><li>pid &gt; 0 等到其进程 ID 与 pid 相等的子进程</li><li>pid &#x3D; 0 等待进程组 ID 与目前进程相同的任何子进程，也就是说任何和调用 waitpid 函数的进程在同一个进程组的进程。</li><li>pid &lt; -1 等待其组 ID 等于 pid 的绝对值的任一子进程。(适用于子进程在其他组的情况)</li></ul></li><li>status：子进程的退出装，用法同 wait 函数</li><li>options：设置为 WNOHANG，函数非阻塞，设置为 0，函数阻塞。</li></ul></li><li>函数返回值：<ul><li>&gt;0：返回回收掉的子进程 ID；</li><li>-1：无子进程</li><li>&#x3D;0：参 3 为 WNOHANG，且子进程正在运行。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件IO</title>
    <link href="/2025/03/21/file-io/"/>
    <url>/2025/03/21/file-io/</url>
    
    <content type="html"><![CDATA[<h1 id="文件-IO"><a href="#文件-IO" class="headerlink" title="文件 IO"></a>文件 IO</h1><h2 id="C-库-IO-函数的工作流程"><a href="#C-库-IO-函数的工作流程" class="headerlink" title="C 库 IO 函数的工作流程"></a>C 库 IO 函数的工作流程</h2><p><img src="/2025/03/21/file-io/c_library_io_function_workflow1.png"></p><p><img src="/2025/03/21/file-io/c_library_io_function_workflow2.png"></p><p>c 语言操作文件相关问题：</p><p>使用 fopen 函数打开一个文件，返回一个 FILE* fp，这个指针指向的结构体有三个重要的成员。</p><ul><li>文件描述符：通过文件描述符可以找到文件的 inode，通过 inode 可以找到对应的数据块</li><li>文件指针：读和写共享一个文件指针，读或者写都会引起文件指针的变化。</li><li>文件缓冲区：读或者写会先通过文件缓冲区，主要目的是为了减少对磁盘的读写次数，提高读写磁盘的效率。</li></ul><p>备注：</p><ul><li>头文件 stdio.h 的第 48 行处：<code>typedef struct_IO_FILE FILE</code>;</li><li>头文件 libio.h 的第 241 行处：<code>struct_IO_FILE</code>，这个接头文件定义中有一个 <code>_fileno_</code>成员，这个就是文件描述符。</li></ul><h2 id="C-库函数与系统函数的关系"><a href="#C-库函数与系统函数的关系" class="headerlink" title="C 库函数与系统函数的关系"></a>C 库函数与系统函数的关系</h2><p><img src="/2025/03/21/file-io/c_function_with_system_function.png"></p><p>系统调用：由操作系统实现并提供给外部应用程序的编程接口，(Application Programming Interfact, API)，是应用程序与系统之间数据交互的桥梁。</p><h2 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h2><p><img src="/2025/03/21/file-io/virtual_address.png"></p><p>进程的虚拟地址空间分为用户区和内核区，其中内核区是受保护的，用户是不能够对其进行读写操作的。</p><p>内核区中很重要的一个就是进程管理，进程管理中有一个区域就是 PCB(本质是一个结构体)。</p><p>PCB 中有文件描述符表，文件描述符表中存放着打开的文件描述符，涉及到文件的 IO 操作都会用到这个文件描述符。</p><h2 id="PCB-和文件描述符表"><a href="#PCB-和文件描述符表" class="headerlink" title="PCB 和文件描述符表"></a>PCB 和文件描述符表</h2><p><img src="/2025/03/21/file-io/pdb_and_file_descriptor_table.png"></p><p>备注：</p><p>pcb：结构体：<code>task_struct</code>，该结构体在：<code>/usr/src/linux-headers-4.4.0-97/include/linux/sched.h:1390</code></p><p>一个进程有一个文件描述符表：1024</p><ul><li>前三个被占用，分别是<code>STDIN_FILENO</code>，<code>STDOUT_FILENO</code>，<code>STDERR_FILENO</code></li><li>文件描述符作用：通过文件描述符找到 inode，通过 inode 找到磁盘数据块</li></ul><p>虚拟地址空间 -&gt; 内核区 -&gt; PCB -&gt; 文件描述符表 -&gt; 文件描述符 -&gt; 文件 IO 操作使用文件描述符</p><h2 id="open-close"><a href="#open-close" class="headerlink" title="open&#x2F;close"></a>open&#x2F;close</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>一个进程启动之后，默认打开三个文件描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STDIO_FILENO    0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STDOUT_FILENO   1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STDERR_FILENO   2</span><br></code></pre></td></tr></table></figure><p>新打开文件返回文件描述符中未使用的最小文件描述符，调用 open 函数可以打开或创建一个问及那，得到一个文件描述符。</p><h3 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a>open 函数</h3><ul><li>函数描述：打开或者新建一个文件</li><li>函数原型：<ul><li><code>int open(const char* pathname, int flags);</code></li><li><code>int open(const char* pathname, int flags, mode_t mode);</code></li></ul></li><li>函数参数：<ul><li>pathname 参数是要开打或创建的文件名，和 fopen 一样，pathname 既可以是相对路劲也可以是绝对路径</li><li>flags 参数有一系列常数值可供选择，可以同时选择多个常熟用按位或运算连接起来，所以这些常熟的共定义都已 O_ 开头，表示 or。<ul><li>必选项：以下三个常数中必须指定一个，且仅允许指定一个。<ul><li><code>O_RDONLY</code> 只读打开</li><li><code>O_WROBLY</code> 只写打开</li><li><code>O_RDWR</code> 可读可写打开</li></ul></li><li>以下可选项可以同时指定 0 个或多个，和必选项按位或起来作为 flags 参数。以下为常用项：<ul><li><code>O_APPEND</code> 表示追加。如果文件已有内容，这次打开文件所写的数据附加到文件的末尾而不是覆盖原来的内容。</li><li><code>O_CERAT</code> 若此文件不存在则创建它。使用此选项时需要提供第三个参数 mode，表示该文件的访问权限。<ul><li>文件最终权限：<code>mode&amp;~umask</code></li></ul></li><li><code>O_EXCL</code> 如果同时指定了 O_CREAT，并且文件已存在，则出错返回</li><li><code>O_TRUNC</code> 如果文件已存在，将其长度截断为 0 字节</li><li><code>O_NONBLOCK</code> 对于设备文件，以 O_NONBLOCK 方式打开可以做非阻塞 I&#x2F;O(Nonblock I&#x2F;O)</li></ul></li></ul></li></ul></li><li>函数返回值：<ul><li>成功：返回一个最小且未被占用的文件描述符</li><li>失败：返回 -1，并设置 errno 值</li></ul></li></ul><h3 id="close-函数"><a href="#close-函数" class="headerlink" title="close 函数"></a>close 函数</h3><ul><li>函数描述：关闭文件</li><li>函数原型：<code>int close(int fd);</code></li><li>函数参数：fd 文件描述符</li><li>函数返回值：<ul><li>成功返回 0</li><li>失败返回 -1，并设置 errno 值</li></ul></li></ul><p>需要说明的是，当一个进程终止时，内核对该进程所有尚未关闭的文件描述符调用 close 关闭，所以即使用户程序不调用 close，在终止时也会自动关闭它打开的所有文件。但是对于一个长年累月云心过的程序（比如网络服务器），打开的文件描述符一定要记得关闭，否则随着打开的文件越来越多，会占用大量文件描述符和系统资源。</p><h2 id="read-write"><a href="#read-write" class="headerlink" title="read&#x2F;write"></a>read&#x2F;write</h2><h3 id="read-函数"><a href="#read-函数" class="headerlink" title="read 函数"></a>read 函数</h3><ul><li>函数描述：从打开的设备或文件中读取数据</li><li>函数原型：<code>ssize_t read(int fd, void *buf, size_t count);</code></li><li>函数参数：<ul><li>fd：文件描述符</li><li>buf：读上来的数据保存在缓冲区 buf 中</li><li>count：buf 缓冲区存放的最大字节数</li></ul></li><li>函数返回值<ul><li>&gt;0：读取到的字节数</li><li>&#x3D;0：文件读取完毕</li><li>-1：出错，并设置 errno</li></ul></li></ul><h3 id="write-函数"><a href="#write-函数" class="headerlink" title="write 函数"></a>write 函数</h3><ul><li>函数描述：向打开的设备或文件中写数据</li><li>函数原型：<code> ssize_t write(int fd, const void *buf, size_t count);</code></li><li>函数参数：<ul><li>fd：文件描述符</li><li>buf：缓冲区，要写入文件或设备的数据</li><li>count：buf 中数据的长度</li></ul></li><li>函数返回值：<ul><li>成功：返回写入的字节数</li><li>错误：返回 -1 并设置 errno</li></ul></li></ul><h2 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h2><p>所有打开的文件都有一个当前文件偏移量(current file offset)，一下简称为 cfo。cfo通常是一个非负整数，用于表明文件开始处到文件当前位置的字节数。读写操作通常开始于 cfo，并且使 cfo 增大，增量为读写的字节数，文件被打开时，cfo 会被初始化为 0，除非使用了 O_APPEND。</p><p>使用 lseek 函数可以改变文件的 cfo。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">off_t</span> <span class="hljs-title function_">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset, <span class="hljs-type">int</span> whence)</span>;<br></code></pre></td></tr></table></figure><ul><li>函数描述：移动文件指针</li><li>函数原型：<code>off_t lseek(int fd, off_t offset, int whence);</code></li><li>函数参数：<ul><li>fd：文件描述符</li><li>参数 offset的含义取决于参数 whence<ul><li>如果 whence 是 SEEK_SET，文件偏移量将设置为 offset</li><li>如果 whence 是 SEEK_CUR，文件偏移量将被设置为 cfo 加上 offset，offset 可以为正也可以为负</li><li>如果 whence 是 SEEK_END，文件偏移量将被设置为文件长度加上 offset，offset 可以为正也可以为负</li></ul></li></ul></li><li>函数返回值：若 lseek 成功执行，则返回新的偏移量</li><li>lseek 函数常用操作：<ul><li>文件指针移动到头部：<code>lseek(fd, 0, SEEK_SET)</code></li><li>获取文件指针当前位置：<code>int len = lseek(fd, 0, SEEK_CUR)</code></li><li>获取文件长度：<code>int len = lseek(fd, 0, SEEK_END)</code></li><li>lseek 实现文件拓展：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 从文件尾部开始向后拓展 1000 个字节</span><br><span class="hljs-type">off_t</span> curpos = lseek(fd, <span class="hljs-number">1000</span>, SEEK_END);<br><span class="hljs-comment">// 额外执行一次写操作，否则文件无法完成拓展</span><br>write(fd, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="perror-和-errno"><a href="#perror-和-errno" class="headerlink" title="perror 和 errno"></a>perror 和 errno</h2><p>errno 是一个全局变量，当系统调用后出错将会将 errno 进行设置，perror 可以将 errno 对应的描述信息打印出来。</p><p>如：<code>perror(&quot;open&quot;)</code>；如果报错的话打印：open：错误信息</p><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><ul><li>普通文件：hello.c<ul><li>默认是非阻塞的</li></ul></li><li>终端设备：如 &#x2F;dev&#x2F;tty<ul><li>默认阻塞</li></ul></li><li>管道和套接字<ul><li>默认阻塞</li></ul></li></ul><h2 id="文件操作相关函数"><a href="#文件操作相关函数" class="headerlink" title="文件操作相关函数"></a>文件操作相关函数</h2><h3 id="stat-lstate-函数"><a href="#stat-lstate-函数" class="headerlink" title="stat&#x2F;lstate 函数"></a>stat&#x2F;lstate 函数</h3><ul><li>函数描述：获取文件属性</li><li>函数原型：<code>int stat(const char* pathname, struct stat* buf);</code><br><code>int lstat(const char* pathname, struct stat* buf);</code></li><li>函数返回值：<ul><li>成功返回 0</li><li>失败返回 -1</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> &#123;</span><br>  <span class="hljs-type">dev_t</span>     st_dev;       <span class="hljs-comment">// 文件的谁被编号</span><br>  <span class="hljs-type">ino_t</span>     st_ino;       <span class="hljs-comment">// 节点</span><br>  <span class="hljs-type">mode_t</span>    st_mode;      <span class="hljs-comment">// 文件的类型和存取权限</span><br>  <span class="hljs-type">nlink_t</span>   st_nlink;     <span class="hljs-comment">// 连到该文件的硬链接数目，刚建立的文件值为 1</span><br>  <span class="hljs-type">uid_t</span>     st_uid;       <span class="hljs-comment">// 用户 ID</span><br>  <span class="hljs-type">gid_t</span>     st_gid;       <span class="hljs-comment">// 组 ID</span><br>  <span class="hljs-type">dev_t</span>     st_rdev       <span class="hljs-comment">// (设备类型)若此文件为设备文件，则为设备编号</span><br>  <span class="hljs-type">off_t</span>     st_size       <span class="hljs-comment">// 文件字节数(文件大小)</span><br>  <span class="hljs-type">blksize_t</span> st_blksize;   <span class="hljs-comment">// 块大小(文件系统的 I/O 缓冲区大小)</span><br>  <span class="hljs-type">blkcnt_t</span>  st_blocks;    <span class="hljs-comment">// 块数</span><br>  <span class="hljs-type">time_t</span>    st_atime;     <span class="hljs-comment">// 最后一次访问时间</span><br>  <span class="hljs-type">time_t</span>    st_mtine;     <span class="hljs-comment">// 最后一次修改时间</span><br>  <span class="hljs-type">time_t</span>    st_ctime;     <span class="hljs-comment">// 最后一次改变时间(指属性)</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>st_mode</code> – 16 位整数<ul><li><p>0 - 2 bit – 其他人权限</p><ul><li><code>S_IROTH</code> 00004 读权限</li><li><code>S_IWOTH</code> 00002 写权限</li><li><code>S_IXOTH</code> 00001 执行权限</li><li><code>S_IRWXO</code> 00007 掩码，过滤 st_mode 中除其他人权限以外的信息</li></ul></li><li><p>3 - 5 bit – 所属组权限</p><ul><li><code>S_IRGRP</code> 00004 读权限</li><li><code>S_IWGRP</code> 00002 写权限</li><li><code>S_IXGRP</code> 00001 执行权限</li><li><code>S_IRWXG</code> 00007 掩码，过滤 st_mode 中除其他人权限以外的信息</li></ul></li><li><p>6 - 8 bit – 文件所有者权限</p><ul><li><code>S_IRUSR</code> 00004 读权限</li><li><code>S_IWUSR</code> 00002 写权限</li><li><code>S_IXUSR</code> 00001 执行权限</li><li><code>S_IRWXU</code> 00007 掩码，过滤 st_mode 中除其他人权限以外的信息</li><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (st_mode &amp; S_IRUSR) ---- 为真表明可读<br><span class="hljs-keyword">if</span> (st_mode &amp; S_IWUSR) ---- 为真表明可写<br><span class="hljs-keyword">if</span> (st_mode &amp; S_IXUSR) ---- 为真表明可执行<br></code></pre></td></tr></table></figure></li></ul></li><li><p>12 - 15 bit – 文件类型</p><ul><li>S_IFSOCK    0140000 套接字</li><li>S_IFLNK     0120000 符号链接(软链接)</li><li>S_IFREG     0100000 普通文件</li><li>S_IFBLK     0060000 块设备</li><li>S_IFDIR     0040000 目录</li><li>S_IFCHR     0020000 字符设备</li><li>S_IFIFO     0010000 管道</li><li>S_IFMT      0170000 掩码，过滤 st_mode 中除文件类以外的信息</li><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((st_mode &amp; S_IFMT) == S_IFREG) -- 为真普通文件<br><span class="hljs-keyword">if</span> (S_ISREG(st_mode)) ---- 为真表示普通文件<br><span class="hljs-keyword">if</span> (S_ISDIR(st_mode)) ---- 为真表示目录文件<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>stat 函数 和 lstat 函数的区别：</p><ul><li>对于普通文件，这两个函数没有区别，是一样的。</li><li>而对于链接文件，调用 lstat 函数获取的是链接文本本身的属性信息；而 stat 函数获取的是链接文件指向的文件的属性信息。</li></ul><h2 id="目录操作相关函数"><a href="#目录操作相关函数" class="headerlink" title="目录操作相关函数"></a>目录操作相关函数</h2><h3 id="opendir-函数"><a href="#opendir-函数" class="headerlink" title="opendir 函数"></a>opendir 函数</h3><ul><li>函数描述：打开一个目录</li><li>函数原型：<code>DIR* opendir(const char* name);</code></li><li>函数返回值：指向目录的指针</li><li>函数参数：要便利的目录(相对路径或者绝对路径)</li></ul><h3 id="readdir-函数"><a href="#readdir-函数" class="headerlink" title="readdir 函数"></a>readdir 函数</h3><ul><li>函数描述：读取目录内容 – 目录项</li><li>函数原型：<code>struct dirent* readdir(DIR* dirp);</code></li><li>函数返回值：读取的目录项指针</li><li>函数参数：opendir 函数的返回值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> &#123;</span><br>  <span class="hljs-type">ino_t</span>             d_ino;        <span class="hljs-comment">// 此目录进入点的 inode</span><br>  <span class="hljs-type">off_t</span>             d_off;        <span class="hljs-comment">// 目录文件开头至此目录进入点的位移</span><br>  <span class="hljs-type">signed</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span>  d_reclen;     <span class="hljs-comment">// d_name 的长度，不包含 NULL 字符</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>     d_type;       <span class="hljs-comment">// d_name 所指的文件类型</span><br>  <span class="hljs-type">char</span>              d_name[<span class="hljs-number">256</span>];  <span class="hljs-comment">// 文件名</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>d_type 的取值：</p><ul><li>DT_BLK - 块设备</li><li>DT_CHR - 字符设备</li><li>DT_DIR - 目录</li><li>DT_LNK - 软链接</li><li>DT_FIFO - 管道</li><li>DT_REG - 普通文件</li><li>DT_SOCK - 套接字</li><li>DT_UNKNOWN - 未知</li></ul><p><img src="/2025/03/21/file-io/directory.png"></p><h3 id="closedir-函数"><a href="#closedir-函数" class="headerlink" title="closedir 函数"></a>closedir 函数</h3><ul><li>函数描述：关闭目录</li><li>函数原型：<code>int closedir(DIR* dirp);</code></li><li>函数返回值：成功返回 0，失败返回 -1</li><li>函数参数：opendir 函数的返回值</li></ul><h3 id="读取目录内容过的一般步骤"><a href="#读取目录内容过的一般步骤" class="headerlink" title="读取目录内容过的一般步骤"></a>读取目录内容过的一般步骤</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">DIR* pDir = opendir(<span class="hljs-string">&quot;dir&quot;</span>) <span class="hljs-comment">// 1. 打开目录</span><br><span class="hljs-keyword">while</span> ((p == readdir(pDir)) != <span class="hljs-literal">NULL</span>) &#123;&#125; <span class="hljs-comment">// 2. 循环读取文件</span><br>closedir(pDir) <span class="hljs-comment">// 3. 关闭目录</span><br></code></pre></td></tr></table></figure><h2 id="dup-dup2-fcntl"><a href="#dup-dup2-fcntl" class="headerlink" title="dup &#x2F; dup2 &#x2F; fcntl"></a>dup &#x2F; dup2 &#x2F; fcntl</h2><p><img src="/2025/03/21/file-io/dup_dup2.png"></p><h3 id="dup-函数"><a href="#dup-函数" class="headerlink" title="dup 函数"></a>dup 函数</h3><ul><li>函数描述：复制文件描述符</li><li>函数原型：<code>int dup(int oldfd);</code></li><li>函数参数：oldfd - 要复制的文件描述符</li><li>函数返回值<ul><li>成功：返回最小且没被占用的文件描述符</li><li>失败：返回 -1，设置 errno 值</li></ul></li></ul><h3 id="dup2-函数"><a href="#dup2-函数" class="headerlink" title="dup2 函数"></a>dup2 函数</h3><ul><li>函数描述：复制文件描述符</li><li>函数原型：<code>int dup2(int oldfd, int newfd);</code></li><li>函数参数：<ul><li>oldfd - 原来的文件描述符</li><li>newfd - 复制成功的新的文件描述符</li></ul></li><li>函数返回值：<ul><li>成功：将 oldfd 复制给 newfd，两个文件描述符指向同一个文件</li><li>失败：返回 -1，设置 errno 值</li></ul></li><li>假设 newfd 已经指向了一个文件，首先 close 原来打开的文件，然后 newfd 指向 oldfd 指向的文件。<br>若 newfd 没有被占用，newfd 指向 oldfd 指向的文件</li></ul><p><img src="/2025/03/21/file-io/dup_dup2_function_principal.png"></p><h3 id="fcntl-函数"><a href="#fcntl-函数" class="headerlink" title="fcntl 函数"></a>fcntl 函数</h3><ul><li>函数描述：改变已经打开的文件的属性</li><li>函数原型：<code>int fcntl(int fd, int cmd, ... /* arg */ );</code><ul><li>若 cmd 为 F_DUPFD，复制文件描述符，与 dup 相同</li><li>若 cmd 为 F_GETFL，获取文件描述符的 flag 属性值</li><li>若 cmd 为 F_SETFL，设置文件描述符的 flag 属性</li></ul></li><li>函数返回值：返回值取决于 cmd<ul><li>成功：<ul><li>若 cmd 为 F_DUPFD，返回一个新的文件描述符</li><li>若 cmd 为 F_GETFL，返回文件描述的 flags 值</li><li>若 cmd 为 F_SETFL，返回 0</li></ul></li><li>失败返回 -1，并设置 errno 值</li></ul></li><li>fcntl 函数常用的操作：<ol><li>复制一个新的文件描述符 <br> <code>int newfd = fcntl(fd, F_DUPFD, 0);</code> </li><li>获取文件的属性标志 <br> <code>int flag = fcntl(fd, F_GETFL, 0);</code></li><li>设置文件状态标志 <br> <code>flag = flag | O_APPEND;</code> <br> <code>fcntl(fd, F_SETFL, flag);</code></li><li>常用的属性标志：<ul><li>O_APPEND —- 设置文件打开为末尾添加</li><li>O_NONBLOCK —- 设置打开的文件描述符为非阻塞</li></ul></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gdb调试</title>
    <link href="/2025/03/07/gdb-debug/"/>
    <url>/2025/03/07/gdb-debug/</url>
    
    <content type="html"><![CDATA[<h1 id="gdb-调试"><a href="#gdb-调试" class="headerlink" title="gdb 调试"></a>gdb 调试</h1><h2 id="gdb-介绍"><a href="#gdb-介绍" class="headerlink" title="gdb 介绍"></a>gdb 介绍</h2><p>GBD (DBU Debugger) 是 GCC 的调试工具。其功能强大，现描述如下：</p><p>GDB 主要帮忙你完成下面四个方面的功能：</p><ul><li>启动程序，可以按照你的自定义的要求随心所欲的运行程序。</li><li>可让被调试的程序在你所指的断点处听出。(断点可以是条件表达式)</li><li>当程序被停住时，可以检查此时你的程序中所发生的事。</li><li>动态的改变你程序的执行环境。</li></ul><h2 id="生成调试信息"><a href="#生成调试信息" class="headerlink" title="生成调试信息"></a>生成调试信息</h2><p>一般来说 GDB 主要调试的是 C&#x2F;C++ 的程序。要调试 C&#x2F;C++ 的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器 (cc&#x2F;gcc&#x2F;g++) 的 -g 参数可以做到这一点。如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -<span class="hljs-selector-tag">g</span> hello<span class="hljs-selector-class">.c</span> -o hello<br></code></pre></td></tr></table></figure><p>如果没有 -g，你将看不到程序的函数名、变量名，所代替的全是运行时的内存地址。当你用 -g 把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用 gbd 调试它。</p><h2 id="启动-gdb"><a href="#启动-gdb" class="headerlink" title="启动 gdb"></a>启动 gdb</h2><ul><li><p>启动 gdb：<code>gdb program</code></p><ul><li>program 也就是你的大执行文件，一般在当前目录下。</li></ul></li><li><p>设置运行参数</p><ul><li><code>set args</code> 可以指定运行时参数。(如：set args 10 20 30 40 50)</li><li><code>show args</code> 命令可以查看设置好的运行参数</li></ul></li><li><p>启动程序</p><ul><li><code>run</code>：程序开始执行，如果有断电，停在第一个断点处</li><li><code>start</code>：程序向下执行一行。(在第一条语句处停止)</li></ul></li></ul><h2 id="显示源代码"><a href="#显示源代码" class="headerlink" title="显示源代码"></a>显示源代码</h2><p>GBD 可以打印出所调试程序的源代码，当然，在程序编译时一定要加上 -g 参数，把源程序信息编译到执行文件中华。不然就看不到源程序了。当程序停下来后，GDB 会报告程序停在了哪个文件的第几行上。你可以用 list 命令来打印程序的源代码，默认打印 10 行，list命令的用法如下所示：</p><ul><li><code>list linenum</code>：打印第 linenum 行的上下文内容</li><li><code>list function</code>：显示函数名为 function 的函数的源程序</li><li><code>list</code>：显示当前行后面的源程序</li><li><code>list -</code>：显示当前文件开始处的源程序</li><li><code>list file:linenum</code>：显示 file 文件下第 linenum 行</li><li><code>list file:function</code>：显示 file 文件的函数名为 function 的函数的源程序</li></ul><p>一般时打印当前行上 5 行和下 5 行，如果显示函数时上 2 行下 8 行，默认是 10 行，当然，你也可以定制显示范围，使用下面命令可以设置一次显示源程序的行数。</p><ul><li><code>set listsize count</code>：设置一次显示源代码的行数</li><li><code>show listsize</code>：查看当前 listsize 的设置</li></ul><h2 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h2><h3 id="简单断点-–-当前文件"><a href="#简单断点-–-当前文件" class="headerlink" title="简单断点 – 当前文件"></a>简单断点 – 当前文件</h3><ul><li>break 设置断点，可以简写为 b<ul><li><code>b 10</code>设置断点，在源程序第 10 行</li><li><code>b func</code>设置断点，在 func 函数入口处</li></ul></li></ul><h3 id="多文件设置断点-–-其他文件"><a href="#多文件设置断点-–-其他文件" class="headerlink" title="多文件设置断点 – 其他文件"></a>多文件设置断点 – 其他文件</h3><ul><li><p>在进入指定函数时停住：</p><ul><li><code>b filename:linenum</code> – 在源文件 filename 的 linenum 行处停住</li><li><code>b filename:function</code> – 在源文件 filename 的 function 函数的入口处停住</li></ul></li><li><p>查询所有断点</p><ul><li><code>info b == info break == i break == i b</code></li></ul></li><li><p>条件断点</p><p>  一般来说，为断点设置一个条件，我们使用 if 关键字，后面跟其断点条件。设置一个条件断点：</p><ul><li><code>b test.c:8 if intValue == 5</code></li></ul></li><li><p>维护断点</p><ul><li><p><code>delete [range...]</code>删除指定的断点，其简写命令为 d。</p><ul><li>如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围<ul><li>删除某个断点：<code>delete num</code></li><li>删除多个断点：<code>delete num1 num2</code></li><li>删除连续多个断点：<code>delete m-n</code></li><li>删除所有断点：<code>delete</code></li></ul></li><li>比删除更高的一种方法是 disable 停止点，disable 了的停止点，GDB 不会删除，当你还需要时，enable 即可，就好像回收站一样。</li></ul></li><li><p><code>disable/enable [range...]</code> 使指定断点无效，简写命令使 dis&#x2F;ena。</p><p>如果什么都不指定，表示 diable 所有的停止点。</p><ul><li>使一个断点无效&#x2F;有效：<code>disable/enable num</code></li><li>使多个断点无效&#x2F;有效：<code>disable/enable num1 num2</code></li><li>使多个连续的断点无效&#x2F;有效：<code>disbale/enable m-n</code></li><li>使所有断点无效&#x2F;有效:<code>disable/enable</code></li></ul></li></ul></li></ul><h2 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h2><ul><li><code>run</code> 运行程序，可简写为 r</li><li><code>next</code> 单步跟踪，函数调用当作一条简单执行语句执行，可简写为 n</li><li><code>step</code> 单步跟踪，函数调用会进入被调用函数体内，可简写为 s</li><li><code>finish</code> 退出进入的函数，如果出不去，看一下函数体中的循环中是否由断点，如果有删掉，或者设置无效。</li><li><code>until</code> 在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体，可简写为 u，如果出不去，看一下函数体中的循环中是否由断点，如果有删掉，或者设置无效。</li><li><code>continue</code> 继续运行程序，可简写为 c (若有断点，则跳到下一个断点处)</li></ul><h2 id="查看变量的值"><a href="#查看变量的值" class="headerlink" title="查看变量的值"></a>查看变量的值</h2><h3 id="查看运行时变量的值"><a href="#查看运行时变量的值" class="headerlink" title="查看运行时变量的值"></a>查看运行时变量的值</h3><p>print 打印变量、字符串、表达式等的值，可简写为 p</p><ul><li><code>p count</code> —- 打印 count 的值</li></ul><h3 id="自动显示变量的值"><a href="#自动显示变量的值" class="headerlink" title="自动显示变量的值"></a>自动显示变量的值</h3><p>你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的 GDB 命令时 display。</p><ul><li><code>display 变量名</code></li><li><code>info display</code> – 查看 display 设置的自动显示的信息。</li><li><code>undisplay num</code> (info display 时显示的编号)</li><li><code>delete display dnums...</code> – 删除自动显示，dnums 意为所设置好了的自动显示的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示<ul><li>删除某个自动显示：<code>undisplay num</code> 或者 &#96;&#96;delete display num&#96;</li><li>删除多个: <code>delete display num1 num2</code></li><li>删除一个范围：<code>delete display m-n</code></li></ul></li><li><code>disable/enable display dnums</code><ul><li>使一个自动显示无效&#x2F;有效：<code>disable/enable display num</code></li><li>使多个自动显示无效&#x2F;有效: <code>disable/enable display num1 num2</code></li><li>使一个范围的自动显示无效&#x2F;有效：<code>disable/enable display m-n</code></li></ul></li></ul><h3 id="查看修改变量的值"><a href="#查看修改变量的值" class="headerlink" title="查看修改变量的值"></a>查看修改变量的值</h3><ul><li><code>ptype width</code> – 查看变量 width 的类型<ul><li><code>type == double</code></li></ul></li><li><code>p width</code> – 打印变量 width 的值<ul><li><code>$4 = 13</code></li></ul></li><li>你可以使用 <code>set var</code> 命令来告诉 GDB，width 不是你 GDB 的参数，而是程序的变量名，如：<ul><li><code>set var width = 47</code> – 将变量 var 的值设置为 47</li></ul></li><li>在你改变程序变量取值时，最好都是用 set var 格式的 GDB 命令</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>gcc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>makefile</title>
    <link href="/2025/03/06/makefile/"/>
    <url>/2025/03/06/makefile/</url>
    
    <content type="html"><![CDATA[<h1 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h1><p>makefile 文件中定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile 就像一个 shell 脚本一样，其中也可以执行操作系统的命令。makefile 带来的好处就是 — “自动化编译”，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p><p>make 是一个命令工具，是一个解释 makefile 中指令的命令工具，一般来说，大多数的 IDE 都有这个命令，比如：Visual C++ 的 nmake，Linux 下的 make。可见，makefile 都成为了一种在工程方面的编译方法。</p><p>makefile 文件中会使用 gcc 编译器对源代码进行编译，最终生成可执行文件或者库文件。</p><p>makefile 文件的命名：makefile 或者 Makefile</p><h2 id="makefile-的基本规则"><a href="#makefile-的基本规则" class="headerlink" title="makefile 的基本规则"></a>makefile 的基本规则</h2><p>makefile 由一组规则组成，规则如下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">目标：依赖<br>(<span class="hljs-literal">Tab</span>) 命令<br></code></pre></td></tr></table></figure><p>makefile 基本规则三要素：</p><ul><li>目标：要生成的目标文件</li><li>依赖：目标文件由哪些文件生成</li><li>命令：通过执行该命令由依赖文件生成目标</li></ul><p>下面以具体的例子讲解：</p><p>当前目录下由 main.c fun1.c fun2.c sum.c，根据这个基本规则编写一个简单的 makefile文件，生成可执行文件 main。</p><p>第一个版本的 makefile 文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">main: main.c fun1.c fun2.c sum.c</span><br>gcc -o main main.c fun1.c fun2.c sum.cls <br></code></pre></td></tr></table></figure><p>缺点：效率低，修改一个文件，所有的文件会全部重新编译。</p><h2 id="makfile-工作原理"><a href="#makfile-工作原理" class="headerlink" title="makfile 工作原理"></a>makfile 工作原理</h2><h3 id="基本原则："><a href="#基本原则：" class="headerlink" title="基本原则："></a>基本原则：</h3><p><strong>若想生成目标，检查规则中的所有的依赖文件是否都存在：</strong></p><ul><li><p>如果有的依赖文件不存在，则向下搜索规则，看是否由生成该依赖文件的规则：</p><p>  如果有规则用来生成该依赖文件，则执行规则中的命令生成依赖文件；如果没有规则用来生成该依赖文件，则报错。<br>  <img src="/2025/03/06/makefile/makefile1.png"></p></li><li><p>如果所有依赖都存在，检查规则中的目标是否需要更新，必须先检查它的所有依赖，依赖中有任何一个被更新，则目标必须更新。(检查的规则是哪个时间大，哪个最新)</p><ul><li><p>若目标的时间 &gt; 依赖的时间，不更新</p></li><li><p>若目标的时间 &lt; 依赖的时间，更新</p><p><img src="/2025/03/06/makefile/makefile2.png"></p></li></ul></li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li>分析各个目标和依赖之间的关系</li><li>根据依赖关系自底向上执行命令</li><li>根据依赖文件得到时间和目标文件的时间确定是否需要更新</li><li>如果目标不依赖任何条件，则执行对应命令，以示更新(如：伪目标)</li></ul><p>第二个版本：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">main: main.o fun1.o fun2.o sum.o</span><br>gcc -o main main.o fun1.o fun2.o sum.o<br><br><span class="hljs-section">main.o: main.c</span><br>gcc -c main.c -I./<br><br><span class="hljs-section">fun1.o: fun1.c</span><br>gcc -c fun1.c<br><br><span class="hljs-section">fun2.o: fun2.c</span><br>gcc -c fun2.c<br><br><span class="hljs-section">sum.o: sum.c</span><br>gcc -c sum.c<br></code></pre></td></tr></table></figure><p>缺点：冗余，若 .c 文件数量很多，编写起来比较麻烦</p><h2 id="makefile-中的变量"><a href="#makefile-中的变量" class="headerlink" title="makefile 中的变量"></a>makefile 中的变量</h2><p>在 makefile 中使用变量有点类似于 C 语言中的宏定义，使用该变量相当于内容替换，使用变量可以使 makefile 易于维护，修改起来变得简单。</p><p>makefile 有三种类型的变量：</p><ul><li>普通变量</li><li>自带变量</li><li>自动变量</li></ul><h3 id="普通变量"><a href="#普通变量" class="headerlink" title="普通变量"></a>普通变量</h3><ul><li>变量定义直接用 &#x3D;</li><li>使用变量值用 $(变量名)  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">如：下面是变量的定义和使用：<br>    foo = abc       // 定义变量并赋值<br>    bar = <span class="hljs-variable">$(foo)</span>    // 使用变量<br></code></pre></td></tr></table></figure>  定义了两个变量：foo、bar，其中 bar 的值是 foo 变量值的引用。</li></ul><h3 id="自带变量"><a href="#自带变量" class="headerlink" title="自带变量"></a>自带变量</h3><p>除了用户自定义变量，makefile 中也提供了一些变量(变量名大写)供用户直接使用，我们可以直接对其进行赋值：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CC = gcc <span class="hljs-comment">#arm-linux-gcc</span><br>CPPFLAGS：C 预处理的选项 -I<br>CFLAGS：C 编译器的选项 -Wall -g -c<br>LDFLAGS：链接器的选项 -L -l<br></code></pre></td></tr></table></figure><h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><ul><li>$@：表示规则中的目标</li><li>$&lt;：表示规则中的第一个条件</li><li>$^：表示规则中的所有条件，组成一个列表，以空格隔开，如果这个列表中有重复的项则消除重复项。</li><li>特别注意：自动变量只能在规则的命令中使用</li></ul><h3 id="规则模式"><a href="#规则模式" class="headerlink" title="规则模式"></a>规则模式</h3><p>至少在规则的目标定义中要包含 ‘%’ ，’%’ 表示一个或多个，在以来条件中同样可以使用 ‘%’，依赖条件中的 ‘%’ 的取值却决于其目标：</p><p>比如：main.o : main.c fun1.o : fun1.c fun2.o : fun2.c sum.o : sum.c，说的简单点就是：xxx.o : xxx.c</p><p>makefile 的第三个版本：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">target = main<br>objects = main.o fun1.o fun2.o sum.o<br>CC = gcc<br>CPPFLAGS = -I./<br><br><span class="hljs-variable">$(target)</span> : <span class="hljs-variable">$(objects)</span><br><span class="hljs-variable">$(CC)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><br><br>%.o : %.c<br><span class="hljs-variable">$(CC)</span> -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span> <span class="hljs-variable">$(CPPFLAGS)</span><br></code></pre></td></tr></table></figure><h2 id="makefile-中的函数"><a href="#makefile-中的函数" class="headerlink" title="makefile 中的函数"></a>makefile 中的函数</h2><p>makefile 中的函数有很多，在这里给打架介绍两个最常用的。</p><ol><li><p>wildcard - 查找指定目录下的指定类型的文件</p><p> <code>src = $(wildcard ./*.c)</code>     &#x2F;&#x2F; 找到当前目录下所有后缀为 .c 的文件，赋值给src</p></li><li><p>patsubst - 匹配替换</p><p> <code>obj = $(patsubst %.c,%.o,$(src))</code>    &#x2F;&#x2F; 将 src 中所有后缀为 .c 的文件替换为 .o</p></li></ol><p>在 makefile 中所有的函数都是由返回值的。</p><p>当前目录下由 main.c fun1.c fun2.c sum.c</p><p><code>src = $(wildcard ./*.c)</code> 等价于 src &#x3D; main.c fun1.c fun2.c sum.c</p><p><code>obj = $(patsubst %.c,%.o,$(src))</code> 等价于 obj &#x3D; main.o fun1.o fun2.o sum.o</p><p>makefile 的第四个版本：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile">src = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> ./*.c)</span><br>objects = <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %.o <span class="hljs-variable">$(src)</span>)</span><br>target = main<br>CC = gcc<br>CPPFLAGS = -I./<br><br><span class="hljs-variable">$(target)</span> : <span class="hljs-variable">$(objects)</span><br><span class="hljs-variable">$(CC)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><br><br>%.o : %.c<br><span class="hljs-variable">$(CC)</span> -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span> <span class="hljs-variable">$(CPPFLAGS)</span><br></code></pre></td></tr></table></figure><p>缺点：每次重新编译都需要手工清理中间文件和最终目标文件</p><h2 id="makefile-的清理操作"><a href="#makefile-的清理操作" class="headerlink" title="makefile 的清理操作"></a>makefile 的清理操作</h2><p>用途：清楚编译生成的中间文件和最终目标文件。</p><p>make clean 如果当前目录下由同名 clean 文件，则不执行 clean 对应的命令，解决方案：</p><ul><li><p>伪目标声明：</p><ul><li><code>.PHONY : clean</code></li><li>声明目标为伪目标之后，makefile 将不会检查该目标是否存在或者该目标是否需要更新。</li></ul></li><li><p>clean 命令中的特殊符号：</p><ul><li><p>“-“ 此命令出错，make 也会继续执行后续的命令。如：<code>-rm main.o</code></p><p>rm -f：将之执行，比如若要删除的文件不存在使用 -f 不会报错</p></li></ul></li><li><p>其他：</p><ul><li>make 默认执行第一个出现的目标，可通过 make dest 指定要执行的目标</li><li>make -f：-f执行第一个 makefile 文件名称，使用 make 执行指定的 makefile：make -f mainmak</li></ul></li></ul><p>makefile 的第五个版本：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile">src = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> ./*.c)</span><br>objects = <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %.o, <span class="hljs-variable">$(src)</span>)</span><br>target = main<br>CC = gcc<br>CPPFLAGS = -I./<br><br><span class="hljs-variable">$(target)</span> : <span class="hljs-variable">$(objects)</span><br><span class="hljs-variable">$(CC)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><br><br>%.o : %.c<br><span class="hljs-variable">$(CC)</span> -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span> <span class="hljs-variable">$(CPPFLAGS)</span><br><br>.PHONY : clean<br><span class="hljs-section">clean:</span><br>rm -f <span class="hljs-variable">$(objects)</span> <span class="hljs-variable">$(target)</span><br></code></pre></td></tr></table></figure><p>在 makefile 的第五个版本中，综合使用了变量，函数，规则模式和清理命令，是一个比较完善的版本。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>gcc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态库和共享（动态）库</title>
    <link href="/2025/03/04/lib-and-so/"/>
    <url>/2025/03/04/lib-and-so/</url>
    
    <content type="html"><![CDATA[<h1 id="静态库和共享（动态）库"><a href="#静态库和共享（动态）库" class="headerlink" title="静态库和共享（动态）库"></a>静态库和共享（动态）库</h1><h2 id="库的介绍"><a href="#库的介绍" class="headerlink" title="库的介绍"></a>库的介绍</h2><h3 id="什么是库"><a href="#什么是库" class="headerlink" title="什么是库"></a>什么是库</h3><p>库是二进制文件，是源代码文件的另一种表现形式，是加了密的源代码；是喜喜呃功能相近或者是相似的函数的集合体。</p><h3 id="使用库有什么好处"><a href="#使用库有什么好处" class="headerlink" title="使用库有什么好处"></a>使用库有什么好处</h3><ul><li>提高代码的可重用性，而且还可以提高程序的健壮性；</li><li>可以减少开发者的代码开发量，缩短开发周期。</li></ul><h3 id="库制作完成后，如何给用户使用"><a href="#库制作完成后，如何给用户使用" class="headerlink" title="库制作完成后，如何给用户使用"></a>库制作完成后，如何给用户使用</h3><ul><li>头文件 — 包含了库函数的声明</li><li>库文件 — 包含了库函数的代码实现</li><li>注意：库不能单独使用，只能作为其他执行程序的额一部分完成某些功能，也就是说只能被其他程序调用才能使用。</li><li>库可分静态库(static library)和共享库(shared library)两种。</li></ul><h2 id="静态库-static-library"><a href="#静态库-static-library" class="headerlink" title="静态库(static library)"></a>静态库(static library)</h2><p>静态库可以认为是一些目标代码的集合，是在可执行程序运行前就已经加入到执行码中，成为执行程序的一部分。按照习惯，一般以 .a 作为文件后缀名。</p><p>静态库的命名一般分为三个部分：</p><ul><li>前缀：lib</li><li>库名称：自定义即可，如：test</li><li>后缀：.a</li></ul><p>座椅最终的静态库的名字应该是：libtest.a</p><h3 id="静态库的制作"><a href="#静态库的制作" class="headerlink" title="静态库的制作"></a>静态库的制作</h3><p>下面以 func1.c、func2.c 和 head.h 三个文件为例讲述静态库的制作和使用，其中 head.h 文件中有函数的声明，func1.c 和 func2.c 文件中有函数的实现。</p><p>步骤一：将 c 源文件生成对应的 .o 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -c func1.c func2.c<br></code></pre></td></tr></table></figure><p>步骤二：使用打包工具与 ar 将准备好的 .o 文件打包为 .a 文件</p><ul><li>在使用 ar 工具的时候需要添加参数 rcs<ul><li>r：表示将文件插入（replace）到库中</li><li>c：表示创建（create）库</li><li>s：表示生成索引（symbol）表</li></ul></li><li>命令： ar rcs 静态库名 .o 文件<ul><li><code>ar rcs libtest.a func1.o func2.o</code></li></ul></li></ul><p><img src="/2025/03/04/lib-and-so/static_create.png" alt="创建静态库的过程"></p><h3 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a>静态库的使用</h3><p>静态库制作完成之后，需要将 .a 文件和头文件一定发布给用户。假设测试文件为 main.c，静态库文件为 libtest.a，头文件为 head.h。</p><p>用到的参数：</p><ul><li>-L：指定要链接的库的所在目录</li><li>-l：指定链接时需要的静态库，去掉前缀和后缀</li><li>-I：指定 main.c 文件用到的头文件 head.h 所在的路径</li><li><code>gcc -o main main.c -L./ -ltest -I./</code></li></ul><h3 id="静态库的优缺点"><a href="#静态库的优缺点" class="headerlink" title="静态库的优缺点"></a>静态库的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>库函数最终被打包到应用程序中，实现时函数本地化，寻址方便、速度快。(库函数调用效率 &#x3D;&#x3D; 自定义函数使用效率)</li><li>程序在运行时与函数库再无瓜葛，移植方便。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p>消耗系统资源较大，每个进程使用静态库都要复制一份，无端浪费内存。<br><img src="/2025/03/04/lib-and-so/static_disvantage.png"></p></li><li><p>静态库会给程序更新、部署喝发布带来麻烦。如果静态库 libxxx.a 更新了，所有使用它的程序都需要重新编译、发布给用户(对于用户来说，可能是一个很小的改动，却导致整个程序重新下载)。</p></li></ul><h2 id="共享库-shared-library-动态库"><a href="#共享库-shared-library-动态库" class="headerlink" title="共享库(shared library)&#x2F;动态库"></a>共享库(shared library)&#x2F;动态库</h2><p>共享库在程序编译时并不会被链接到目标代码中，二十在程序运行时才被载入。不容的应用如果调用相同的库，那么在内存里只需要有一份该共享库的拷贝，规避了空间浪费问题。动态库在程序运行时才被载入，也解决了静态库对程序的更行、部署和发布带来的麻烦。用户只需要更新动态库即可，增量更新。为什么需要动态库，其实也是静态库的特点导致的。</p><p>按照习惯，一般以 .so 作为文件后缀名。共享库的命名一般分为三个部分：</p><ul><li>前缀：lib</li><li>库名称：自定义即可，如：test</li><li>后缀：.so</li></ul><p>所以最终的动态库名称应该为：libtest.so</p><p><img src="/2025/03/04/lib-and-so/shared_create.png"></p><h3 id="共享库的制作"><a href="#共享库的制作" class="headerlink" title="共享库的制作"></a>共享库的制作</h3><ol><li><p>生成目标文件 .o，此时要加编译选项：-fPIC(fpic)’</p><p> gcc -fpic -c func1.c func2.c</p><p> 参数：-fpic 创建于地址无关的编译程序(pic，position independent code)，目的就是为了能够在多个应用程序间共享。</p></li><li><p>生成共享库，此时要加链接器选项：-shared(指定生成动态链接库)</p><p>gcc -shared func1.o func2.o -o libtest.so</p></li></ol><h3 id="共享库的使用"><a href="#共享库的使用" class="headerlink" title="共享库的使用"></a>共享库的使用</h3><p>引用动态库编译成可执行文件(跟静态库方式一样)：</p><p>用到的参数：</p><ul><li>-L：指定要链接的库的所在目录</li><li>-l：指定链接时需要的动态库，去掉前缀和后缀</li><li>-I：指定 main.c 文件用到的头文件 head.h 所在的路径</li><li><code>gcc -o main main.c -L./ -ltest -I./</code></li></ul><p>然后运行：.&#x2F;main，发现竟然报错了。<br><img src="/2025/03/04/lib-and-so/shared_error.png"></p><h4 id="分析为什么在执行的时候找不到-libtest-so-库"><a href="#分析为什么在执行的时候找不到-libtest-so-库" class="headerlink" title="分析为什么在执行的时候找不到 libtest.so 库"></a>分析为什么在执行的时候找不到 libtest.so 库</h4><ul><li><p>当系统加载可执行代码的时候，能够知道其所依赖库的名字，但是还需要知道所依赖的库的绝对路径。此时就需要系统动态载入器(dynamic linker&#x2F;loader)。</p><p>ldd 命令可以查看可执行文件依赖的库文件，执行 <code>ldd main</code>，就可发现 libtest.so 找不到<br><img src="/2025/03/04/lib-and-so/ldd_main.png"></p></li><li><p>对于 elf 格式的可执行文件，是由 ld-linux.so* 来完成的，它先后搜索 elf 文件的 DT_RPATH 段 – 环境变量 LD_LIBRARY_PATH – &#x2F;etc&#x2F;ld.so.cache 文件列表 – &#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib&#x2F; 目录找到库文件后将其载入内存。</p><p>使用 file 命令可以查看文件的类型：<code>file main</code><br><img src="/2025/03/04/lib-and-so/file_main.png"></p></li></ul><h3 id="如何让系统找到共享库"><a href="#如何让系统找到共享库" class="headerlink" title="如何让系统找到共享库"></a>如何让系统找到共享库</h3><ul><li>拷贝自己制作的共享库到 &#x2F;lib 或者 &#x2F;usr&#x2F;lib</li><li>临时设置 LD_LIBRARY_PATH：<ul><li><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径</code></li></ul></li><li>永久设置，把 <code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径</code> 设置到 ~&#x2F;.bashrc 文件中，然后在执行下列三种办法之一：<ul><li>执行 <code>. ~/.bashrc</code> 使配置文件生效</li><li>执行 <code>source ~/.bashrc</code> 使配置文件生效</li><li>退出当前终端，然后再次登录也可以使配置文件生效</li></ul></li><li>永久设置，把 <code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径</code> 设置到 &#x2F;etc&#x2F;profile 文件中。</li><li>将其添加到 &#x2F;etc&#x2F;ld.so.cache 文件中<ul><li>编辑 &#x2F;etc&#x2F;ld.so.conf 文件，加入库文件所在的目录的路径</li><li>运行 <code>sudo ldconfig -v</code>，该指令会重建 &#x2F;etc&#x2F;ld.so.cache 文件</li></ul></li></ul><p>解决了库的路径问题之后，再次 ldd 命令可以查看可执行文件依赖的库文件，<code>ldd main</code><br><img src="/2025/03/04/lib-and-so/ldd_main_ok.png"></p><h3 id="共享库的特点"><a href="#共享库的特点" class="headerlink" title="共享库的特点"></a>共享库的特点</h3><ul><li>动态库把对一些库函数的链接载入推迟到程序运行的时期。</li><li>可以实现进程之间的资源共享(因此动态库也称为共享库)。</li><li>将一些程序升级变得简单。</li><li>甚至可以真正做到链接载入完全由程序员在代码中控制(显式调用)。</li></ul><h2 id="比较静态库和动态库的优缺点"><a href="#比较静态库和动态库的优缺点" class="headerlink" title="比较静态库和动态库的优缺点"></a>比较静态库和动态库的优缺点</h2><h3 id="静态库的有点"><a href="#静态库的有点" class="headerlink" title="静态库的有点"></a>静态库的有点</h3><ol><li>执行速度快，是因为静态库已经编译到可执行文件内部了。</li><li>移植方便，不依赖于其他的库文件</li></ol><h3 id="静态库的缺点"><a href="#静态库的缺点" class="headerlink" title="静态库的缺点"></a>静态库的缺点</h3><ol><li>耗费内存，是由于每一个静态库的可执行程序都会加载一次。</li><li>部署更新麻烦，因为静态库修改以后所有的调用到这个静态库的可执行文件都需要重新编译。</li></ol><h3 id="动态库的优点"><a href="#动态库的优点" class="headerlink" title="动态库的优点"></a>动态库的优点</h3><ol><li>节省内存。</li><li>部署升级更新方便，只需替换动态库即可，然后再重启服务。</li></ol><h3 id="动态库的缺点"><a href="#动态库的缺点" class="headerlink" title="动态库的缺点"></a>动态库的缺点</h3><ol><li>加载速度比静态库慢。</li><li>移植性差，需要把所有用到的动态库都移植。</li></ol><p>由于由静态库生成的可执行文件是把静态库加载到了其内部，所以静态库生成的可执行文件一般会比动态库大。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc编译器</title>
    <link href="/2025/03/04/gcc-compiler/"/>
    <url>/2025/03/04/gcc-compiler/</url>
    
    <content type="html"><![CDATA[<h1 id="gcc-编译器"><a href="#gcc-编译器" class="headerlink" title="gcc 编译器"></a>gcc 编译器</h1><h2 id="gcc-的工作流程"><a href="#gcc-的工作流程" class="headerlink" title="gcc 的工作流程"></a>gcc 的工作流程</h2><p>gcc 编译器将 c 源文件到生成一个可执行程序，中间一共经历了四个步骤：<br><img src="/2025/03/04/gcc-compiler/gcc_compile_flow.png"></p><p>四个步骤并不是 gcc 独立完成的，而是在内部调用了其他工具，从而完成了整个工作流程，其中编译最耗时，因为要逐行检查语法。<br><img src="/2025/03/04/gcc-compiler/gcc_tool_chain.png"></p><p>下面以 test.c 为例介绍 gcc 的四个步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -E test.c -o test.i<br>gcc -S test.i -o test.s<br>gcc -c test.s -o test.o<br>gcc test.o -o test<br></code></pre></td></tr></table></figure><p>一步生成最终可执行程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc test.c -o test<br></code></pre></td></tr></table></figure><h2 id="gcc-常用参数"><a href="#gcc-常用参数" class="headerlink" title="gcc 常用参数"></a>gcc 常用参数</h2><ul><li>-v 查看 gcc 版本号， –version 也可以</li><li>-E 生成预处理文件</li><li>-S 生成汇编文件</li><li>-c 只编译，生成 .o 文件，通常称为目标文件</li><li>-I 指定头文件所在的路径</li><li>-L 指定库文件所在的路径</li><li>-l 指定库的名字</li><li>-o 指定生成的目标文件的名字</li><li>-g 包含调试信息，使用 gdb 调试需要添加 -g 参数</li><li>-On n&#x3D;0~3 编译优化，n 越大优化程度越高，但编译时间越长</li></ul><p>例如：下面代码片段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = a;<br><span class="hljs-type">int</span> c = b;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, c);<br></code></pre></td></tr></table></figure><p>上面的代码可能会被编译器优化成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> c = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><ul><li>-Wall 提示更多警告信息</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br><span class="hljs-type">int</span> c = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d]\n&quot;</span>, c);<br></code></pre></td></tr></table></figure><p>编译如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -o test -Wall test.c<br>warning: unused variable &#x27;a&#x27; [-Wunused-variable]<br>warning: unused variable &#x27;b&#x27; [-Wunused-variable]<br></code></pre></td></tr></table></figure><ul><li>-D 编译时定义宏<br>test.c 文件中的代码片段：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max==[%d]&quot;</span>, MAX);<br></code></pre></td></tr></table></figure><p>编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -o test test.c -D MAX=10<br>gcc -o test test.c -DMAX=10<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>gcc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础命令</title>
    <link href="/2025/03/03/linux_base/"/>
    <url>/2025/03/03/linux_base/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h1><h2 id="Shell-相关"><a href="#Shell-相关" class="headerlink" title="Shell 相关"></a>Shell 相关</h2><pre><code class="hljs">概念： Shell就是命令解析器，Shell将用户输入的命令解释成内核能够识别的指令，Shell就相当于翻译。查看当前系统使用的shell:    echo $SHELL查看当前系统支持的shell:    cat /etc/shells</code></pre><h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><pre><code class="hljs">是一个倒立的树状结构。</code></pre><ul><li>&#x2F;bin: binary，二进制文件，可执行程序，shell命令<ul><li>如：ls, rm, mv, cp等常用命令</li></ul></li><li>&#x2F;sbin: s是Super User的意思，这里存放的是系统管理员使用的系统管理程序。<ul><li>如ifconfig, halt, shutdown, reboot等系统命令</li></ul></li><li>&#x2F;dev: device，在linux下一切皆文件<ul><li>硬盘, 显卡, 显示器</li><li>字符设备文件、块设备文件<ul><li>如: 在input目录下执行: sudo cat mouse0, 移动鼠标会显示有输入.</li></ul></li></ul></li><li>&#x2F;lib: linux运行的时候需要加载的一些动态库<ul><li>如: libc.so、libpthread.so等</li></ul></li><li>&#x2F;mnt: 手动的挂载目录, 如U盘等</li><li>&#x2F;media: 外设的自动挂载目录, 如光驱等</li><li>&#x2F;root: linux的超级用户root的家目录</li><li>&#x2F;usr: unix system resource–类似于WINDOWS的programe files目录<ul><li>include目录里存放头文件, 如: stdio.h、stdlib.h、string.h、pthread.h</li><li>games目录下的小游戏-如: sl小火车游戏</li></ul></li><li>&#x2F;etc: 存放配置文件<ul><li>&#x2F;etc&#x2F;passwd<ul><li>man 5 passwd可以查看passwd文件的格式信息</li></ul></li><li>&#x2F;etc&#x2F;group<ul><li>man 5 group可以查看group文件的格式信息</li></ul></li><li>&#x2F;etc&#x2F;profile<ul><li>系统的配置文件, 修改该文件会影响这个系统下面的所有的用户</li></ul></li></ul></li><li>&#x2F;opt: 安装第三方应用程序<ul><li>比如安装oracle数据库可以在这个目录下</li></ul></li><li>&#x2F;home: linux操作系统所有用户的家目录<ul><li>用户家目录：(宿主目录或者主目录)<ul><li>&#x2F;home&#x2F;itcast</li></ul></li></ul></li><li>&#x2F;tmp: 存放临时文件<ul><li>新建在这个目录下的文件会在系统重启后自动清除</li></ul></li></ul><h2 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h2><ul><li>绝对路径: 从&#x2F;目录开始表示的目录.</li><li>相对路径: 从当前目录开始表示的目录.<ul><li>从当前所处的目录开始表示的路径。</li><li>. 表示当前目录</li><li>.. 表示当前目录的上一级目录</li></ul></li></ul><h2 id="文件和目录操作相关的命令"><a href="#文件和目录操作相关的命令" class="headerlink" title="文件和目录操作相关的命令"></a>文件和目录操作相关的命令</h2><h3 id="tree-命令"><a href="#tree-命令" class="headerlink" title="tree 命令"></a>tree 命令</h3><pre><code class="hljs">以树状星蚀查看指定目录内容，使用该命令需要安装软件tree</code></pre><p>命令使用方法：</p><ul><li>tree – 树状结构显示当前目录下的文件信息</li><li>tree 目录 – 树状结构显示指定目录下的文件信息</li></ul><h3 id="ls-命令"><a href="#ls-命令" class="headerlink" title="ls 命令"></a>ls 命令</h3><ul><li>查看指定目录下的文件信息</li><li>使用方法：<ul><li>ls – 显示当前目录下的文件信息</li><li>ls 目录 – 显示指定目录下的文件信息</li></ul></li><li>相关参数<ul><li>-a: 显示所有文件和目录<ul><li>. 当前目录</li><li>.. 当前目录的额上一级目录</li><li>隐藏文件，以 . 开头的文件，如.bashrc</li><li>普通文件</li></ul></li><li>-R: 递归显示指定目录下的文件信息</li><li>-l: 列出文件的详细信息，7部分内容<br><img src="/2025/03/03/linux_base/ls-l.png"></li><li>参数之间可以结合使用：<ul><li>ls -la: 列出当前目录下所有文件的相关信息，包括隐藏文件</li><li>ls -ltr: 列出当前目录下的文件，按照时间你想排序</li></ul></li></ul></li></ul><h3 id="cd-命令"><a href="#cd-命令" class="headerlink" title="cd 命令"></a>cd 命令</h3><pre><code class="hljs">切换目录(change directory)，命令使用方式：cd + 目录路径可以使用相对路径或者绝对路径</code></pre><ul><li>切换到家目录<ul><li>cd</li><li>cd ~</li><li>cd &#x2F;home&#x2F;user_name</li><li>cd $HOME</li></ul></li><li>临近两个目录切换<ul><li>cd -</li></ul></li></ul><h3 id="pwd-命令"><a href="#pwd-命令" class="headerlink" title="pwd 命令"></a>pwd 命令</h3><pre><code class="hljs">查看用户当前所处的工作目录，print working directory</code></pre><h3 id="which-命令"><a href="#which-命令" class="headerlink" title="which 命令"></a>which 命令</h3><pre><code class="hljs">显示命令所在的目录, 如 which ls， which cp</code></pre><h3 id="touch-命令"><a href="#touch-命令" class="headerlink" title="touch 命令"></a>touch 命令</h3><pre><code class="hljs">如果文件不存在，创建新文件，如果文件存在，更新最后修改时间命令使用方式：touch 文件名</code></pre><h3 id="mkdir-命令"><a href="#mkdir-命令" class="headerlink" title="mkdir 命令"></a>mkdir 命令</h3><pre><code class="hljs">创建新目录，make directory创建方式：mkdir 目录名如果创建多级目录需要添加参数 -p：  在当前目录下创建目录： mkdir mydir  在宿主目录下创建多级目录： mkdir -p ~/test/hello/world/aa</code></pre><h3 id="rmdir-命令"><a href="#rmdir-命令" class="headerlink" title="rmdir 命令"></a>rmdir 命令</h3><pre><code class="hljs">删除空目录，只能删除空目录 ，使用方式：rmdir 目录名</code></pre><h3 id="rm-命令"><a href="#rm-命令" class="headerlink" title="rm 命令"></a>rm 命令</h3><ul><li>删除文件： rm 文件名</li><li>删除目录： rm -r 目录名</li><li>参数：<ul><li>-r： 递归删除目录，删除目录碧玺添加此参数</li><li>-i： 提示用户是否删除文件或目录</li><li>-f： 强制删除</li></ul></li><li>注意事项：<ul><li>使用 rm 命令删除的文件或目录不会放入回收站中，数据不易回复。</li></ul></li></ul><h3 id="cp-命令"><a href="#cp-命令" class="headerlink" title="cp 命令"></a>cp 命令</h3><p>命令使用方式： cp 源目录或文件 目标目录或文件</p><p>若有目录的拷贝需要使用 -r 参数</p><ul><li>cp 要拷贝的文件(file1) file(不存在)<ul><li>创建 file，将 file1 中的内容拷贝到 file</li></ul></li><li>cp file1 file(存在)<ul><li>file1 覆盖 file</li></ul></li><li>cp file dir(存在)<ul><li>拷贝 file 到 dir 目录</li></ul></li><li>cp -r dir(存在) dir1(存在)<ul><li>将 dir 目录拷贝到 dir1 目录中</li><li>包括 dir 目录</li></ul></li><li>cp -r dir(存在) dir1(不存在)<ul><li>创建 dir1</li><li>将 dir 目录拷贝到 dir1 中，不包括 dir 目录</li></ul></li><li>cp 拷贝目录也可以用 -a 参数，这样可以保留被拷贝的文件的一些属性信息</li></ul><h3 id="mv-命令"><a href="#mv-命令" class="headerlink" title="mv 命令"></a>mv 命令</h3><ul><li>改名或者移动文件 mv file1 file2<ul><li>改名：<ul><li>mv file(存在) file1(不存在)</li><li>mv dir(存在) dir1(不存在)</li><li>mv file(存在) file1(存在)<ul><li>file 文件覆盖 file1 文件，file 改名为 file1</li></ul></li></ul></li><li>移动(第二个参数一定是目录文件)<ul><li>mv file(文件) dir(存在目录)<ul><li>将 file 文件移动到 dir 中</li></ul></li><li>mv dir(目录) dir1(存在目录)<ul><li>将 dir 目录移动到 dir1 中，dir 就会作为 dir1 的子目录而存在</li></ul></li></ul></li></ul></li></ul><h3 id="cat-命令"><a href="#cat-命令" class="headerlink" title="cat 命令"></a>cat 命令</h3><ul><li>将文件内容一次性输出到终端。</li><li>使用方式： cat 文件名</li><li>缺点：终端显示的内容有限，如果文件太长无法显示全部。</li><li>可用于文件重定向：cat file1 &gt; file2， 相当于 cp file1 file2</li></ul><h3 id="more-命令"><a href="#more-命令" class="headerlink" title="more 命令"></a>more 命令</h3><ul><li>文件内容分页显示到终端，但是智能一直向下浏览，不能回退</li><li>使用方式：more + 文件名</li><li>相关操作：<ul><li>显示下一行：回车</li><li>显示下一页：空格</li><li>退出：q(ctrl + c)</li></ul></li></ul><h3 id="less-命令"><a href="#less-命令" class="headerlink" title="less 命令"></a>less 命令</h3><ul><li>文件内容分页显示到终端，可以上下浏览</li><li>使用方式：less + 文件名</li><li>相关操作：<ul><li>显示下一行：回车、ctrl + p、方向键上</li><li>显示上一行：ctrl + n、方向键下</li><li>显示下一页：空格、PageDown</li><li>显示上一页：PageUp</li><li>退出：q</li></ul></li></ul><h3 id="head-命令"><a href="#head-命令" class="headerlink" title="head 命令"></a>head 命令</h3><ul><li>从文件头部开始查看前 n 行的内容</li><li>使用方式： head -n[行数] 文件名<ul><li>head -20 hello.txt’</li></ul></li><li>如果没有指定行数，默认显示前10行内容</li></ul><h3 id="tail-命令"><a href="#tail-命令" class="headerlink" title="tail 命令"></a>tail 命令</h3><ul><li>从文件尾部向上查看最后 n 行的内容</li><li>使用方式： tail -n[行数] 文件名</li><li>如果未指定行数，默认显示最后10行内容</li><li>一个比较重要的应用：显示日志：<code>tail -f test.log</code>，可以实时显示日志内容，当有新的日志产生时，会自动显示在终端上</li></ul><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><ul><li>软链接类似于 windows 下的快捷方式</li><li>如何创建软链接<ul><li><p>ln -s 文件名 快捷方式的名字</p><p>例如：ln -s aa aa.soft</p></li><li><p>目录也可以创建软链接</p><p>例如：ln -s tmp tmp.link</p></li></ul></li><li>创建软链接应注意事项<ul><li>ln 创建软链接要用绝对路径，因为如果不使用绝对路径，一旦这个链接文件发生位置变动，就不能找到那个文件了。</li><li>软链接文件的大小是：路径 + 文件名的总字节数</li></ul></li></ul><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><ul><li>ln 文件名 硬链接的名字<ul><li>ln test.log test.log.hard</li></ul></li><li>使用硬链接应注意事项<ul><li><p>硬链接不能建立在目录上</p></li><li><p>硬链接对绝对路径没有要求</p></li><li><p>硬链接不能跨文件系统</p><p>硬链接文件和源文件的 inode 是相同的，文件系统的 inode 要求唯一，跨文件系统可能会使 inode不同，所以硬链接不能跨文件系统</p></li></ul></li><li>硬链接的本质<ul><li>硬链接的本质使不同的文件名所在 inode 节点是相同的，相同的 inode 节点指向了相同的数据块，所以它们的文件内容是一样的，文件内容会同步。<ul><li><p>ls -i 文件名 —–&gt; 可以查看文件的 i 节点</p></li><li><p>stat 文件名 —–&gt; 可以查看文件的详细信息，包括 inode 节点</p></li><li><p>如下图，file.hard 是 file 的硬链接，这两个文件指向同一个 inode，同一个 inode 指向了相同的数据块(文件内容)。<br><img src="/2025/03/03/linux_base/hardlink.png"></p><ul><li>当新创建了一个文件，硬链接计数为1</li><li>给文件创建了一个硬链接后，硬链接计数加1</li><li>删除一个硬链接后，硬链接计数减1</li><li>如果删除硬链接后，硬链接技术为0，则该文件会被删除</li></ul></li></ul></li></ul></li><li>硬链接应用场合<ul><li><p>可以起到文件同步的作用</p><p>修改 file 内容，会在其余几个硬链接文件上同步</p></li><li><p>可以起到保护文件的作用</p><p>删除文件的时候，只要硬链接技术不为0，不会真正删除，起到保护文件的作用。</p></li></ul></li></ul><h3 id="wc-命令"><a href="#wc-命令" class="headerlink" title="wc 命令"></a>wc 命令</h3><ul><li>显示文件行数，字节数，单词数<ul><li>wc -l file 显示文件的总行数</li><li>wc -c file 显示文件的总字节数</li><li>wc -w file 显示文件的总单词数</li><li>wc file 显示文件的总行数，总字节数，总单词数</li></ul></li></ul><h3 id="whoami-命令"><a href="#whoami-命令" class="headerlink" title="whoami 命令"></a>whoami 命令</h3><ul><li>显示当前用户名</li></ul><h2 id="用户权限、用户、用户组"><a href="#用户权限、用户、用户组" class="headerlink" title="用户权限、用户、用户组"></a>用户权限、用户、用户组</h2><h3 id="修改文件权限-chmod"><a href="#修改文件权限-chmod" class="headerlink" title="修改文件权限 chmod"></a>修改文件权限 chmod</h3><pre><code class="hljs">linux 是通过权限对文件进行控制的，通过使用 chmod 命令可以修改文件相关的权限</code></pre><ul><li>文字设定法<ul><li>命令：chmod [+|-|&#x3D;] 文件名<ul><li>操作对象 [who]<ul><li>u – 用户(user)</li><li>g – 同组用户(group)</li><li>o – 其他用户(other)</li><li>a – 所有用户(all)</li></ul></li><li>操作符 [+|-|&#x3D;]<ul><li>+ – 添加权限</li><li>- – 删除权限</li><li>&#x3D; – 赋予给定权限并取消其他权限</li></ul></li><li>权限 [mode]<ul><li>r – 读权限</li><li>w – 写权限</li><li>x – 执行权限</li></ul></li></ul></li><li>示例：给文件 file.txt 的所有者和所属组添加读写权限<ul><li>chmod ug+wr file.txt</li></ul></li></ul></li><li>数字设定法<ul><li>命令：chmod [who] [+|-|&#x3D;] 文件名<ul><li>操作符 [+|-|&#x3D;]<ul><li>\ – 添加权限</li><li>- – 删除权限</li><li>&#x3D; – 赋予给定权限并取消其他权限</li></ul></li><li>数字表示的含义<ul><li>0 – 没有权限(-)</li><li>1 – 执行权限(x)</li><li>2 – 写权限(w)</li><li>4 – 读权限(r)</li></ul></li><li>例：给 file.txt 文件设置 rw-rw-r–<ul><li>chmod 664 file.txt</li></ul></li></ul></li></ul></li></ul><p>注意点：使用数字设定发，一定要使用3位的8进制数：如066</p><h3 id="修改文件所有者和所属组"><a href="#修改文件所有者和所属组" class="headerlink" title="修改文件所有者和所属组"></a>修改文件所有者和所属组</h3><ul><li>修改文件所有者 chown<ul><li>用法：chown 文件所有者 文件名<ul><li>sudo chown user file.txt</li></ul></li></ul></li><li>修改文件所有者和所属组 chown<ul><li>用法：chown 文件所有者：文件所属组 文件名<ul><li>sudo chown user:group file.txt</li></ul></li></ul></li><li>注意：普通用户需要使用管理员用户权限执行该命令</li><li>注意：若系统没有其他用法，可以使用 <code>sudo adduser 用户名</code> 创建一个新用户</li></ul><h3 id="修改文件所属组"><a href="#修改文件所属组" class="headerlink" title="修改文件所属组"></a>修改文件所属组</h3><ul><li>chgrp 命令<ul><li>使用方法：chgrp 用户组 文件或目录名<ul><li>示例：修改文件所属组位 group1</li><li>sudo chgrp group1 file.txt</li></ul></li><li>普通用户需要使用管理员用户权限执行该命令</li></ul></li></ul><h2 id="find-命令"><a href="#find-命令" class="headerlink" title="find 命令"></a>find 命令</h2><h3 id="按文件名查询：使用参数-name"><a href="#按文件名查询：使用参数-name" class="headerlink" title="按文件名查询：使用参数 -name"></a>按文件名查询：使用参数 -name</h3><ul><li>命令：find 路径 -name “文件名”</li><li>示例：find &#x2F;home -name “*.c”</li></ul><h3 id="按文件类型查询：使用参数-type"><a href="#按文件类型查询：使用参数-type" class="headerlink" title="按文件类型查询：使用参数 -type"></a>按文件类型查询：使用参数 -type</h3><ul><li>命令：find 路径 -type 类型<ul><li>普通文件类型用 f 表示而不是 -</li><li>d -&gt; 目录</li><li>l -&gt; 符号链接</li><li>b -&gt; 块设备</li><li>c -&gt; 字符设备</li><li>s -&gt; socket 文件</li><li>p -&gt; 管道文件</li></ul></li><li>查找指定目录下的普通文件： find 路径 -type f</li></ul><h3 id="按文件大小查询：使用参数-size"><a href="#按文件大小查询：使用参数-size" class="headerlink" title="按文件大小查询：使用参数 -size"></a>按文件大小查询：使用参数 -size</h3><ul><li>命令：find 路径 -size 范围<ul><li>范围：<ul><li>大于：+ 表示 – +100k</li><li>小于：- 表示 – -100k</li><li>等于：无符号表示 – 100k</li></ul></li><li>大小：<ul><li>M 必须大写(10M)</li><li>k 必须小写(10k)</li><li>c 表示字节数</li></ul></li><li>例子：查询目录为家目录<ul><li>等于 100k 的文件：find ~&#x2F; -size 100k</li><li>大于 100k 的文件：find ~&#x2F; -size +100k</li><li>大于 50k，小于 100k 的文件：find ~&#x2F; -size +50k -size -100k</li></ul></li></ul></li></ul><h3 id="按文件日期"><a href="#按文件日期" class="headerlink" title="按文件日期"></a>按文件日期</h3><ul><li>创建日期：-ctime -n&#x2F;+n</li><li>修改日期：-mtime -n&#x2F;+n</li><li>访问日期：-atime -n&#x2F;+n</li></ul><h3 id="按深度"><a href="#按深度" class="headerlink" title="按深度"></a>按深度</h3><ul><li>maxdepth n(层数)<ul><li>搜索 n 层以下的目录，搜索的层数不超过 n 层</li></ul></li><li>mindepth n(层数)<ul><li>搜索 n 层以上的目录，搜索的层数不能小于 n 层</li></ul></li></ul><h3 id="高级查找"><a href="#高级查找" class="headerlink" title="高级查找"></a>高级查找</h3><ul><li>例：查找指定目录下所有目录，并列出目录中文件详细信息<ul><li>find .&#x2F; -type d -exec shell 命令 {} ;<ul><li>find .&#x2F; -type d -exec ls -l {} ;</li></ul></li><li>find .&#x2F; -type d -ok shell 命令 {} ;<ul><li>find .&#x2F; -type d -ok ls -l {} ;</li></ul></li></ul></li><li>注意：{}中间不能又空格</li><li>ok 比较安全，特别是在执行 rm 删除文件的时候<ul><li>find .&#x2F; -type d | xargs shell 命令<ul><li>find .&#x2F; -type d | xargs ls -l</li></ul></li></ul></li></ul><h2 id="grep-命令"><a href="#grep-命令" class="headerlink" title="grep 命令"></a>grep 命令</h2><h3 id="grep-r-有目录-“查找的内容”-搜索路径"><a href="#grep-r-有目录-“查找的内容”-搜索路径" class="headerlink" title="grep -r(有目录) “查找的内容” 搜索路径"></a>grep -r(有目录) “查找的内容” 搜索路径</h3><ul><li>-r 参数，若是目录，则可以递归搜索</li><li>-n 参数可以显示该查找内容所在的行号</li><li>-i 参数可以忽略大小写进行查找</li><li>-v 参数不显示含有某字符串</li></ul><h3 id="搜索当前目录下包含-hello-world-字符串的文件"><a href="#搜索当前目录下包含-hello-world-字符串的文件" class="headerlink" title="搜索当前目录下包含 hello world 字符串的文件"></a>搜索当前目录下包含 hello world 字符串的文件</h3><ul><li><code>grep -r -n &quot;hello world&quot; ./</code>    —-显示行号</li><li><code>grep -r -n -i &quot;HELLO world&quot; ./</code>    —-忽略大小写查找</li></ul><h2 id="find-和-grep-命令结合使用"><a href="#find-和-grep-命令结合使用" class="headerlink" title="find 和 grep 命令结合使用"></a>find 和 grep 命令结合使用</h2><h3 id="先使用-find-命令查找文件，然后使用-grep-命令查找那些文件包含某个字符串"><a href="#先使用-find-命令查找文件，然后使用-grep-命令查找那些文件包含某个字符串" class="headerlink" title="先使用 find 命令查找文件，然后使用 grep 命令查找那些文件包含某个字符串"></a>先使用 find 命令查找文件，然后使用 grep 命令查找那些文件包含某个字符串</h3><ul><li>find . -name “*.c” | xargs grep -n “main”</li></ul><h2 id="Linux-中常用的压缩工具"><a href="#Linux-中常用的压缩工具" class="headerlink" title="Linux 中常用的压缩工具"></a>Linux 中常用的压缩工具</h2><h3 id="gzip-和-bzip2"><a href="#gzip-和-bzip2" class="headerlink" title="gzip 和 bzip2"></a>gzip 和 bzip2</h3><ul><li>不能压缩目录，只能一个一个文件进行压缩，压缩之后会使源文件消失</li><li>gzip * 压缩当前目录下所有的文件，但是目录不能压缩</li><li>gunzip * 解压当前目录下所有的 .gz 文件</li><li>bzip2 * 压缩当前目录下所有的文件，但是目录不能压缩</li><li>bunzip2 * 解压当前目录下所有的 .bz2 文件</li></ul><h3 id="tar-工具"><a href="#tar-工具" class="headerlink" title="tar 工具"></a>tar 工具</h3><ul><li>相关参数说明<ul><li>z：用 gzip 来压缩&#x2F;解压文件</li><li>j：用 bzip2 来压缩&#x2F;解压文件</li><li>c：create，创建新的压缩文件，与 x 互斥使用</li><li>x：从压缩文件中释放文件，与 c 互斥使用</li><li>f：指定压缩文件的名字</li><li>t：查看压缩包中有哪些文件</li></ul></li><li>压缩：<ul><li>tar -cvf 压缩包名.tar 要压缩的文件或目录</li><li>tar -cvzf 压缩包名.tar.gz 要压缩的文件或目录</li><li>tar -cvjf 压缩包名.tar.bz2 要压缩的文件或目录</li></ul></li><li>解压缩<ul><li>tar -xvf 压缩包名.tar</li><li>tar -xzvf 压缩包名.tar.gz</li><li>tar -xjvf 压缩包名.tar.bz2</li><li>解压到指定目录：添加参数 -C(大写)<ul><li>tar -xzvf 压缩包名.tar.gz -C 指定目录</li></ul></li></ul></li><li>查看压缩包中有哪些文件<ul><li>tar -tvf 压缩包名.tar</li></ul></li></ul><h3 id="rar-工具"><a href="#rar-工具" class="headerlink" title="rar 工具"></a>rar 工具</h3><ul><li>使用前需要安装 rar 工具<ul><li>安装命令：sudo apt-get install rar</li></ul></li><li>压缩：<ul><li>命令： rar a -r 压缩包名 要压缩的文件<ul><li>压缩目录需要使用参数： -R</li><li>rar a -r my aa bb dir —-将 aa bb dir 三个文件压缩到 my.rar 中</li></ul></li><li>打包的生成的新文件不需要指定后缀</li></ul></li><li>解压缩：<ul><li>命令：rar x xxx.rar 压缩目录<ul><li>rar x my.rar —-将 my.rar 中的文件解压到当前目录</li></ul></li><li>解压到指定目录，直接指定解压目录即可<ul><li>rar x xxx.rar 目录</li><li>rar x my.rar TAR —-将 my.rar 中的文件解压到 TAR 目录</li><li>注意：若解压目录不存在则会报错</li></ul></li></ul></li></ul><h3 id="zip-工具"><a href="#zip-工具" class="headerlink" title="zip 工具"></a>zip 工具</h3><ul><li>压缩：zip -r 压缩包名 要压缩的文件或目录<ul><li>压缩目录需要使用参数 -R</li><li>使用该命令不需要指定压缩包后缀</li><li>zip -r xxx file dir —-将 file dir 两个文件压缩到 xxx.zip 中</li></ul></li><li>解压缩：unzip 压缩包名<ul><li>解压缩到指定目录：添加参数 -d 解压目录</li><li>unzip xxx.zip -d &#x2F;home</li><li>注意：若解压目录不存在则会创建</li></ul></li></ul><h2 id="软件的安装和卸载"><a href="#软件的安装和卸载" class="headerlink" title="软件的安装和卸载"></a>软件的安装和卸载</h2><h3 id="在线安装"><a href="#在线安装" class="headerlink" title="在线安装"></a>在线安装</h3><ul><li>软件安装：sudo apt-get install 软件名</li><li>软件卸载：sudo apt-get remove 软件名</li><li>更新软件列表：sudo apt-get update</li><li>清理安装包：sudo apt-get clean</li></ul><h3 id="安装包安装"><a href="#安装包安装" class="headerlink" title="安装包安装"></a>安装包安装</h3><ul><li>在 Ubuntu 系统下必须有 deb 格式的安装包</li><li>软件安装：sudo dpkg -i xxx.deb</li><li>软件卸载：sudo dpkg -r xxx.deb</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
