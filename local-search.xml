<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>跟随鼠标移动的小球</title>
    <link href="/2025/04/06/easyx-demo/"/>
    <url>/2025/04/06/easyx-demo/</url>
    
    <content type="html"><![CDATA[<h1 id="跟随鼠标移动的小球"><a href="#跟随鼠标移动的小球" class="headerlink" title="跟随鼠标移动的小球"></a>跟随鼠标移动的小球</h1><h2 id="绘制边框"><a href="#绘制边框" class="headerlink" title="绘制边框"></a>绘制边框</h2><p>EasyX 绘图函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">HWND <span class="hljs-title">initgraph</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> width,          <span class="hljs-comment">// 窗口宽度</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> height,         <span class="hljs-comment">// 窗口高度</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> flag = <span class="hljs-literal">NULL</span>     <span class="hljs-comment">// 窗口样式</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>使用该函数创建窗口后，屏幕会闪过一个窗口后，程序就结束运行了。<br> 通用的方法就是使用一个死循环来卡住程序。</p><p><img src="/2025/03/21/file-io/mo/image1.png" alt="通用游戏框架"></p><p>所有的游戏都依赖一个循环来不断更新画面、读入玩家操作事件，而这个循环就叫做游戏的“主循环”</p><h2 id="绘制小球"><a href="#绘制小球" class="headerlink" title="绘制小球"></a>绘制小球</h2><p><code>solidcircle</code> 函数用于画无边框的填充圆</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solidcircle</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> x,          <span class="hljs-comment">// 圆心 x 坐标</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> y,          <span class="hljs-comment">// 圆心 y 坐标</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> radius      <span class="hljs-comment">// 圆的半径</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>在窗口的 (300, 300) 位置绘制一个半径为 100 的圆：<code>solidcircle(300, 300, 100);</code></p><h2 id="处理鼠标移动事件"><a href="#处理鼠标移动事件" class="headerlink" title="处理鼠标移动事件"></a>处理鼠标移动事件</h2><p><code>peekmessage</code> 函数用于获取一个消息，并立即返回</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">peekmessage</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    ExMessage *msg,         <span class="hljs-comment">// 指向消息结构体 ExMessage 的指针，用来保存获取到的消息</span></span></span><br><span class="hljs-params"><span class="hljs-function">    BYTE filter = <span class="hljs-number">-1</span>,       <span class="hljs-comment">// 指定要获取的消息范围，默认 -1 获取所有类别的消息</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">bool</span> removemsg = <span class="hljs-literal">true</span>   <span class="hljs-comment">// 在 peekmessage 处理完消息后，是否将其从消息队列中移除</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><br><br></code></pre></td></tr></table></figure><p>在 EasyX 中鼠标的移动、点击或者是键盘的按键操作都称作为“消息”。</p><p><img src="/2025/03/21/file-io/mo/image2.png"></p><p>当我们触发这些消息的时候，EasyX 会将其放置到自己的消息队列中</p><p><img src="/2025/03/21/file-io/mo/image3.png"></p><p>当我们每次调用 peekmessage 函数便尝试从消息队列中拉去一个消息，如果成功拉去到了消息，那么函数则会返回 true，反之则返回 false</p><p><img src="/2025/03/21/file-io/mo/image4.png"></p><p>这样，我们不断地从队列中拉去已有的消息进行处理</p><p><img src="/2025/03/21/file-io/mo/image5.png"></p><p>现在开始就需要对存储消息的结构体进行分析 &lt;<a href="https://docs.easyx.cn/zh-cn/exmessage">ExMessage 结构体</a>&gt; <br> 查看文档可知，结构体中的 <code>message</code> 成员对应的 <code>WM_MOUSEMOVE</code> 就是鼠标移动对应的消息。</p><p>我们定义两个变量 x 和 y，用来保存圆心位置，当鼠标移动的时候将当前鼠标坐标赋值给它们。这样写好后，就会导致窗口中的圆越来越多。这是因为在绘制新圆的时候，没有将旧的圆擦除。解决的方法很简单，在每次循环绘制圆的之前，将整个窗口清空一次就可以了。</p><p>画出圆后屏幕上的圆会不断闪烁，这是因为没有使用双缓冲绘图导致的。在代码中添加三行代码就可以解决：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">BeginBatchDraw</span>();<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 游戏主循环</span><br>    <span class="hljs-built_in">FlushBatchDraw</span>();<br>&#125;<br><span class="hljs-built_in">EndBatchDraw</span>();<br></code></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/BV1iQ4y1s7Qj?vd_source=d3a8a2f439156e68b612ac4b2fcf649a">视频教程</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>游戏开发</tag>
      
      <tag>EasyX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号</title>
    <link href="/2025/03/27/signals/"/>
    <url>/2025/03/27/signals/</url>
    
    <content type="html"><![CDATA[<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><h2 id="信号介绍"><a href="#信号介绍" class="headerlink" title="信号介绍"></a>信号介绍</h2><h3 id="信号的概念"><a href="#信号的概念" class="headerlink" title="信号的概念"></a>信号的概念</h3><p>信号是信息的载体，Linux&#x2F;Unix 环境下，古老、经典的通信方式，现下依然是主要的通信手段。</p><ul><li>信号在我们的生活中随处可见，例如：<ul><li>古代战争中摔杯为号</li><li>现代战争中的信号弹</li><li>体育比赛中使用的信号强……</li></ul></li><li>信号的特点<ul><li>简单</li><li>不能携带大量信息</li><li>满足某个特定条件参会产生</li></ul></li></ul><h2 id="信号的机制"><a href="#信号的机制" class="headerlink" title="信号的机制"></a>信号的机制</h2><p>进程 A 给进程 B 发送信号，进程 B 收到信号之前执行自己的代码，收到信号后不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕后再继续执行。与硬件中断类似 —— 异步模式。但信号是软件层面上实现的终端，早期常被称为“软中断”。</p><p><strong>每个进程收到的所有信号，都是由内核负责发送的。</strong></p><p><img src="/2025/03/27/signals/image1.png" alt="进程 A 给进程 B 发送信号示意图"></p><h3 id="信号的状态"><a href="#信号的状态" class="headerlink" title="信号的状态"></a>信号的状态</h3><p>信号由三种状态：产生、未决和递达</p><ul><li>信号的产生<ul><li>按键产生，如：Ctrl + c、Ctrl + z、Ctrl + \</li><li>系统调用产生，如：kill、raise、abort</li><li>软件条件山城，如：定时器 alarm</li><li>硬件异常产生，如：非法访问内存 (错误段)、除 0 (浮点数例外)、内存对齐出错 (总线错误)</li><li>命令产生，如：kill 命令</li></ul></li><li>未决： 产生和递达之间的状态。主要由于阻塞 (屏蔽) 导致该状态</li><li>递达：递送并且达到进程</li></ul><h3 id="信号处理方式"><a href="#信号处理方式" class="headerlink" title="信号处理方式"></a>信号处理方式</h3><ul><li>执行默认动作</li><li>忽略信号 (丢弃不处理)</li><li>捕捉信号 (调用用户的自定义的处理函数)</li></ul><h3 id="信号的特质"><a href="#信号的特质" class="headerlink" title="信号的特质"></a>信号的特质</h3><p>信号的实现手段导致信号<strong>有很强的延时性</strong>，但对于用户来说，时间非常短，不易察觉。</p><p>Linux 内核的进程控制块 PCB 是一个结构体，task_struct，除了包含进程 id，状态，工作目录，用户 id，组 id，文件描述符表，还包含了信号相关的信息，主要指<strong>阻塞信号集和未决信号集</strong>。</p><h3 id="阻塞信号集和未决信号集"><a href="#阻塞信号集和未决信号集" class="headerlink" title="阻塞信号集和未决信号集"></a>阻塞信号集和未决信号集</h3><ul><li>阻塞信号集中保存的都是被当前进程阻塞的信号。若当前进程收到的是阻塞信号集中的某些信号，这些信号需要暂时被阻塞，不予处理。</li><li>信号产生后由于某些原因 (主要是阻塞) 不能抵达，这类信号的集合称之为未决信号集。在屏蔽解除之前，信号一直处于未决状态；若是信号从阻塞信号集中解除阻塞，则该信号会被处理，并从未决信号集中去除。</li></ul><h3 id="信号的四要素"><a href="#信号的四要素" class="headerlink" title="信号的四要素"></a>信号的四要素</h3><ul><li>通过 <code>man 7 signal</code> 可以查看相关信号信息<ul><li>1 信号的编号<ul><li>使用 <code>kill -l</code> 命令可以查看当前系统有哪些信号，不存在编号为 0 的信号。其中 1-31 号信号称之为常规信号 (也叫普通信号或标准信号)，34-64 称之为实时信号，驱动变成与硬件相关。</li></ul></li><li>信号的名称</li><li>产生信号的事件</li><li>信号的默认处理动作：<ul><li>Term：终止进程</li><li>Ign：忽略信号 (默认即使对该种信号忽略操作)</li><li>Core：终止进程，生成 Core 文件。(查验死亡原因，用于 gdb 调试)</li><li>Stop：停止 (暂停) 进程</li><li>Cont：继续运行进程</li></ul></li></ul></li><li>特别需要注意的是：<code>The signals SIGKILL and SIGSTOP connot be caught, blocked, or ignored.</code></li><li>几个常用到的信号：<br>SIGINT、SIGQUIT、SIGKILL、SIGSEGV、SIGUSR1、SIGUSR2、SIGPIPE、SIGALRM、SIGTERM、SIGCHLD、SIGSTOP、SIGCONT</li></ul><h2 id="信号相关函数"><a href="#信号相关函数" class="headerlink" title="信号相关函数"></a>信号相关函数</h2><h3 id="signal-函数"><a href="#signal-函数" class="headerlink" title="signal 函数"></a>signal 函数</h3><ul><li>函数作用：注册新号捕捉函数</li><li>函数原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*<span class="hljs-type">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">sighandler_t</span> <span class="hljs-title function_">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signul, <span class="hljs-type">sighandler_t</span> handler)</span>;<br></code></pre></td></tr></table></figure></li><li>函数参数：<ul><li>signum：信号编号</li><li>handler：信号处理函数</li></ul></li></ul><h3 id="kill-函数-命令"><a href="#kill-函数-命令" class="headerlink" title="kill 函数&#x2F;命令"></a>kill 函数&#x2F;命令</h3><ul><li>描述：给指定进程发送指定信号</li><li>kill 命令：<code>kill -SIGKILL 进程 PID</code></li><li>kill 函数原型：<code>int kill(pid_t pid, int sig);</code></li><li>函数返回值：<ul><li>成功：0</li><li>失败：-1，设置 errno</li></ul></li><li>函数参数：<ul><li>sig 信号参数：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</li><li>pid 参数：<ul><li>pid &gt; 0：发送信号给指定进程</li><li>pid &#x3D; 0：发送信号给与调用 kill 函数进程属于同一组的所有进程</li><li>pid &lt; -1：取 pid 发给对应进程组</li><li>pid &#x3D; -1：发送给进程有权限发送的系统中所有进程</li></ul></li></ul></li></ul><p>进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们互相关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组 ID 与组长 ID 相同。</p><h3 id="abort-函数-raise-函数"><a href="#abort-函数-raise-函数" class="headerlink" title="abort 函数&#x2F; raise 函数"></a>abort 函数&#x2F; raise 函数</h3><h4 id="raise-函数"><a href="#raise-函数" class="headerlink" title="raise 函数"></a>raise 函数</h4><ul><li>函数描述：给当前进程发送指定信号 (自己给自己发)</li><li>函数原型：<code>int raise(int sig);</code></li><li>函数返回值：成功：0，失败非 0 值</li><li>函数拓展：<code>raise(signo) == kill(getpid(), signo);</code></li></ul><h4 id="abort-函数"><a href="#abort-函数" class="headerlink" title="abort 函数"></a>abort 函数</h4><ul><li>函数描述：给自己发送异常终止信号 (SIGABRT)，并产生 core 文件</li><li>函数原型：<code>void abort();</code></li><li>函数拓展：<code>abort() == kill(getpid(), SIGABRT);</code></li></ul><h3 id="alarm-函数"><a href="#alarm-函数" class="headerlink" title="alarm 函数"></a>alarm 函数</h3><ul><li>函数描述：设置定时器 (闹钟)。在指定 seconds 后，内核会给当前进程发送 SIGALRM 信号。进程收到该信号，默认动作终止。<strong>每个进程都有且只有唯一一个定时器</strong>。</li><li>函数原型：<code>unsigned int alarm(unsigned int seconds);</code></li><li>函数返回值：返回 0 或剩余的秒数，无失败。例如：<br><img src="/2025/03/27/signals/image2.png"></li><li>常用操作：取消定时去 alarm(0)，返回旧闹钟余下秒数。<br> alarm 使用的是自然定时器，与进程状态无关，就绪、运行、挂起 (阻塞、暂停)、终止、僵尸…无论进程处于何种状态，alarm 都计时。</li></ul><h3 id="setitimer-函数"><a href="#setitimer-函数" class="headerlink" title="setitimer 函数"></a>setitimer 函数</h3><ul><li>函数原型：<code>int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);</code></li><li>函数描述：设置定时器去 (闹钟)，可替代 alarm 函数，精度微秒 us，可以实现周期定时</li><li>函数返回值：<ul><li>成功：0</li><li>失败：-1，设置 errno</li></ul></li><li>函数参数：<ul><li>which：指定定时方式<ul><li>自然定时：ITIMER_REAL -&gt; SIGALRM 计算自然时间</li><li>虚拟空间计时 (用户空间)：ITIMER_VIRTUAL -&gt; SIGVTALRM 只计算进程占用 cpu 时间</li><li>运行时即使 (用户 + 内核)：ITIMER_PROF -&gt; SIGPROF 计算占用 cpu 及执行系统调用时间</li></ul></li><li>new_value：struct itimerval，负责设定 timeout 时间<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">itimerval</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timerval</span> <span class="hljs-title">it_interval</span>;</span> <span class="hljs-comment">// 闹钟触发周期</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timerval</span> <span class="hljs-title">it_value</span>;</span>   <span class="hljs-comment">// 闹钟触发时间</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timerval</span> &#123;</span><br>    <span class="hljs-type">long</span> tv_sec;    <span class="hljs-comment">// 秒</span><br>    <span class="hljs-type">long</span> tv_usec;   <span class="hljs-comment">// 微秒</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li>old_value：存放旧的 timeout 值，一般指定为 NULL</li></ul></li></ul><h2 id="信号集相关"><a href="#信号集相关" class="headerlink" title="信号集相关"></a>信号集相关</h2><h3 id="未决信号集和阻塞信号集得关系"><a href="#未决信号集和阻塞信号集得关系" class="headerlink" title="未决信号集和阻塞信号集得关系"></a>未决信号集和阻塞信号集得关系</h3><p>阻塞信号集是当前进程要阻塞的信号的集合，未决信号集是当前进程中还处于未决状态的信号的集合，这两个集合存储在内核的 PCB 中。</p><ul><li>下面以 SIGINT 为例说明未决信号集和阻塞信号集的关系：<br>当进程收到一个 SIGINT (信号编号为2) 信号，首先这个信号灰保存在未决信号集合中，此时对应的 2 号编号的这个位置上置为 1，表示处于未决状态；在这个信号需要被处理之前首先要在阻塞信号集中的编号为 2 的位置上去检查该值是否为 1：<ul><li>如果为 1，表示 SIGINT 信号被当前进程阻塞了，这个信号暂时不被处理，所以未决信号集上该位置上的值保持为 1，表示该信号处于未决状态；</li><li>如果为 0，表示 SIGINT 信号没有被当前进程阻塞，这个信号需要被处理，内核会对 SIGINT 信号进程处理 (执行默认动作，忽略或者执行用户自定义的信号处理函数)，并将未决信号集中编号为 2 的位置上将 1 变为 0，表示该信号已经处理了，这个时间非常短暂，用户感知不到。</li></ul></li></ul><p>当 SIGINT 信号从阻塞信号集中接触阻塞之后，该信号就会被处理。<br><img src="/2025/03/27/signals/image3.png"></p><h3 id="信号集相关函数"><a href="#信号集相关函数" class="headerlink" title="信号集相关函数"></a>信号集相关函数</h3><p>由于信号集属于内核的一块区域，用户不能直接操作内核空间，为此，内核提供了一些信号集相关的接口函数，使用这些函数用户就可以完成对于信号集的相关操作。</p><p>信号集是一个能表示多个信号的数据类型，<code>sigset_t set</code>，set 即一个信号集。既然是一个集合，就需要对集合进行添加、删除等操作。</p><p>sigset_t 类型的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">__sigset_t</span> <span class="hljs-type">sigset_t</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int)))</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> __val[_SIGSET_NWORDS];<br>&#125; <span class="hljs-type">__sigset_t</span>;<br></code></pre></td></tr></table></figure><h4 id="信号集相关函数-1"><a href="#信号集相关函数-1" class="headerlink" title="信号集相关函数"></a>信号集相关函数</h4><ul><li><code>int sigemptyset(sigset_t *set);</code> <br> 函数说明：将某个信号清 0 <br> 函数返回值：成功：0，失败：-1，设置 errno</li><li><code>int sigfillset(sigset_t *set);</code> <br> 函数说明：将某个信号集置 1 <br> 函数返回值：成功：0，失败：-1，设置 errno</li><li><code>int sigaddset(sigset_t *set, int signum);</code> <br> 函数说明：将某个信号加入信号集中 <br> 函数返回值：成功：0，失败：-1，设置 errno</li><li><code>int sigdelset(sigset_t *set, int signum);</code> <br> 函数说明：将某个信号从信号集中清除 <br> 函数返回值：成功：0，失败：-1，设置 errno</li><li><code>int sigismember(const sigset_t *set, int signum);</code> <br> 函数说明：判断某个信号是否在信号集中 <br> 函数返回值：在：1；不在：0；出错：-1，设置 errno</li><li>sigprocmask 函数<ul><li>函数说明：用来屏蔽信号、接触屏蔽也是用该函数。其本质，读取或修改进程控制块中的信号屏蔽字 (阻塞信号集)。<br> <strong>特别注意，屏蔽信号只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢弃处理。</strong></li><li>函数原型：<code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</code></li><li>函数返回值：成功：0；失败：-1，设置 errno</li><li>函数参数：<ul><li>how 参数取值：假设当前的信号屏蔽字为 mask<ul><li>SIG_BLOCK：当 how 这只为此，set 表示需要屏蔽的信号。相当于 mask &#x3D; mask | let</li><li>SIG_UNBLOCK：当 how 设置为此，set 表示需要解除屏蔽的信号。相当于 mask &#x3D; mask &amp; ~set;</li><li>SIG_SETMASK：当 how 设置为此，set 表示用于替代原始屏蔽集的额新屏蔽集。相当于 mask &#x3D; set 若，调用 sigprocmask 解除了对当前若干个信号的阻塞，则在 sigprocmask 返回前，至少将其中一个信号递达。</li></ul></li><li>set：传入参数，是一个自定义信号集合。由参数 how 来指示如何修改当前信号屏蔽字。</li><li>oldset：传出参数，保存旧的信号屏蔽字。</li></ul></li></ul></li><li>sigpending 函数<ul><li>函数原型：<code>int sigpending(sigset_t *set);</code></li><li>函数说明：读取当前进程的未决信号集</li><li>函数参数：set 传出参数</li><li>函数返回值：成功：0；失败：-1，设置 errno</li></ul></li></ul><h2 id="信号捕捉函数"><a href="#信号捕捉函数" class="headerlink" title="信号捕捉函数"></a>信号捕捉函数</h2><ul><li>signal 函数</li><li>sigaction 函数<ul><li>函数说明：注册一个信号处理函数</li><li>函数原型：<code>int sigaction(int signum, const struct sigaction *act, struct sigaction* oldact);</code></li><li>函数参数：<ul><li>signum：捕捉信号</li><li>act：传入参数，新的处理方式</li><li>oldact：传出参数，旧的处理方式</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> &#123;</span><br>  <span class="hljs-type">void</span> (*sa_handler)(<span class="hljs-type">int</span>);  <span class="hljs-comment">// 信号处理函数</span><br>  <span class="hljs-type">void</span> (*sa_sigaction)(<span class="hljs-type">int</span>, <span class="hljs-type">siginfo_t</span> *, <span class="hljs-type">void</span> *); <span class="hljs-comment">// 信号处理函数</span><br>  <span class="hljs-type">sigset_t</span> sa_mask; <span class="hljs-comment">// 信号处理函数执行期间需要阻塞的信号</span><br>  <span class="hljs-type">int</span> sa_flags; <span class="hljs-comment">// 通常为 0，表示使用默认表示</span><br>  <span class="hljs-type">void</span> (*sa_restore)(<span class="hljs-type">void</span>);<br>&#125;;<br></code></pre></td></tr></table></figure></li><li>总结：<ul><li>sa_handler：指定信号捕捉后的处理函数名 (既注册函数)。也可复制为 SIG_IGN 表忽略或 SIG_DFL 表执行默认动作。</li><li>sa_mask：用来指定在信号处理函数执行期间需要被屏蔽的信号，特别是当某个信号被处理时，它自身会被自动放入进程的信号掩码，因此在信号处理函数执行期间这个信号不会再度发生。注意：仅在处理函数被调用期间屏蔽生效，是临时性设置。</li><li>sa_flags：通常设置为 0，使用默认属性。</li><li>sa_restore：已不再使用</li></ul></li><li>知识点：<ul><li>在 XXX 信号处理函数执行期间，XXX 信号是被阻塞的，如果该信号产生了多次，在 XXX 信号处理函数结束之后，该 XXX 信号只被处理一次。</li><li>在 XXX 信号处理函数执行期间，如果阻塞了 YYY 信号，若 YYY 信号产生了多次，当 XXX 信号处理函数结束后，YYY 信号只会被处理一次。</li></ul></li><li>内核实现信号捕捉过程 <br> 如果信号的处理动作是用户自定义函数，在信号递达时旧调用这个函数，这称为捕捉信号，由于信号处理函数的代码是在用户空间的，处理过程比较复杂，距离如下：<ol><li>用户程序注册了 SIGQUIT 信号的处理函数 sighandler</li><li>当前正在执行 main 函数，这时发生中断或异常切换到内核态</li><li>在终端处理完毕后要返回用户态的 main 函数之前检查到有信号 SIGQUIT 递达</li><li>内核决定返回用户态后不是恢复 main 函数的上下文继续执行，而是执行 sighandler 函数，sighandler 和 main 函数使用不同的堆栈空间，他们之间不存在调用和被调用的关系，是两个独立的控制流程，</li><li>sighandler 函数返回后自动执行特殊的系统调用 sigreturn 再次进入内核态</li><li>如果没有新的信号要递达，这次再返回用户态就是恢复 main 函数的上下文继续执行了。</li></ol></li></ul></li></ul><p><img src="/2025/03/27/signals/image4.png"></p><h2 id="SIGCHLD-信号"><a href="#SIGCHLD-信号" class="headerlink" title="SIGCHLD 信号"></a>SIGCHLD 信号</h2><h3 id="产生-SIGCHLD-信号的条件"><a href="#产生-SIGCHLD-信号的条件" class="headerlink" title="产生 SIGCHLD 信号的条件"></a>产生 SIGCHLD 信号的条件</h3><ul><li>子进程结束的时候</li><li>子进程收到 SIGSTOP 信号</li><li>当子进程停止时，收到 SIGCONT 信号</li></ul><h3 id="SIGCHLD-信号的作用"><a href="#SIGCHLD-信号的作用" class="headerlink" title="SIGCHLD 信号的作用"></a>SIGCHLD 信号的作用</h3><p>子进程推出后，内核会给它的父进程发送 SIGCHLD 信号，父进程收到这个信号后可以对子进程进行回收</p><p>使用 SIGCHLD 信号完成对子进程的回收可以避免父进程阻塞等待而不能执行其他操作，只有当父进程收到 SIGCHLD 信号之后采取调用信号捕捉函数完成对子进程的回收，未收到 SIGCHLD 信号之前可以处理其他操作。</p><h3 id="使用-SIGCHLD-信号完成对子进程的回收"><a href="#使用-SIGCHLD-信号完成对子进程的回收" class="headerlink" title="使用 SIGCHLD 信号完成对子进程的回收"></a>使用 SIGCHLD 信号完成对子进程的回收</h3><h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><ul><li>有可能未完成信号处理函数的注册，子进程都退出了<ul><li>解决办法：可以在 fork 之前先将 SIGCHLD 信号阻塞，当完成信号处理函数的注册而后再解除阻塞</li></ul></li><li>当 SIGCHLD 信号函数处理期间，SIGCHLD 信号若再次产生是被阻塞的，而且若产生了多次，则该信号只会被处理一次，这样可能会产生僵尸进程。<ul><li>解决办法：可以在信号处理函数里面使用 while(1) 循环回收，这样就有可能出现不过一次 SIGCHLD 信号但是回收了多个子进程的情况，从而避免僵尸进程的产生。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程间通信</title>
    <link href="/2025/03/26/process-communicate/"/>
    <url>/2025/03/26/process-communicate/</url>
    
    <content type="html"><![CDATA[<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h2 id="进程间通信相关概念"><a href="#进程间通信相关概念" class="headerlink" title="进程间通信相关概念"></a>进程间通信相关概念</h2><h3 id="什么是进程间通信"><a href="#什么是进程间通信" class="headerlink" title="什么是进程间通信"></a>什么是进程间通信</h3><p>Linux 环境下，进程地址空间相互独立，每个进程各自由不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核种开辟一块缓冲区，进程 1 把数据从用户空间拷贝到内核缓冲区，进程 2 再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信 (IPC，InterProcess Communication)。</p><p><img src="/2025/03/26/process-communicate/image1.png"></p><h3 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h3><p>在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用，现今常用的进程间通信方式有：</p><ul><li>管道 (使用最简单)</li><li>信号 (开销最小)</li><li>共享映射区 (无血缘关系)</li><li>本地套接字 (最稳定)</li></ul><h2 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道 - pipe"></a>管道 - pipe</h2><h3 id="管道的概念"><a href="#管道的概念" class="headerlink" title="管道的概念"></a>管道的概念</h3><p>管道是一种最基本的 IPC 机制，也称匿名管道，应用于有血缘关系的进程之间，完成数据传递。调用 pipe 函数即可创建一个管道。</p><p><img src="/2025/03/26/process-communicate/image2.png"></p><p>有如下特质：</p><ul><li>管道的本质是一块内核缓冲区</li><li>由两个文件描述符引用，一个表示读端，一个表示写端</li><li>规定数据从管道的写端流入管道，从读端流出。</li><li>当两个进程都终结的时候，管道也自动消失</li><li>管道的读端和写端默认都是阻塞的。</li></ul><h3 id="管道的原理"><a href="#管道的原理" class="headerlink" title="管道的原理"></a>管道的原理</h3><ul><li>管道的实质是内核缓冲区，内部使用环形队列实现。</li><li>默认缓冲区大小为 4K，可以使用 <code>ulimit -a</code> 命令获取大小</li><li>实际操作过程中缓冲区会根据数据压力做适当调整</li></ul><h3 id="管道的局限性"><a href="#管道的局限性" class="headerlink" title="管道的局限性"></a>管道的局限性</h3><ul><li>数据一旦被读走，便不在管道中存在，不可反复读取</li><li>数据只能在一个方向上流动，若要实现双向流动，必须使用两个管道。</li><li>只能在有血缘关系的进程间使用管道。</li></ul><h3 id="创建管道-pipe-函数"><a href="#创建管道-pipe-函数" class="headerlink" title="创建管道 - pipe 函数"></a>创建管道 - pipe 函数</h3><ul><li>函数作用：创建一个管道</li><li>函数原型：<code>int pipe(int fd[2]);</code></li><li>函数参数：若函数调用成功，fd[0] 存放管道的读端，fd[1] 存放管道的写端</li><li>返回值：<ul><li>成功返回 0</li><li>失败返回 -1，并设置 errno 值</li></ul></li></ul><p>函数调用成功返回读端和写端的文件描述符，其中 fd[0] 是读端，fd[1] 是写端，向管道读写数据是通过使用这两个文件描述符进行的，读写管道的实质是操作内核缓冲区。</p><p>管道创建成功以后，创建该管道的进程 (父进程) 同时掌握着管道的读端和写端。</p><h3 id="父子进程使用管道通信"><a href="#父子进程使用管道通信" class="headerlink" title="父子进程使用管道通信"></a>父子进程使用管道通信</h3><p>一个进程在由 pipe() 创建管道后，一般再 fork 一个子进程，然后通过管道实现父子进程间的通信 (因此也不难推出，只要两个进程种存在血缘关系，这里的血缘关系指的是具有共同的祖先，都可以采用管道方式进行通信)。<strong>父子进程间具有相同的文件描述符，且指向同一个管道 pipe</strong>，其他没有关系的进程不能获取 pipe() 产生的两个文件描述符，也就不能利用同一个管道进行通信。</p><ol><li>父进程创建管道 <br><img src="/2025/03/26/process-communicate/image3.png"></li><li>父进程 fork 处子进程 <br><img src="/2025/03/26/process-communicate/image4.png"></li><li>父进程关闭 fd[0]，子进程关闭 fd[1] <br><img src="/2025/03/26/process-communicate/image5.png"></li></ol><p>关键步骤总结：</p><ul><li>父进程调用 pipe 函数创建管道，得到两个文件描述符 fd[0] 和 fd[1]，分别指向管道的读端和写端</li><li>父进程调用 fork 创建子进程，那么子进程也有两个文件描述符指向同一管道。</li><li>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出，这样就实现了父子进程间通信。</li></ul><h3 id="管道的读写行为"><a href="#管道的读写行为" class="headerlink" title="管道的读写行为"></a>管道的读写行为</h3><ul><li>读操作<ul><li>有数据 <br>read 正常读，返回读出的字节数</li><li>无数据<ul><li>写端全部关闭 <br> read 解除阻塞，返回 0，相当于读文件到了尾部</li><li>没有全部关闭 <br> read 阻塞</li></ul></li></ul></li><li>写操作<ul><li>读端全部关闭 <br> 管道破裂，进程终止，内核给当前进程发 SIGPIPE 信号</li><li>读端没有全部关闭<ul><li>缓冲区写满了 <br> write 阻塞</li><li>缓冲区没有满 <br> 继续 write</li></ul></li></ul></li></ul><h3 id="如何设置管道为非阻塞"><a href="#如何设置管道为非阻塞" class="headerlink" title="如何设置管道为非阻塞"></a>如何设置管道为非阻塞</h3><p>默认情况下，管道的读写两端都是阻塞的，若要设置读或者写为非阻塞，则可参考下列三个步骤：</p><ol><li><code>int flags = fcntl(fd[0], F_GETTL, 0);</code></li><li><code>flags |= O_NONBLOCK;</code></li><li><code>fcntl(fd[0], F_SETFL, flags);</code></li></ol><p>若是读端设置为非阻塞：</p><ul><li>写端没有关闭，管道中没有数据可读，则 read 返回 -1；</li><li>写端没有关闭，<strong>管道中数据可读</strong>，则 read 返回实际读到的字节数</li><li>写端已经关闭，<strong>管道中有数据可读</strong>，则 read 返回实际督导的字节数</li><li>写端已经关闭，管道中没有数据可读，则 read 返回 0</li></ul><h3 id="如何查看管道缓冲区大小"><a href="#如何查看管道缓冲区大小" class="headerlink" title="如何查看管道缓冲区大小"></a>如何查看管道缓冲区大小</h3><ul><li>命令 <br> <code>ulimit -a</code></li><li>函数 <br> <code>long fpathconf(int fd, int name);</code> <br> <code>printf(&quot;pipe size == [%ld]\n&quot;, fd[0], _PC_PIPE_BUF);</code> <br> <code>printf(&quot;pipe size == [%ld]\n&quot;, fd[1], _PC_PIPE_BUF);</code></li></ul><h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><h3 id="FIFO-介绍"><a href="#FIFO-介绍" class="headerlink" title="FIFO 介绍"></a>FIFO 介绍</h3><p><strong>FIFO 常被称为命名管道</strong>，以区分管道 (pipe)。管道 (pipe) 只能用于 “有血缘关系”的进程间通信。<strong>但通过 FIFO，不相关的进程也能交换数据</strong>。</p><p>FIFO 是 Linux <strong>基础文件类星</strong>中的一种 (<strong>文件类型为 p</strong>，可通过 ls -l 查看文件类型)。但 FIFO 文件在磁盘上没有数据块，文件大小为 0，仅仅用来表示内核中一条通道。进程间可以打开这个文件进行 read&#x2F;write，实际上是在读写内核缓冲区，这样就实现了进程间通信。</p><h3 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h3><ul><li>方式1 - 使用命令 mkfifo <br> 命令格式：mkfifo 管道名 <br> 例如：<code>mkfifo myfifo</code></li><li>方式2 - 使用函数 <br> <code>int mkfifo(const char* pathname, mode_t mode);</code> <br> 参数说明和返回值可以查看 <code>man 3 mkfifo</code></li></ul><p>当创建了一个 FIFO，就可以使用 open 函数打开它，常见的文件 I&#x2F;O 函数都可用于 FIFO。如：close、read、write、unlink 等。</p><p>FIFO 严格遵循先进先出 (first in first out)，对 FIFO 的读总是从开始处返回数据，对他们的写则把数据添加到末尾。<strong>它们不支持诸如 lseek() 等文件定位操作。</strong></p><h3 id="使用-FIFO-完成两个进程通信"><a href="#使用-FIFO-完成两个进程通信" class="headerlink" title="使用 FIFO 完成两个进程通信"></a>使用 FIFO 完成两个进程通信</h3><p><img src="/2025/03/26/process-communicate/image6.png" alt="使用 FIFO 完成两个进程通信示意图"></p><p>思路：</p><ul><li>进程 A：<ul><li>创建一个 fifo 文件：myfifo</li><li>调用 open 函数打开 myfifo 文件</li><li>调用 write 函数写入一个字符串如： “hello world” (其实就是将数据写入到内核缓冲区) </li><li>调用 close 函数关闭 myfifo 文件</li></ul></li><li>进程 B：<ul><li>调用 open 函数打开 myfifo 文件</li><li>调用 read 函数读取文件内容 (其实就是从内核中读取数据)</li><li>打印显示读取内容</li><li>调用 close 函数关闭 myfifo 文件</li></ul></li></ul><h2 id="内存映射区"><a href="#内存映射区" class="headerlink" title="内存映射区"></a>内存映射区</h2><h3 id="存储映射区介绍"><a href="#存储映射区介绍" class="headerlink" title="存储映射区介绍"></a>存储映射区介绍</h3><p>存储映射 I&#x2F;O (Memory-mapped I&#x2F;O) 使一个磁盘文件与存储空间中的一个缓冲区像映射。从缓冲区中取数据，就相当于读文件中的相应字节；将数据写入缓冲区，则会将数据写入文件。这样，就可在不使用 read 和 write 函数的情况下，使用地址 (指针) 完成 I&#x2F;O 操作。</p><p>使用存储映射这种方法，首先应通知内核，将一个指定文件映射到存储区域中，这个映射工作可以通过 mmap 函数来实现。</p><p><img src="/2025/03/26/process-communicate/image7.png"></p><h3 id="mmap-函数"><a href="#mmap-函数" class="headerlink" title="mmap 函数"></a>mmap 函数</h3><ul><li>函数作用：建立存储映射区</li><li>函数原型：<code>void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);</code></li><li>函数返回值：<ul><li>成功：返回创建的映射区首地址</li><li>失败：MAP_FAILED 、宏</li></ul></li><li>参数：<ul><li>addr：指定映射的起始地址，通常设为 NULL，由系统指定</li><li>length：映射到内存的额文件长度</li><li>prot：映射区的保护方式，最常用：<ul><li>读：PROT_READ</li><li>写：PROT_WRITE</li><li>读写：PROT_READ | PROT_WRITE</li></ul></li><li>flags：映射区的特性，可以是<ul><li>MAP_SHARED：写入映射区的数据会写回文件，且允许其他映射该文件的进程共享</li><li>MAP_PRIVATE：对映射区的写入操作会产生一个映射区的复制 (copy-on-write)，对此区域所做的修改不会写回原文件</li></ul></li><li>fd：由 open 返回的文件描述符，代表要映射的文件。</li><li>offset：以文件开始处的偏移量，<strong>必须是 4K 的正数倍</strong>，通常为 0，表示从文件头开始映射</li></ul></li></ul><h3 id="munmap-函数"><a href="#munmap-函数" class="headerlink" title="munmap 函数"></a>munmap 函数</h3><ul><li>函数作用：释放由 mmap 函数建立的存储映射区</li><li>函数原型：<code>int munmap(void *addr, size_t length)</code></li><li>返回值：<ul><li>成功：返回 0</li><li>失败：返回 -1，设置 errno 值</li></ul></li><li>函数参数：<ul><li>addr：调用 mmap 函数成功返回的映射区首地址</li><li>length：映射区大小 (mmap 函数的第二个参数)</li></ul></li></ul><h3 id="mmap-注意事项"><a href="#mmap-注意事项" class="headerlink" title="mmap 注意事项"></a>mmap 注意事项</h3><ul><li>创建映射区的过程中，隐含着一次对映射文件的读操作，将文件内容读取到映射区</li><li>当 MAP_SHARED 时，要求：映射区的权限应 &lt;&#x3D; 文件打开的权限 (出于对映射区的保护)。而 MAP_PRIVATE 则不所谓，因为 mmap 中的权限是对内存的限制。</li><li>映射区的释放与文件关闭无关，只要映射建立成功，文件可以立即关闭。</li><li>特别注意，当映射文件大小为 0 时，不能创建映射区。所以，用于映射的文件必须要有实际大小；mmap 使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。</li><li>munmap 传入的地址一定是 mmap 的返回地址。坚决杜绝指针 ++ 操作</li><li>文件偏移量必须为 0 或者 4K 的整数倍</li><li>mmap 创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</li></ul><h3 id="有关-mmap-函数的使用总结"><a href="#有关-mmap-函数的使用总结" class="headerlink" title="有关 mmap 函数的使用总结"></a>有关 mmap 函数的使用总结</h3><ul><li>第一个参数写成 NULL</li><li>第二个参数要映射的文件大小 &gt; 0</li><li>第三个参数：PROT_READ、PROT_WRITE</li><li>第四个参数：MAP_SHARED 或者 MAP_PRIVATE</li><li>第五个参数：打开的文件对应的文件描述符</li><li>第六个参数：4k 的正数倍</li></ul><p>使用 mmap 函数建立匿名映射：<br><code>mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</code></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程控制</title>
    <link href="/2025/03/25/process-control/"/>
    <url>/2025/03/25/process-control/</url>
    
    <content type="html"><![CDATA[<h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><h2 id="进程相关概念"><a href="#进程相关概念" class="headerlink" title="进程相关概念"></a>进程相关概念</h2><h3 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h3><ul><li>程序，是指编译好的二进制文件，在磁盘上，占用磁盘空间，是一个静态概念</li><li>进程，一个启动的程序，进程占用的是系统资源，如：物理内存，CPU，终端等，是一个动态的概念</li><li>程序 -&gt; 剧本(纸)</li><li>进程 -&gt; 戏(舞台、演员、灯光、道具……)</li></ul><p>同一个剧本可以在多个舞台同时上演。同样，一个程序也可以加载为不同的进程(彼此之间互不影响)</p><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><ul><li><p>并发，在一个短时间内，是在同一个 CPU 上，同时运行多个程序</p><p>如：若将 CPU 的 1S 的时间分成 1000 个时间片，每个进程执行完一个时间片必须无条件让出 CPU 的使用权，这样 1S 中就可以执行 1000 个进程。</p><p><img src="/2025/03/25/process-control/image1.png"></p><p><img src="/2025/03/25/process-control/image2.png"></p><p><img src="/2025/03/25/process-control/image3.png"></p><p><img src="/2025/03/25/process-control/image4.png"></p></li><li><p>并行是指两个或两个以上的程序在同一时刻发生(需要有多颗CPU核心)</p><p><img src="/2025/03/25/process-control/image5.png"></p><p><img src="/2025/03/25/process-control/image6.png"></p></li></ul><h3 id="PCB-进程控制块"><a href="#PCB-进程控制块" class="headerlink" title="PCB - 进程控制块"></a>PCB - 进程控制块</h3><p>每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。以下为常用成员：</p><ul><li>进程 id。系统中每个进程有唯一的 id，在 C 语言中用 pid_t 类型表示，其实就是一个非负整数。</li><li>进程的状态，有就绪、运行、挂起、停止等状态。</li><li>进程切换时需要保存和回复的一些 CPU 寄存器。</li><li>描述虚拟地址空间的信息。</li><li>描述控制终端的信息。</li><li>当前工作目睹 (Current Working Directory)<ul><li>getcwd –pwd</li></ul></li><li>umask 掩码</li><li>文件描述符，包含很多指向 file 结构体的指针</li><li>和信号相关的信息</li><li>用户 id 和组 id</li><li>会话 (Session) 和进程组</li><li>进程可以使用的资源上限 (Resource Limit)<ul><li>ulimit -a</li></ul></li></ul><h3 id="进程状态-面试考"><a href="#进程状态-面试考" class="headerlink" title="进程状态 (面试考)"></a>进程状态 (面试考)</h3><p>进程基本的状态有 5 种。分别为初始态、就绪态、运行态、挂起态与终止态。其中初始态为进程准备阶段，常与就绪太结合来看。</p><p><img src="/2025/03/25/process-control/image7.png"></p><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><h3 id="fork-函数"><a href="#fork-函数" class="headerlink" title="fork 函数"></a>fork 函数</h3><ul><li><p>函数作用：创建子进程</p></li><li><p>原型：<code>pit_t fort();</code></p></li><li><p>函数参数：无</p></li><li><p>返回值：</p><ul><li>调用成功：父进程返回子进程的 PID，子进程返回 0；</li><li>调用失败：返回 -1，设置 errno 值。</li></ul></li><li><p>fork 函数代码片段实例</p><p><img src="/2025/03/25/process-control/image8.png"></p></li><li><p>调用 fork 函数的内核实现原理：</p><p><img src="/2025/03/25/process-control/image9.png"></p></li><li><p>fork 函数总结</p><ul><li><p>fork 函数的返回值：</p><p>父进程返回子进程的 PID，是一个大于 0 的数；<br> 子进程返回0；<br> 特别需要注意的是：不是 fork 函数在一个进程种返回 2 个值，二十在父子进程各自返回一个值。</p></li><li><p>子进程创建成功后，代码的执行位置：</p><p>父进程执行到什么位置，子进程就从哪里执行</p></li><li><p>如何区分父子进程：</p><p>通过 fork 函数的返回值</p></li><li><p>父子进程的执行顺序</p><p>不一定，哪个进程先抢到 CPU，哪个进程就先执行</p></li><li><p>父子进程不能共享全局变量；</p><p>但是如果父子进程只是对全局变量做读操作，则步子进程在内存种只有一份，属于共享，但是如果父子进程中的任何一个进程对该变量做修改操作；会在内存种拷贝一个副本没然后在这个副本上进行修改，修改完成后再映射回去。</p></li></ul></li></ul><h3 id="ps-命令和kill-命令"><a href="#ps-命令和kill-命令" class="headerlink" title="ps 命令和kill 命令"></a>ps 命令和kill 命令</h3><ul><li><code>ps aux | grep &quot;xxx&quot;</code></li><li><code>ps ajx | grep &quot;xxx&quot;</code><ul><li>-a：(all) 当前系统所有用户的进程</li><li>-u：查看进程所有者以及其他信息</li><li>-x：显示没有控制终端的进程 – 不能与用户进行交互的进程 [输入、输出]</li><li>-j：列出与作业控制相关的信息</li></ul></li><li><code>kill -l</code> 查看系统有哪些信号</li><li><code>kill -9 pid</code> 杀死某个线程</li></ul><h3 id="getpid-getppid"><a href="#getpid-getppid" class="headerlink" title="getpid &#x2F; getppid"></a>getpid &#x2F; getppid</h3><ul><li><p>getpid - 得到当前进程的 PID</p><p><code>pid_t getpid();</code></p></li><li><p>getppid - 得到当前进程的父进程的 PID</p><p><code>pid_t getppid();</code></p></li></ul><h2 id="exec-函数族"><a href="#exec-函数族" class="headerlink" title="exec 函数族"></a>exec 函数族</h2><h3 id="函数作用和函数介绍"><a href="#函数作用和函数介绍" class="headerlink" title="函数作用和函数介绍"></a>函数作用和函数介绍</h3><p>有时候需要再一个进程里面执行其他的命令或者是用户自定义的应用程序，此时就用到了 exec 函数族当中的函数。</p><p>使用方法一般都是再父进程里面调用 fork 创建处子进程，然后在子进程里面 调用 exec 函数。</p><h3 id="execl-函数"><a href="#execl-函数" class="headerlink" title="execl 函数"></a>execl 函数</h3><ul><li>函数原型：<code>int execl(const char *pathname, const char *arg, .../* (char  *) NULL */);</code></li><li>参数介绍：<ul><li>path：要执行的程序的绝对路径</li><li>变参 arg：要执行的程序的需要的参数</li><li>arg：占位，通常写应用程序的名字</li><li>arg 后面的：命令的额参数</li><li>参数写完之后：NULL</li></ul></li><li>返回值：<ul><li>若是成功，则不反悔，不会再执行 exec 函数后面的代码；</li><li>若是失败：会执行 execl 后面的代码，可以用 perror 打印错误原因。</li></ul></li></ul><p>execl 函数一般执行自己写的程序。</p><h3 id="execlp-函数"><a href="#execlp-函数" class="headerlink" title="execlp 函数"></a>execlp 函数</h3><ul><li>函数原型：<code>int execlp(const char *file, const char *arg, .../* (char  *) NULL */);</code></li><li>参数介绍：<ul><li>file：执行命令的名字，根据 PATH 环境变量来搜索该命令</li><li>arg：占位</li><li>arg 后面的：命令参数</li><li>参数写完之后：NULL</li></ul></li><li>返回值：<ul><li>若是成功，则不反悔，不会再执行 exec 函数后面的代码；</li><li>若是失败：会执行 execl 后面的代码，可以用 perror 打印错误原因。</li></ul></li></ul><p>execlp 函数一般是执行系统自带的程序或者命令。</p><h3 id="exec-函数族原理介绍"><a href="#exec-函数族原理介绍" class="headerlink" title="exec 函数族原理介绍"></a>exec 函数族原理介绍</h3><p>exec 族函数的实现原理图：</p><p>如：<code>execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL);</code></p><p><img src="/2025/03/25/process-control/image10.png"></p><p>总结：<br><br>exec 函数是用一个新程序替换了当前进程的代码段、数据段、堆和栈；原有的进程空间没有发生变化，并没有创建新的进程，进程的 PID 没有发生变化。</p><p>注意：当 execl 和 execlp 函数执行成功后，不返回，并且不会执行 execl 后面的代码逻辑，原因是调用 execl 函数成功以后，exec 函数指定的代码段已经将原有的代码段替换了。</p><h2 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h2><h3 id="为什么要进行进程资源回收"><a href="#为什么要进行进程资源回收" class="headerlink" title="为什么要进行进程资源回收"></a>为什么要进行进程资源回收</h3><p>当一个进程推出之后，进程能够回收自己的用户区资源，但是不能回收内核空间的 PCB 资源，必须由它的父进程调用 wait 或者 waitpid 函数完成对子进程的回收，避免造成系统资源的浪费。</p><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><ul><li>孤儿进程的额概念：<br>若子进程的父进程已经死掉，而子进程还存活者，这个进程就成了孤儿进程。</li><li>为了保证每个进程都有一个父进程，孤儿进程会被 init 进程领养，init 进程成为了孤儿进程的养父进程，当孤儿进程退出之后，由 init 进程完成对孤儿进程的回收。</li></ul><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><ul><li>僵尸进程的概念：<br> 若子进程死了，父进程还活着，但是父进程没有调用 wait 或 waitpid函数完成对子进程的回收，则该子进程就成了僵尸进程。</li><li>如何解决僵尸进程：<ul><li>由于僵尸进程是一个已经死亡的进程，所以不能使用 kill 命令将其杀死</li><li>通过杀死其父进程的方法可以消除僵尸进程。<br>杀死其父进程后，这个僵尸进程会被 init 进程领养，由 init 进程完成对僵尸进程的回收</li></ul></li></ul><h3 id="进程回收函数"><a href="#进程回收函数" class="headerlink" title="进程回收函数"></a>进程回收函数</h3><h4 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait 函数"></a>wait 函数</h4><ul><li>函数原型：<code>pid_t wait(int* status);</code></li><li>函数作用：<ul><li>阻塞并等待子进程退出</li><li>回收子进程残留资源</li><li>获取子进程结束状态 (退出原因)</li></ul></li><li>返回值：<ul><li>成功：清理掉的子进程 ID</li><li>失败：-1 (没有子进程)</li></ul></li><li>status 参数：子进程的退出状态 – 传出参数<ul><li>WIFEXITED(status)：为非 0  -&gt; 进程正常结束 <br> WEXITSTATUS(status)：获取进程退出状态</li><li>WIFSIGNALED(status)：为非 0  -&gt; 进程异常终止 <br> WTERMSIG(status)：取得进程终止的信号编号</li></ul></li></ul><h4 id="waitpid-函数"><a href="#waitpid-函数" class="headerlink" title="waitpid 函数"></a>waitpid 函数</h4><ul><li>函数原型：<code>pid_t waitpid(pid_t pid, int *wstatus, int options);</code></li><li>函数作用：同 wait 函数</li><li>函数参数：<ul><li>pid：<ul><li>pid &#x3D; -1 等待任一子进程。与 wait 等效。</li><li>pid &gt; 0 等到其进程 ID 与 pid 相等的子进程</li><li>pid &#x3D; 0 等待进程组 ID 与目前进程相同的任何子进程，也就是说任何和调用 waitpid 函数的进程在同一个进程组的进程。</li><li>pid &lt; -1 等待其组 ID 等于 pid 的绝对值的任一子进程。(适用于子进程在其他组的情况)</li></ul></li><li>status：子进程的退出装，用法同 wait 函数</li><li>options：设置为 WNOHANG，函数非阻塞，设置为 0，函数阻塞。</li></ul></li><li>函数返回值：<ul><li>&gt;0：返回回收掉的子进程 ID；</li><li>-1：无子进程</li><li>&#x3D;0：参 3 为 WNOHANG，且子进程正在运行。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件IO</title>
    <link href="/2025/03/21/file-io/"/>
    <url>/2025/03/21/file-io/</url>
    
    <content type="html"><![CDATA[<h1 id="文件-IO"><a href="#文件-IO" class="headerlink" title="文件 IO"></a>文件 IO</h1><h2 id="C-库-IO-函数的工作流程"><a href="#C-库-IO-函数的工作流程" class="headerlink" title="C 库 IO 函数的工作流程"></a>C 库 IO 函数的工作流程</h2><p><img src="/2025/03/21/file-io/c_library_io_function_workflow1.png"></p><p><img src="/2025/03/21/file-io/c_library_io_function_workflow2.png"></p><p>c 语言操作文件相关问题：</p><p>使用 fopen 函数打开一个文件，返回一个 FILE* fp，这个指针指向的结构体有三个重要的成员。</p><ul><li>文件描述符：通过文件描述符可以找到文件的 inode，通过 inode 可以找到对应的数据块</li><li>文件指针：读和写共享一个文件指针，读或者写都会引起文件指针的变化。</li><li>文件缓冲区：读或者写会先通过文件缓冲区，主要目的是为了减少对磁盘的读写次数，提高读写磁盘的效率。</li></ul><p>备注：</p><ul><li>头文件 stdio.h 的第 48 行处：<code>typedef struct_IO_FILE FILE</code>;</li><li>头文件 libio.h 的第 241 行处：<code>struct_IO_FILE</code>，这个接头文件定义中有一个 <code>_fileno_</code>成员，这个就是文件描述符。</li></ul><h2 id="C-库函数与系统函数的关系"><a href="#C-库函数与系统函数的关系" class="headerlink" title="C 库函数与系统函数的关系"></a>C 库函数与系统函数的关系</h2><p><img src="/2025/03/21/file-io/c_function_with_system_function.png"></p><p>系统调用：由操作系统实现并提供给外部应用程序的编程接口，(Application Programming Interfact, API)，是应用程序与系统之间数据交互的桥梁。</p><h2 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h2><p><img src="/2025/03/21/file-io/virtual_address.png"></p><p>进程的虚拟地址空间分为用户区和内核区，其中内核区是受保护的，用户是不能够对其进行读写操作的。</p><p>内核区中很重要的一个就是进程管理，进程管理中有一个区域就是 PCB(本质是一个结构体)。</p><p>PCB 中有文件描述符表，文件描述符表中存放着打开的文件描述符，涉及到文件的 IO 操作都会用到这个文件描述符。</p><h2 id="PCB-和文件描述符表"><a href="#PCB-和文件描述符表" class="headerlink" title="PCB 和文件描述符表"></a>PCB 和文件描述符表</h2><p><img src="/2025/03/21/file-io/pdb_and_file_descriptor_table.png"></p><p>备注：</p><p>pcb：结构体：<code>task_struct</code>，该结构体在：<code>/usr/src/linux-headers-4.4.0-97/include/linux/sched.h:1390</code></p><p>一个进程有一个文件描述符表：1024</p><ul><li>前三个被占用，分别是<code>STDIN_FILENO</code>，<code>STDOUT_FILENO</code>，<code>STDERR_FILENO</code></li><li>文件描述符作用：通过文件描述符找到 inode，通过 inode 找到磁盘数据块</li></ul><p>虚拟地址空间 -&gt; 内核区 -&gt; PCB -&gt; 文件描述符表 -&gt; 文件描述符 -&gt; 文件 IO 操作使用文件描述符</p><h2 id="open-close"><a href="#open-close" class="headerlink" title="open&#x2F;close"></a>open&#x2F;close</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>一个进程启动之后，默认打开三个文件描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STDIO_FILENO    0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STDOUT_FILENO   1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STDERR_FILENO   2</span><br></code></pre></td></tr></table></figure><p>新打开文件返回文件描述符中未使用的最小文件描述符，调用 open 函数可以打开或创建一个问及那，得到一个文件描述符。</p><h3 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a>open 函数</h3><ul><li>函数描述：打开或者新建一个文件</li><li>函数原型：<ul><li><code>int open(const char* pathname, int flags);</code></li><li><code>int open(const char* pathname, int flags, mode_t mode);</code></li></ul></li><li>函数参数：<ul><li>pathname 参数是要开打或创建的文件名，和 fopen 一样，pathname 既可以是相对路劲也可以是绝对路径</li><li>flags 参数有一系列常数值可供选择，可以同时选择多个常熟用按位或运算连接起来，所以这些常熟的共定义都已 O_ 开头，表示 or。<ul><li>必选项：以下三个常数中必须指定一个，且仅允许指定一个。<ul><li><code>O_RDONLY</code> 只读打开</li><li><code>O_WROBLY</code> 只写打开</li><li><code>O_RDWR</code> 可读可写打开</li></ul></li><li>以下可选项可以同时指定 0 个或多个，和必选项按位或起来作为 flags 参数。以下为常用项：<ul><li><code>O_APPEND</code> 表示追加。如果文件已有内容，这次打开文件所写的数据附加到文件的末尾而不是覆盖原来的内容。</li><li><code>O_CERAT</code> 若此文件不存在则创建它。使用此选项时需要提供第三个参数 mode，表示该文件的访问权限。<ul><li>文件最终权限：<code>mode&amp;~umask</code></li></ul></li><li><code>O_EXCL</code> 如果同时指定了 O_CREAT，并且文件已存在，则出错返回</li><li><code>O_TRUNC</code> 如果文件已存在，将其长度截断为 0 字节</li><li><code>O_NONBLOCK</code> 对于设备文件，以 O_NONBLOCK 方式打开可以做非阻塞 I&#x2F;O(Nonblock I&#x2F;O)</li></ul></li></ul></li></ul></li><li>函数返回值：<ul><li>成功：返回一个最小且未被占用的文件描述符</li><li>失败：返回 -1，并设置 errno 值</li></ul></li></ul><h3 id="close-函数"><a href="#close-函数" class="headerlink" title="close 函数"></a>close 函数</h3><ul><li>函数描述：关闭文件</li><li>函数原型：<code>int close(int fd);</code></li><li>函数参数：fd 文件描述符</li><li>函数返回值：<ul><li>成功返回 0</li><li>失败返回 -1，并设置 errno 值</li></ul></li></ul><p>需要说明的是，当一个进程终止时，内核对该进程所有尚未关闭的文件描述符调用 close 关闭，所以即使用户程序不调用 close，在终止时也会自动关闭它打开的所有文件。但是对于一个长年累月云心过的程序（比如网络服务器），打开的文件描述符一定要记得关闭，否则随着打开的文件越来越多，会占用大量文件描述符和系统资源。</p><h2 id="read-write"><a href="#read-write" class="headerlink" title="read&#x2F;write"></a>read&#x2F;write</h2><h3 id="read-函数"><a href="#read-函数" class="headerlink" title="read 函数"></a>read 函数</h3><ul><li>函数描述：从打开的设备或文件中读取数据</li><li>函数原型：<code>ssize_t read(int fd, void *buf, size_t count);</code></li><li>函数参数：<ul><li>fd：文件描述符</li><li>buf：读上来的数据保存在缓冲区 buf 中</li><li>count：buf 缓冲区存放的最大字节数</li></ul></li><li>函数返回值<ul><li>&gt;0：读取到的字节数</li><li>&#x3D;0：文件读取完毕</li><li>-1：出错，并设置 errno</li></ul></li></ul><h3 id="write-函数"><a href="#write-函数" class="headerlink" title="write 函数"></a>write 函数</h3><ul><li>函数描述：向打开的设备或文件中写数据</li><li>函数原型：<code> ssize_t write(int fd, const void *buf, size_t count);</code></li><li>函数参数：<ul><li>fd：文件描述符</li><li>buf：缓冲区，要写入文件或设备的数据</li><li>count：buf 中数据的长度</li></ul></li><li>函数返回值：<ul><li>成功：返回写入的字节数</li><li>错误：返回 -1 并设置 errno</li></ul></li></ul><h2 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h2><p>所有打开的文件都有一个当前文件偏移量(current file offset)，一下简称为 cfo。cfo通常是一个非负整数，用于表明文件开始处到文件当前位置的字节数。读写操作通常开始于 cfo，并且使 cfo 增大，增量为读写的字节数，文件被打开时，cfo 会被初始化为 0，除非使用了 O_APPEND。</p><p>使用 lseek 函数可以改变文件的 cfo。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">off_t</span> <span class="hljs-title function_">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset, <span class="hljs-type">int</span> whence)</span>;<br></code></pre></td></tr></table></figure><ul><li>函数描述：移动文件指针</li><li>函数原型：<code>off_t lseek(int fd, off_t offset, int whence);</code></li><li>函数参数：<ul><li>fd：文件描述符</li><li>参数 offset的含义取决于参数 whence<ul><li>如果 whence 是 SEEK_SET，文件偏移量将设置为 offset</li><li>如果 whence 是 SEEK_CUR，文件偏移量将被设置为 cfo 加上 offset，offset 可以为正也可以为负</li><li>如果 whence 是 SEEK_END，文件偏移量将被设置为文件长度加上 offset，offset 可以为正也可以为负</li></ul></li></ul></li><li>函数返回值：若 lseek 成功执行，则返回新的偏移量</li><li>lseek 函数常用操作：<ul><li>文件指针移动到头部：<code>lseek(fd, 0, SEEK_SET)</code></li><li>获取文件指针当前位置：<code>int len = lseek(fd, 0, SEEK_CUR)</code></li><li>获取文件长度：<code>int len = lseek(fd, 0, SEEK_END)</code></li><li>lseek 实现文件拓展：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 从文件尾部开始向后拓展 1000 个字节</span><br><span class="hljs-type">off_t</span> curpos = lseek(fd, <span class="hljs-number">1000</span>, SEEK_END);<br><span class="hljs-comment">// 额外执行一次写操作，否则文件无法完成拓展</span><br>write(fd, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="perror-和-errno"><a href="#perror-和-errno" class="headerlink" title="perror 和 errno"></a>perror 和 errno</h2><p>errno 是一个全局变量，当系统调用后出错将会将 errno 进行设置，perror 可以将 errno 对应的描述信息打印出来。</p><p>如：<code>perror(&quot;open&quot;)</code>；如果报错的话打印：open：错误信息</p><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><ul><li>普通文件：hello.c<ul><li>默认是非阻塞的</li></ul></li><li>终端设备：如 &#x2F;dev&#x2F;tty<ul><li>默认阻塞</li></ul></li><li>管道和套接字<ul><li>默认阻塞</li></ul></li></ul><h2 id="文件操作相关函数"><a href="#文件操作相关函数" class="headerlink" title="文件操作相关函数"></a>文件操作相关函数</h2><h3 id="stat-lstate-函数"><a href="#stat-lstate-函数" class="headerlink" title="stat&#x2F;lstate 函数"></a>stat&#x2F;lstate 函数</h3><ul><li>函数描述：获取文件属性</li><li>函数原型：<code>int stat(const char* pathname, struct stat* buf);</code><br><code>int lstat(const char* pathname, struct stat* buf);</code></li><li>函数返回值：<ul><li>成功返回 0</li><li>失败返回 -1</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> &#123;</span><br>  <span class="hljs-type">dev_t</span>     st_dev;       <span class="hljs-comment">// 文件的谁被编号</span><br>  <span class="hljs-type">ino_t</span>     st_ino;       <span class="hljs-comment">// 节点</span><br>  <span class="hljs-type">mode_t</span>    st_mode;      <span class="hljs-comment">// 文件的类型和存取权限</span><br>  <span class="hljs-type">nlink_t</span>   st_nlink;     <span class="hljs-comment">// 连到该文件的硬链接数目，刚建立的文件值为 1</span><br>  <span class="hljs-type">uid_t</span>     st_uid;       <span class="hljs-comment">// 用户 ID</span><br>  <span class="hljs-type">gid_t</span>     st_gid;       <span class="hljs-comment">// 组 ID</span><br>  <span class="hljs-type">dev_t</span>     st_rdev       <span class="hljs-comment">// (设备类型)若此文件为设备文件，则为设备编号</span><br>  <span class="hljs-type">off_t</span>     st_size       <span class="hljs-comment">// 文件字节数(文件大小)</span><br>  <span class="hljs-type">blksize_t</span> st_blksize;   <span class="hljs-comment">// 块大小(文件系统的 I/O 缓冲区大小)</span><br>  <span class="hljs-type">blkcnt_t</span>  st_blocks;    <span class="hljs-comment">// 块数</span><br>  <span class="hljs-type">time_t</span>    st_atime;     <span class="hljs-comment">// 最后一次访问时间</span><br>  <span class="hljs-type">time_t</span>    st_mtine;     <span class="hljs-comment">// 最后一次修改时间</span><br>  <span class="hljs-type">time_t</span>    st_ctime;     <span class="hljs-comment">// 最后一次改变时间(指属性)</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>st_mode</code> – 16 位整数<ul><li><p>0 - 2 bit – 其他人权限</p><ul><li><code>S_IROTH</code> 00004 读权限</li><li><code>S_IWOTH</code> 00002 写权限</li><li><code>S_IXOTH</code> 00001 执行权限</li><li><code>S_IRWXO</code> 00007 掩码，过滤 st_mode 中除其他人权限以外的信息</li></ul></li><li><p>3 - 5 bit – 所属组权限</p><ul><li><code>S_IRGRP</code> 00004 读权限</li><li><code>S_IWGRP</code> 00002 写权限</li><li><code>S_IXGRP</code> 00001 执行权限</li><li><code>S_IRWXG</code> 00007 掩码，过滤 st_mode 中除其他人权限以外的信息</li></ul></li><li><p>6 - 8 bit – 文件所有者权限</p><ul><li><code>S_IRUSR</code> 00004 读权限</li><li><code>S_IWUSR</code> 00002 写权限</li><li><code>S_IXUSR</code> 00001 执行权限</li><li><code>S_IRWXU</code> 00007 掩码，过滤 st_mode 中除其他人权限以外的信息</li><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (st_mode &amp; S_IRUSR) ---- 为真表明可读<br><span class="hljs-keyword">if</span> (st_mode &amp; S_IWUSR) ---- 为真表明可写<br><span class="hljs-keyword">if</span> (st_mode &amp; S_IXUSR) ---- 为真表明可执行<br></code></pre></td></tr></table></figure></li></ul></li><li><p>12 - 15 bit – 文件类型</p><ul><li>S_IFSOCK    0140000 套接字</li><li>S_IFLNK     0120000 符号链接(软链接)</li><li>S_IFREG     0100000 普通文件</li><li>S_IFBLK     0060000 块设备</li><li>S_IFDIR     0040000 目录</li><li>S_IFCHR     0020000 字符设备</li><li>S_IFIFO     0010000 管道</li><li>S_IFMT      0170000 掩码，过滤 st_mode 中除文件类以外的信息</li><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((st_mode &amp; S_IFMT) == S_IFREG) -- 为真普通文件<br><span class="hljs-keyword">if</span> (S_ISREG(st_mode)) ---- 为真表示普通文件<br><span class="hljs-keyword">if</span> (S_ISDIR(st_mode)) ---- 为真表示目录文件<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>stat 函数 和 lstat 函数的区别：</p><ul><li>对于普通文件，这两个函数没有区别，是一样的。</li><li>而对于链接文件，调用 lstat 函数获取的是链接文本本身的属性信息；而 stat 函数获取的是链接文件指向的文件的属性信息。</li></ul><h2 id="目录操作相关函数"><a href="#目录操作相关函数" class="headerlink" title="目录操作相关函数"></a>目录操作相关函数</h2><h3 id="opendir-函数"><a href="#opendir-函数" class="headerlink" title="opendir 函数"></a>opendir 函数</h3><ul><li>函数描述：打开一个目录</li><li>函数原型：<code>DIR* opendir(const char* name);</code></li><li>函数返回值：指向目录的指针</li><li>函数参数：要便利的目录(相对路径或者绝对路径)</li></ul><h3 id="readdir-函数"><a href="#readdir-函数" class="headerlink" title="readdir 函数"></a>readdir 函数</h3><ul><li>函数描述：读取目录内容 – 目录项</li><li>函数原型：<code>struct dirent* readdir(DIR* dirp);</code></li><li>函数返回值：读取的目录项指针</li><li>函数参数：opendir 函数的返回值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> &#123;</span><br>  <span class="hljs-type">ino_t</span>             d_ino;        <span class="hljs-comment">// 此目录进入点的 inode</span><br>  <span class="hljs-type">off_t</span>             d_off;        <span class="hljs-comment">// 目录文件开头至此目录进入点的位移</span><br>  <span class="hljs-type">signed</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span>  d_reclen;     <span class="hljs-comment">// d_name 的长度，不包含 NULL 字符</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>     d_type;       <span class="hljs-comment">// d_name 所指的文件类型</span><br>  <span class="hljs-type">char</span>              d_name[<span class="hljs-number">256</span>];  <span class="hljs-comment">// 文件名</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>d_type 的取值：</p><ul><li>DT_BLK - 块设备</li><li>DT_CHR - 字符设备</li><li>DT_DIR - 目录</li><li>DT_LNK - 软链接</li><li>DT_FIFO - 管道</li><li>DT_REG - 普通文件</li><li>DT_SOCK - 套接字</li><li>DT_UNKNOWN - 未知</li></ul><p><img src="/2025/03/21/file-io/directory.png"></p><h3 id="closedir-函数"><a href="#closedir-函数" class="headerlink" title="closedir 函数"></a>closedir 函数</h3><ul><li>函数描述：关闭目录</li><li>函数原型：<code>int closedir(DIR* dirp);</code></li><li>函数返回值：成功返回 0，失败返回 -1</li><li>函数参数：opendir 函数的返回值</li></ul><h3 id="读取目录内容过的一般步骤"><a href="#读取目录内容过的一般步骤" class="headerlink" title="读取目录内容过的一般步骤"></a>读取目录内容过的一般步骤</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">DIR* pDir = opendir(<span class="hljs-string">&quot;dir&quot;</span>) <span class="hljs-comment">// 1. 打开目录</span><br><span class="hljs-keyword">while</span> ((p == readdir(pDir)) != <span class="hljs-literal">NULL</span>) &#123;&#125; <span class="hljs-comment">// 2. 循环读取文件</span><br>closedir(pDir) <span class="hljs-comment">// 3. 关闭目录</span><br></code></pre></td></tr></table></figure><h2 id="dup-dup2-fcntl"><a href="#dup-dup2-fcntl" class="headerlink" title="dup &#x2F; dup2 &#x2F; fcntl"></a>dup &#x2F; dup2 &#x2F; fcntl</h2><p><img src="/2025/03/21/file-io/dup_dup2.png"></p><h3 id="dup-函数"><a href="#dup-函数" class="headerlink" title="dup 函数"></a>dup 函数</h3><ul><li>函数描述：复制文件描述符</li><li>函数原型：<code>int dup(int oldfd);</code></li><li>函数参数：oldfd - 要复制的文件描述符</li><li>函数返回值<ul><li>成功：返回最小且没被占用的文件描述符</li><li>失败：返回 -1，设置 errno 值</li></ul></li></ul><h3 id="dup2-函数"><a href="#dup2-函数" class="headerlink" title="dup2 函数"></a>dup2 函数</h3><ul><li>函数描述：复制文件描述符</li><li>函数原型：<code>int dup2(int oldfd, int newfd);</code></li><li>函数参数：<ul><li>oldfd - 原来的文件描述符</li><li>newfd - 复制成功的新的文件描述符</li></ul></li><li>函数返回值：<ul><li>成功：将 oldfd 复制给 newfd，两个文件描述符指向同一个文件</li><li>失败：返回 -1，设置 errno 值</li></ul></li><li>假设 newfd 已经指向了一个文件，首先 close 原来打开的文件，然后 newfd 指向 oldfd 指向的文件。<br>若 newfd 没有被占用，newfd 指向 oldfd 指向的文件</li></ul><p><img src="/2025/03/21/file-io/dup_dup2_function_principal.png"></p><h3 id="fcntl-函数"><a href="#fcntl-函数" class="headerlink" title="fcntl 函数"></a>fcntl 函数</h3><ul><li>函数描述：改变已经打开的文件的属性</li><li>函数原型：<code>int fcntl(int fd, int cmd, ... /* arg */ );</code><ul><li>若 cmd 为 F_DUPFD，复制文件描述符，与 dup 相同</li><li>若 cmd 为 F_GETFL，获取文件描述符的 flag 属性值</li><li>若 cmd 为 F_SETFL，设置文件描述符的 flag 属性</li></ul></li><li>函数返回值：返回值取决于 cmd<ul><li>成功：<ul><li>若 cmd 为 F_DUPFD，返回一个新的文件描述符</li><li>若 cmd 为 F_GETFL，返回文件描述的 flags 值</li><li>若 cmd 为 F_SETFL，返回 0</li></ul></li><li>失败返回 -1，并设置 errno 值</li></ul></li><li>fcntl 函数常用的操作：<ol><li>复制一个新的文件描述符 <br> <code>int newfd = fcntl(fd, F_DUPFD, 0);</code> </li><li>获取文件的属性标志 <br> <code>int flag = fcntl(fd, F_GETFL, 0);</code></li><li>设置文件状态标志 <br> <code>flag = flag | O_APPEND;</code> <br> <code>fcntl(fd, F_SETFL, flag);</code></li><li>常用的属性标志：<ul><li>O_APPEND —- 设置文件打开为末尾添加</li><li>O_NONBLOCK —- 设置打开的文件描述符为非阻塞</li></ul></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gdb调试</title>
    <link href="/2025/03/07/gdb-debug/"/>
    <url>/2025/03/07/gdb-debug/</url>
    
    <content type="html"><![CDATA[<h1 id="gdb-调试"><a href="#gdb-调试" class="headerlink" title="gdb 调试"></a>gdb 调试</h1><h2 id="gdb-介绍"><a href="#gdb-介绍" class="headerlink" title="gdb 介绍"></a>gdb 介绍</h2><p>GBD (DBU Debugger) 是 GCC 的调试工具。其功能强大，现描述如下：</p><p>GDB 主要帮忙你完成下面四个方面的功能：</p><ul><li>启动程序，可以按照你的自定义的要求随心所欲的运行程序。</li><li>可让被调试的程序在你所指的断点处听出。(断点可以是条件表达式)</li><li>当程序被停住时，可以检查此时你的程序中所发生的事。</li><li>动态的改变你程序的执行环境。</li></ul><h2 id="生成调试信息"><a href="#生成调试信息" class="headerlink" title="生成调试信息"></a>生成调试信息</h2><p>一般来说 GDB 主要调试的是 C&#x2F;C++ 的程序。要调试 C&#x2F;C++ 的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器 (cc&#x2F;gcc&#x2F;g++) 的 -g 参数可以做到这一点。如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -<span class="hljs-selector-tag">g</span> hello<span class="hljs-selector-class">.c</span> -o hello<br></code></pre></td></tr></table></figure><p>如果没有 -g，你将看不到程序的函数名、变量名，所代替的全是运行时的内存地址。当你用 -g 把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用 gbd 调试它。</p><h2 id="启动-gdb"><a href="#启动-gdb" class="headerlink" title="启动 gdb"></a>启动 gdb</h2><ul><li><p>启动 gdb：<code>gdb program</code></p><ul><li>program 也就是你的大执行文件，一般在当前目录下。</li></ul></li><li><p>设置运行参数</p><ul><li><code>set args</code> 可以指定运行时参数。(如：set args 10 20 30 40 50)</li><li><code>show args</code> 命令可以查看设置好的运行参数</li></ul></li><li><p>启动程序</p><ul><li><code>run</code>：程序开始执行，如果有断电，停在第一个断点处</li><li><code>start</code>：程序向下执行一行。(在第一条语句处停止)</li></ul></li></ul><h2 id="显示源代码"><a href="#显示源代码" class="headerlink" title="显示源代码"></a>显示源代码</h2><p>GBD 可以打印出所调试程序的源代码，当然，在程序编译时一定要加上 -g 参数，把源程序信息编译到执行文件中华。不然就看不到源程序了。当程序停下来后，GDB 会报告程序停在了哪个文件的第几行上。你可以用 list 命令来打印程序的源代码，默认打印 10 行，list命令的用法如下所示：</p><ul><li><code>list linenum</code>：打印第 linenum 行的上下文内容</li><li><code>list function</code>：显示函数名为 function 的函数的源程序</li><li><code>list</code>：显示当前行后面的源程序</li><li><code>list -</code>：显示当前文件开始处的源程序</li><li><code>list file:linenum</code>：显示 file 文件下第 linenum 行</li><li><code>list file:function</code>：显示 file 文件的函数名为 function 的函数的源程序</li></ul><p>一般时打印当前行上 5 行和下 5 行，如果显示函数时上 2 行下 8 行，默认是 10 行，当然，你也可以定制显示范围，使用下面命令可以设置一次显示源程序的行数。</p><ul><li><code>set listsize count</code>：设置一次显示源代码的行数</li><li><code>show listsize</code>：查看当前 listsize 的设置</li></ul><h2 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h2><h3 id="简单断点-–-当前文件"><a href="#简单断点-–-当前文件" class="headerlink" title="简单断点 – 当前文件"></a>简单断点 – 当前文件</h3><ul><li>break 设置断点，可以简写为 b<ul><li><code>b 10</code>设置断点，在源程序第 10 行</li><li><code>b func</code>设置断点，在 func 函数入口处</li></ul></li></ul><h3 id="多文件设置断点-–-其他文件"><a href="#多文件设置断点-–-其他文件" class="headerlink" title="多文件设置断点 – 其他文件"></a>多文件设置断点 – 其他文件</h3><ul><li><p>在进入指定函数时停住：</p><ul><li><code>b filename:linenum</code> – 在源文件 filename 的 linenum 行处停住</li><li><code>b filename:function</code> – 在源文件 filename 的 function 函数的入口处停住</li></ul></li><li><p>查询所有断点</p><ul><li><code>info b == info break == i break == i b</code></li></ul></li><li><p>条件断点</p><p>  一般来说，为断点设置一个条件，我们使用 if 关键字，后面跟其断点条件。设置一个条件断点：</p><ul><li><code>b test.c:8 if intValue == 5</code></li></ul></li><li><p>维护断点</p><ul><li><p><code>delete [range...]</code>删除指定的断点，其简写命令为 d。</p><ul><li>如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围<ul><li>删除某个断点：<code>delete num</code></li><li>删除多个断点：<code>delete num1 num2</code></li><li>删除连续多个断点：<code>delete m-n</code></li><li>删除所有断点：<code>delete</code></li></ul></li><li>比删除更高的一种方法是 disable 停止点，disable 了的停止点，GDB 不会删除，当你还需要时，enable 即可，就好像回收站一样。</li></ul></li><li><p><code>disable/enable [range...]</code> 使指定断点无效，简写命令使 dis&#x2F;ena。</p><p>如果什么都不指定，表示 diable 所有的停止点。</p><ul><li>使一个断点无效&#x2F;有效：<code>disable/enable num</code></li><li>使多个断点无效&#x2F;有效：<code>disable/enable num1 num2</code></li><li>使多个连续的断点无效&#x2F;有效：<code>disbale/enable m-n</code></li><li>使所有断点无效&#x2F;有效:<code>disable/enable</code></li></ul></li></ul></li></ul><h2 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h2><ul><li><code>run</code> 运行程序，可简写为 r</li><li><code>next</code> 单步跟踪，函数调用当作一条简单执行语句执行，可简写为 n</li><li><code>step</code> 单步跟踪，函数调用会进入被调用函数体内，可简写为 s</li><li><code>finish</code> 退出进入的函数，如果出不去，看一下函数体中的循环中是否由断点，如果有删掉，或者设置无效。</li><li><code>until</code> 在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体，可简写为 u，如果出不去，看一下函数体中的循环中是否由断点，如果有删掉，或者设置无效。</li><li><code>continue</code> 继续运行程序，可简写为 c (若有断点，则跳到下一个断点处)</li></ul><h2 id="查看变量的值"><a href="#查看变量的值" class="headerlink" title="查看变量的值"></a>查看变量的值</h2><h3 id="查看运行时变量的值"><a href="#查看运行时变量的值" class="headerlink" title="查看运行时变量的值"></a>查看运行时变量的值</h3><p>print 打印变量、字符串、表达式等的值，可简写为 p</p><ul><li><code>p count</code> —- 打印 count 的值</li></ul><h3 id="自动显示变量的值"><a href="#自动显示变量的值" class="headerlink" title="自动显示变量的值"></a>自动显示变量的值</h3><p>你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的 GDB 命令时 display。</p><ul><li><code>display 变量名</code></li><li><code>info display</code> – 查看 display 设置的自动显示的信息。</li><li><code>undisplay num</code> (info display 时显示的编号)</li><li><code>delete display dnums...</code> – 删除自动显示，dnums 意为所设置好了的自动显示的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示<ul><li>删除某个自动显示：<code>undisplay num</code> 或者 &#96;&#96;delete display num&#96;</li><li>删除多个: <code>delete display num1 num2</code></li><li>删除一个范围：<code>delete display m-n</code></li></ul></li><li><code>disable/enable display dnums</code><ul><li>使一个自动显示无效&#x2F;有效：<code>disable/enable display num</code></li><li>使多个自动显示无效&#x2F;有效: <code>disable/enable display num1 num2</code></li><li>使一个范围的自动显示无效&#x2F;有效：<code>disable/enable display m-n</code></li></ul></li></ul><h3 id="查看修改变量的值"><a href="#查看修改变量的值" class="headerlink" title="查看修改变量的值"></a>查看修改变量的值</h3><ul><li><code>ptype width</code> – 查看变量 width 的类型<ul><li><code>type == double</code></li></ul></li><li><code>p width</code> – 打印变量 width 的值<ul><li><code>$4 = 13</code></li></ul></li><li>你可以使用 <code>set var</code> 命令来告诉 GDB，width 不是你 GDB 的参数，而是程序的变量名，如：<ul><li><code>set var width = 47</code> – 将变量 var 的值设置为 47</li></ul></li><li>在你改变程序变量取值时，最好都是用 set var 格式的 GDB 命令</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>gcc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>makefile</title>
    <link href="/2025/03/06/makefile/"/>
    <url>/2025/03/06/makefile/</url>
    
    <content type="html"><![CDATA[<h1 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h1><p>makefile 文件中定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile 就像一个 shell 脚本一样，其中也可以执行操作系统的命令。makefile 带来的好处就是 — “自动化编译”，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p><p>make 是一个命令工具，是一个解释 makefile 中指令的命令工具，一般来说，大多数的 IDE 都有这个命令，比如：Visual C++ 的 nmake，Linux 下的 make。可见，makefile 都成为了一种在工程方面的编译方法。</p><p>makefile 文件中会使用 gcc 编译器对源代码进行编译，最终生成可执行文件或者库文件。</p><p>makefile 文件的命名：makefile 或者 Makefile</p><h2 id="makefile-的基本规则"><a href="#makefile-的基本规则" class="headerlink" title="makefile 的基本规则"></a>makefile 的基本规则</h2><p>makefile 由一组规则组成，规则如下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">目标：依赖<br>(<span class="hljs-literal">Tab</span>) 命令<br></code></pre></td></tr></table></figure><p>makefile 基本规则三要素：</p><ul><li>目标：要生成的目标文件</li><li>依赖：目标文件由哪些文件生成</li><li>命令：通过执行该命令由依赖文件生成目标</li></ul><p>下面以具体的例子讲解：</p><p>当前目录下由 main.c fun1.c fun2.c sum.c，根据这个基本规则编写一个简单的 makefile文件，生成可执行文件 main。</p><p>第一个版本的 makefile 文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">main: main.c fun1.c fun2.c sum.c</span><br>gcc -o main main.c fun1.c fun2.c sum.cls <br></code></pre></td></tr></table></figure><p>缺点：效率低，修改一个文件，所有的文件会全部重新编译。</p><h2 id="makfile-工作原理"><a href="#makfile-工作原理" class="headerlink" title="makfile 工作原理"></a>makfile 工作原理</h2><h3 id="基本原则："><a href="#基本原则：" class="headerlink" title="基本原则："></a>基本原则：</h3><p><strong>若想生成目标，检查规则中的所有的依赖文件是否都存在：</strong></p><ul><li><p>如果有的依赖文件不存在，则向下搜索规则，看是否由生成该依赖文件的规则：</p><p>  如果有规则用来生成该依赖文件，则执行规则中的命令生成依赖文件；如果没有规则用来生成该依赖文件，则报错。<br>  <img src="/2025/03/06/makefile/makefile1.png"></p></li><li><p>如果所有依赖都存在，检查规则中的目标是否需要更新，必须先检查它的所有依赖，依赖中有任何一个被更新，则目标必须更新。(检查的规则是哪个时间大，哪个最新)</p><ul><li><p>若目标的时间 &gt; 依赖的时间，不更新</p></li><li><p>若目标的时间 &lt; 依赖的时间，更新</p><p><img src="/2025/03/06/makefile/makefile2.png"></p></li></ul></li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li>分析各个目标和依赖之间的关系</li><li>根据依赖关系自底向上执行命令</li><li>根据依赖文件得到时间和目标文件的时间确定是否需要更新</li><li>如果目标不依赖任何条件，则执行对应命令，以示更新(如：伪目标)</li></ul><p>第二个版本：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">main: main.o fun1.o fun2.o sum.o</span><br>gcc -o main main.o fun1.o fun2.o sum.o<br><br><span class="hljs-section">main.o: main.c</span><br>gcc -c main.c -I./<br><br><span class="hljs-section">fun1.o: fun1.c</span><br>gcc -c fun1.c<br><br><span class="hljs-section">fun2.o: fun2.c</span><br>gcc -c fun2.c<br><br><span class="hljs-section">sum.o: sum.c</span><br>gcc -c sum.c<br></code></pre></td></tr></table></figure><p>缺点：冗余，若 .c 文件数量很多，编写起来比较麻烦</p><h2 id="makefile-中的变量"><a href="#makefile-中的变量" class="headerlink" title="makefile 中的变量"></a>makefile 中的变量</h2><p>在 makefile 中使用变量有点类似于 C 语言中的宏定义，使用该变量相当于内容替换，使用变量可以使 makefile 易于维护，修改起来变得简单。</p><p>makefile 有三种类型的变量：</p><ul><li>普通变量</li><li>自带变量</li><li>自动变量</li></ul><h3 id="普通变量"><a href="#普通变量" class="headerlink" title="普通变量"></a>普通变量</h3><ul><li>变量定义直接用 &#x3D;</li><li>使用变量值用 $(变量名)  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">如：下面是变量的定义和使用：<br>    foo = abc       // 定义变量并赋值<br>    bar = <span class="hljs-variable">$(foo)</span>    // 使用变量<br></code></pre></td></tr></table></figure>  定义了两个变量：foo、bar，其中 bar 的值是 foo 变量值的引用。</li></ul><h3 id="自带变量"><a href="#自带变量" class="headerlink" title="自带变量"></a>自带变量</h3><p>除了用户自定义变量，makefile 中也提供了一些变量(变量名大写)供用户直接使用，我们可以直接对其进行赋值：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CC = gcc <span class="hljs-comment">#arm-linux-gcc</span><br>CPPFLAGS：C 预处理的选项 -I<br>CFLAGS：C 编译器的选项 -Wall -g -c<br>LDFLAGS：链接器的选项 -L -l<br></code></pre></td></tr></table></figure><h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><ul><li>$@：表示规则中的目标</li><li>$&lt;：表示规则中的第一个条件</li><li>$^：表示规则中的所有条件，组成一个列表，以空格隔开，如果这个列表中有重复的项则消除重复项。</li><li>特别注意：自动变量只能在规则的命令中使用</li></ul><h3 id="规则模式"><a href="#规则模式" class="headerlink" title="规则模式"></a>规则模式</h3><p>至少在规则的目标定义中要包含 ‘%’ ，’%’ 表示一个或多个，在以来条件中同样可以使用 ‘%’，依赖条件中的 ‘%’ 的取值却决于其目标：</p><p>比如：main.o : main.c fun1.o : fun1.c fun2.o : fun2.c sum.o : sum.c，说的简单点就是：xxx.o : xxx.c</p><p>makefile 的第三个版本：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">target = main<br>objects = main.o fun1.o fun2.o sum.o<br>CC = gcc<br>CPPFLAGS = -I./<br><br><span class="hljs-variable">$(target)</span> : <span class="hljs-variable">$(objects)</span><br><span class="hljs-variable">$(CC)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><br><br>%.o : %.c<br><span class="hljs-variable">$(CC)</span> -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span> <span class="hljs-variable">$(CPPFLAGS)</span><br></code></pre></td></tr></table></figure><h2 id="makefile-中的函数"><a href="#makefile-中的函数" class="headerlink" title="makefile 中的函数"></a>makefile 中的函数</h2><p>makefile 中的函数有很多，在这里给打架介绍两个最常用的。</p><ol><li><p>wildcard - 查找指定目录下的指定类型的文件</p><p> <code>src = $(wildcard ./*.c)</code>     &#x2F;&#x2F; 找到当前目录下所有后缀为 .c 的文件，赋值给src</p></li><li><p>patsubst - 匹配替换</p><p> <code>obj = $(patsubst %.c,%.o,$(src))</code>    &#x2F;&#x2F; 将 src 中所有后缀为 .c 的文件替换为 .o</p></li></ol><p>在 makefile 中所有的函数都是由返回值的。</p><p>当前目录下由 main.c fun1.c fun2.c sum.c</p><p><code>src = $(wildcard ./*.c)</code> 等价于 src &#x3D; main.c fun1.c fun2.c sum.c</p><p><code>obj = $(patsubst %.c,%.o,$(src))</code> 等价于 obj &#x3D; main.o fun1.o fun2.o sum.o</p><p>makefile 的第四个版本：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile">src = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> ./*.c)</span><br>objects = <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %.o <span class="hljs-variable">$(src)</span>)</span><br>target = main<br>CC = gcc<br>CPPFLAGS = -I./<br><br><span class="hljs-variable">$(target)</span> : <span class="hljs-variable">$(objects)</span><br><span class="hljs-variable">$(CC)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><br><br>%.o : %.c<br><span class="hljs-variable">$(CC)</span> -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span> <span class="hljs-variable">$(CPPFLAGS)</span><br></code></pre></td></tr></table></figure><p>缺点：每次重新编译都需要手工清理中间文件和最终目标文件</p><h2 id="makefile-的清理操作"><a href="#makefile-的清理操作" class="headerlink" title="makefile 的清理操作"></a>makefile 的清理操作</h2><p>用途：清楚编译生成的中间文件和最终目标文件。</p><p>make clean 如果当前目录下由同名 clean 文件，则不执行 clean 对应的命令，解决方案：</p><ul><li><p>伪目标声明：</p><ul><li><code>.PHONY : clean</code></li><li>声明目标为伪目标之后，makefile 将不会检查该目标是否存在或者该目标是否需要更新。</li></ul></li><li><p>clean 命令中的特殊符号：</p><ul><li><p>“-“ 此命令出错，make 也会继续执行后续的命令。如：<code>-rm main.o</code></p><p>rm -f：将之执行，比如若要删除的文件不存在使用 -f 不会报错</p></li></ul></li><li><p>其他：</p><ul><li>make 默认执行第一个出现的目标，可通过 make dest 指定要执行的目标</li><li>make -f：-f执行第一个 makefile 文件名称，使用 make 执行指定的 makefile：make -f mainmak</li></ul></li></ul><p>makefile 的第五个版本：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile">src = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> ./*.c)</span><br>objects = <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %.o, <span class="hljs-variable">$(src)</span>)</span><br>target = main<br>CC = gcc<br>CPPFLAGS = -I./<br><br><span class="hljs-variable">$(target)</span> : <span class="hljs-variable">$(objects)</span><br><span class="hljs-variable">$(CC)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><br><br>%.o : %.c<br><span class="hljs-variable">$(CC)</span> -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span> <span class="hljs-variable">$(CPPFLAGS)</span><br><br>.PHONY : clean<br><span class="hljs-section">clean:</span><br>rm -f <span class="hljs-variable">$(objects)</span> <span class="hljs-variable">$(target)</span><br></code></pre></td></tr></table></figure><p>在 makefile 的第五个版本中，综合使用了变量，函数，规则模式和清理命令，是一个比较完善的版本。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>gcc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态库和共享（动态）库</title>
    <link href="/2025/03/04/lib-and-so/"/>
    <url>/2025/03/04/lib-and-so/</url>
    
    <content type="html"><![CDATA[<h1 id="静态库和共享（动态）库"><a href="#静态库和共享（动态）库" class="headerlink" title="静态库和共享（动态）库"></a>静态库和共享（动态）库</h1><h2 id="库的介绍"><a href="#库的介绍" class="headerlink" title="库的介绍"></a>库的介绍</h2><h3 id="什么是库"><a href="#什么是库" class="headerlink" title="什么是库"></a>什么是库</h3><p>库是二进制文件，是源代码文件的另一种表现形式，是加了密的源代码；是喜喜呃功能相近或者是相似的函数的集合体。</p><h3 id="使用库有什么好处"><a href="#使用库有什么好处" class="headerlink" title="使用库有什么好处"></a>使用库有什么好处</h3><ul><li>提高代码的可重用性，而且还可以提高程序的健壮性；</li><li>可以减少开发者的代码开发量，缩短开发周期。</li></ul><h3 id="库制作完成后，如何给用户使用"><a href="#库制作完成后，如何给用户使用" class="headerlink" title="库制作完成后，如何给用户使用"></a>库制作完成后，如何给用户使用</h3><ul><li>头文件 — 包含了库函数的声明</li><li>库文件 — 包含了库函数的代码实现</li><li>注意：库不能单独使用，只能作为其他执行程序的额一部分完成某些功能，也就是说只能被其他程序调用才能使用。</li><li>库可分静态库(static library)和共享库(shared library)两种。</li></ul><h2 id="静态库-static-library"><a href="#静态库-static-library" class="headerlink" title="静态库(static library)"></a>静态库(static library)</h2><p>静态库可以认为是一些目标代码的集合，是在可执行程序运行前就已经加入到执行码中，成为执行程序的一部分。按照习惯，一般以 .a 作为文件后缀名。</p><p>静态库的命名一般分为三个部分：</p><ul><li>前缀：lib</li><li>库名称：自定义即可，如：test</li><li>后缀：.a</li></ul><p>座椅最终的静态库的名字应该是：libtest.a</p><h3 id="静态库的制作"><a href="#静态库的制作" class="headerlink" title="静态库的制作"></a>静态库的制作</h3><p>下面以 func1.c、func2.c 和 head.h 三个文件为例讲述静态库的制作和使用，其中 head.h 文件中有函数的声明，func1.c 和 func2.c 文件中有函数的实现。</p><p>步骤一：将 c 源文件生成对应的 .o 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -c func1.c func2.c<br></code></pre></td></tr></table></figure><p>步骤二：使用打包工具与 ar 将准备好的 .o 文件打包为 .a 文件</p><ul><li>在使用 ar 工具的时候需要添加参数 rcs<ul><li>r：表示将文件插入（replace）到库中</li><li>c：表示创建（create）库</li><li>s：表示生成索引（symbol）表</li></ul></li><li>命令： ar rcs 静态库名 .o 文件<ul><li><code>ar rcs libtest.a func1.o func2.o</code></li></ul></li></ul><p><img src="/2025/03/04/lib-and-so/static_create.png" alt="创建静态库的过程"></p><h3 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a>静态库的使用</h3><p>静态库制作完成之后，需要将 .a 文件和头文件一定发布给用户。假设测试文件为 main.c，静态库文件为 libtest.a，头文件为 head.h。</p><p>用到的参数：</p><ul><li>-L：指定要链接的库的所在目录</li><li>-l：指定链接时需要的静态库，去掉前缀和后缀</li><li>-I：指定 main.c 文件用到的头文件 head.h 所在的路径</li><li><code>gcc -o main main.c -L./ -ltest -I./</code></li></ul><h3 id="静态库的优缺点"><a href="#静态库的优缺点" class="headerlink" title="静态库的优缺点"></a>静态库的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>库函数最终被打包到应用程序中，实现时函数本地化，寻址方便、速度快。(库函数调用效率 &#x3D;&#x3D; 自定义函数使用效率)</li><li>程序在运行时与函数库再无瓜葛，移植方便。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p>消耗系统资源较大，每个进程使用静态库都要复制一份，无端浪费内存。<br><img src="/2025/03/04/lib-and-so/static_disvantage.png"></p></li><li><p>静态库会给程序更新、部署喝发布带来麻烦。如果静态库 libxxx.a 更新了，所有使用它的程序都需要重新编译、发布给用户(对于用户来说，可能是一个很小的改动，却导致整个程序重新下载)。</p></li></ul><h2 id="共享库-shared-library-动态库"><a href="#共享库-shared-library-动态库" class="headerlink" title="共享库(shared library)&#x2F;动态库"></a>共享库(shared library)&#x2F;动态库</h2><p>共享库在程序编译时并不会被链接到目标代码中，二十在程序运行时才被载入。不容的应用如果调用相同的库，那么在内存里只需要有一份该共享库的拷贝，规避了空间浪费问题。动态库在程序运行时才被载入，也解决了静态库对程序的更行、部署和发布带来的麻烦。用户只需要更新动态库即可，增量更新。为什么需要动态库，其实也是静态库的特点导致的。</p><p>按照习惯，一般以 .so 作为文件后缀名。共享库的命名一般分为三个部分：</p><ul><li>前缀：lib</li><li>库名称：自定义即可，如：test</li><li>后缀：.so</li></ul><p>所以最终的动态库名称应该为：libtest.so</p><p><img src="/2025/03/04/lib-and-so/shared_create.png"></p><h3 id="共享库的制作"><a href="#共享库的制作" class="headerlink" title="共享库的制作"></a>共享库的制作</h3><ol><li><p>生成目标文件 .o，此时要加编译选项：-fPIC(fpic)’</p><p> gcc -fpic -c func1.c func2.c</p><p> 参数：-fpic 创建于地址无关的编译程序(pic，position independent code)，目的就是为了能够在多个应用程序间共享。</p></li><li><p>生成共享库，此时要加链接器选项：-shared(指定生成动态链接库)</p><p>gcc -shared func1.o func2.o -o libtest.so</p></li></ol><h3 id="共享库的使用"><a href="#共享库的使用" class="headerlink" title="共享库的使用"></a>共享库的使用</h3><p>引用动态库编译成可执行文件(跟静态库方式一样)：</p><p>用到的参数：</p><ul><li>-L：指定要链接的库的所在目录</li><li>-l：指定链接时需要的动态库，去掉前缀和后缀</li><li>-I：指定 main.c 文件用到的头文件 head.h 所在的路径</li><li><code>gcc -o main main.c -L./ -ltest -I./</code></li></ul><p>然后运行：.&#x2F;main，发现竟然报错了。<br><img src="/2025/03/04/lib-and-so/shared_error.png"></p><h4 id="分析为什么在执行的时候找不到-libtest-so-库"><a href="#分析为什么在执行的时候找不到-libtest-so-库" class="headerlink" title="分析为什么在执行的时候找不到 libtest.so 库"></a>分析为什么在执行的时候找不到 libtest.so 库</h4><ul><li><p>当系统加载可执行代码的时候，能够知道其所依赖库的名字，但是还需要知道所依赖的库的绝对路径。此时就需要系统动态载入器(dynamic linker&#x2F;loader)。</p><p>ldd 命令可以查看可执行文件依赖的库文件，执行 <code>ldd main</code>，就可发现 libtest.so 找不到<br><img src="/2025/03/04/lib-and-so/ldd_main.png"></p></li><li><p>对于 elf 格式的可执行文件，是由 ld-linux.so* 来完成的，它先后搜索 elf 文件的 DT_RPATH 段 – 环境变量 LD_LIBRARY_PATH – &#x2F;etc&#x2F;ld.so.cache 文件列表 – &#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib&#x2F; 目录找到库文件后将其载入内存。</p><p>使用 file 命令可以查看文件的类型：<code>file main</code><br><img src="/2025/03/04/lib-and-so/file_main.png"></p></li></ul><h3 id="如何让系统找到共享库"><a href="#如何让系统找到共享库" class="headerlink" title="如何让系统找到共享库"></a>如何让系统找到共享库</h3><ul><li>拷贝自己制作的共享库到 &#x2F;lib 或者 &#x2F;usr&#x2F;lib</li><li>临时设置 LD_LIBRARY_PATH：<ul><li><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径</code></li></ul></li><li>永久设置，把 <code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径</code> 设置到 ~&#x2F;.bashrc 文件中，然后在执行下列三种办法之一：<ul><li>执行 <code>. ~/.bashrc</code> 使配置文件生效</li><li>执行 <code>source ~/.bashrc</code> 使配置文件生效</li><li>退出当前终端，然后再次登录也可以使配置文件生效</li></ul></li><li>永久设置，把 <code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径</code> 设置到 &#x2F;etc&#x2F;profile 文件中。</li><li>将其添加到 &#x2F;etc&#x2F;ld.so.cache 文件中<ul><li>编辑 &#x2F;etc&#x2F;ld.so.conf 文件，加入库文件所在的目录的路径</li><li>运行 <code>sudo ldconfig -v</code>，该指令会重建 &#x2F;etc&#x2F;ld.so.cache 文件</li></ul></li></ul><p>解决了库的路径问题之后，再次 ldd 命令可以查看可执行文件依赖的库文件，<code>ldd main</code><br><img src="/2025/03/04/lib-and-so/ldd_main_ok.png"></p><h3 id="共享库的特点"><a href="#共享库的特点" class="headerlink" title="共享库的特点"></a>共享库的特点</h3><ul><li>动态库把对一些库函数的链接载入推迟到程序运行的时期。</li><li>可以实现进程之间的资源共享(因此动态库也称为共享库)。</li><li>将一些程序升级变得简单。</li><li>甚至可以真正做到链接载入完全由程序员在代码中控制(显式调用)。</li></ul><h2 id="比较静态库和动态库的优缺点"><a href="#比较静态库和动态库的优缺点" class="headerlink" title="比较静态库和动态库的优缺点"></a>比较静态库和动态库的优缺点</h2><h3 id="静态库的有点"><a href="#静态库的有点" class="headerlink" title="静态库的有点"></a>静态库的有点</h3><ol><li>执行速度快，是因为静态库已经编译到可执行文件内部了。</li><li>移植方便，不依赖于其他的库文件</li></ol><h3 id="静态库的缺点"><a href="#静态库的缺点" class="headerlink" title="静态库的缺点"></a>静态库的缺点</h3><ol><li>耗费内存，是由于每一个静态库的可执行程序都会加载一次。</li><li>部署更新麻烦，因为静态库修改以后所有的调用到这个静态库的可执行文件都需要重新编译。</li></ol><h3 id="动态库的优点"><a href="#动态库的优点" class="headerlink" title="动态库的优点"></a>动态库的优点</h3><ol><li>节省内存。</li><li>部署升级更新方便，只需替换动态库即可，然后再重启服务。</li></ol><h3 id="动态库的缺点"><a href="#动态库的缺点" class="headerlink" title="动态库的缺点"></a>动态库的缺点</h3><ol><li>加载速度比静态库慢。</li><li>移植性差，需要把所有用到的动态库都移植。</li></ol><p>由于由静态库生成的可执行文件是把静态库加载到了其内部，所以静态库生成的可执行文件一般会比动态库大。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc编译器</title>
    <link href="/2025/03/04/gcc-compiler/"/>
    <url>/2025/03/04/gcc-compiler/</url>
    
    <content type="html"><![CDATA[<h1 id="gcc-编译器"><a href="#gcc-编译器" class="headerlink" title="gcc 编译器"></a>gcc 编译器</h1><h2 id="gcc-的工作流程"><a href="#gcc-的工作流程" class="headerlink" title="gcc 的工作流程"></a>gcc 的工作流程</h2><p>gcc 编译器将 c 源文件到生成一个可执行程序，中间一共经历了四个步骤：<br><img src="/2025/03/04/gcc-compiler/gcc_compile_flow.png"></p><p>四个步骤并不是 gcc 独立完成的，而是在内部调用了其他工具，从而完成了整个工作流程，其中编译最耗时，因为要逐行检查语法。<br><img src="/2025/03/04/gcc-compiler/gcc_tool_chain.png"></p><p>下面以 test.c 为例介绍 gcc 的四个步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -E test.c -o test.i<br>gcc -S test.i -o test.s<br>gcc -c test.s -o test.o<br>gcc test.o -o test<br></code></pre></td></tr></table></figure><p>一步生成最终可执行程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc test.c -o test<br></code></pre></td></tr></table></figure><h2 id="gcc-常用参数"><a href="#gcc-常用参数" class="headerlink" title="gcc 常用参数"></a>gcc 常用参数</h2><ul><li>-v 查看 gcc 版本号， –version 也可以</li><li>-E 生成预处理文件</li><li>-S 生成汇编文件</li><li>-c 只编译，生成 .o 文件，通常称为目标文件</li><li>-I 指定头文件所在的路径</li><li>-L 指定库文件所在的路径</li><li>-l 指定库的名字</li><li>-o 指定生成的目标文件的名字</li><li>-g 包含调试信息，使用 gdb 调试需要添加 -g 参数</li><li>-On n&#x3D;0~3 编译优化，n 越大优化程度越高，但编译时间越长</li></ul><p>例如：下面代码片段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = a;<br><span class="hljs-type">int</span> c = b;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, c);<br></code></pre></td></tr></table></figure><p>上面的代码可能会被编译器优化成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> c = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><ul><li>-Wall 提示更多警告信息</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br><span class="hljs-type">int</span> c = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d]\n&quot;</span>, c);<br></code></pre></td></tr></table></figure><p>编译如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -o test -Wall test.c<br>warning: unused variable &#x27;a&#x27; [-Wunused-variable]<br>warning: unused variable &#x27;b&#x27; [-Wunused-variable]<br></code></pre></td></tr></table></figure><ul><li>-D 编译时定义宏<br>test.c 文件中的代码片段：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max==[%d]&quot;</span>, MAX);<br></code></pre></td></tr></table></figure><p>编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -o test test.c -D MAX=10<br>gcc -o test test.c -DMAX=10<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>gcc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础命令</title>
    <link href="/2025/03/03/linux_base/"/>
    <url>/2025/03/03/linux_base/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h1><h2 id="Shell-相关"><a href="#Shell-相关" class="headerlink" title="Shell 相关"></a>Shell 相关</h2><pre><code class="hljs">概念： Shell就是命令解析器，Shell将用户输入的命令解释成内核能够识别的指令，Shell就相当于翻译。查看当前系统使用的shell:    echo $SHELL查看当前系统支持的shell:    cat /etc/shells</code></pre><h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><pre><code class="hljs">是一个倒立的树状结构。</code></pre><ul><li>&#x2F;bin: binary，二进制文件，可执行程序，shell命令<ul><li>如：ls, rm, mv, cp等常用命令</li></ul></li><li>&#x2F;sbin: s是Super User的意思，这里存放的是系统管理员使用的系统管理程序。<ul><li>如ifconfig, halt, shutdown, reboot等系统命令</li></ul></li><li>&#x2F;dev: device，在linux下一切皆文件<ul><li>硬盘, 显卡, 显示器</li><li>字符设备文件、块设备文件<ul><li>如: 在input目录下执行: sudo cat mouse0, 移动鼠标会显示有输入.</li></ul></li></ul></li><li>&#x2F;lib: linux运行的时候需要加载的一些动态库<ul><li>如: libc.so、libpthread.so等</li></ul></li><li>&#x2F;mnt: 手动的挂载目录, 如U盘等</li><li>&#x2F;media: 外设的自动挂载目录, 如光驱等</li><li>&#x2F;root: linux的超级用户root的家目录</li><li>&#x2F;usr: unix system resource–类似于WINDOWS的programe files目录<ul><li>include目录里存放头文件, 如: stdio.h、stdlib.h、string.h、pthread.h</li><li>games目录下的小游戏-如: sl小火车游戏</li></ul></li><li>&#x2F;etc: 存放配置文件<ul><li>&#x2F;etc&#x2F;passwd<ul><li>man 5 passwd可以查看passwd文件的格式信息</li></ul></li><li>&#x2F;etc&#x2F;group<ul><li>man 5 group可以查看group文件的格式信息</li></ul></li><li>&#x2F;etc&#x2F;profile<ul><li>系统的配置文件, 修改该文件会影响这个系统下面的所有的用户</li></ul></li></ul></li><li>&#x2F;opt: 安装第三方应用程序<ul><li>比如安装oracle数据库可以在这个目录下</li></ul></li><li>&#x2F;home: linux操作系统所有用户的家目录<ul><li>用户家目录：(宿主目录或者主目录)<ul><li>&#x2F;home&#x2F;itcast</li></ul></li></ul></li><li>&#x2F;tmp: 存放临时文件<ul><li>新建在这个目录下的文件会在系统重启后自动清除</li></ul></li></ul><h2 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h2><ul><li>绝对路径: 从&#x2F;目录开始表示的目录.</li><li>相对路径: 从当前目录开始表示的目录.<ul><li>从当前所处的目录开始表示的路径。</li><li>. 表示当前目录</li><li>.. 表示当前目录的上一级目录</li></ul></li></ul><h2 id="文件和目录操作相关的命令"><a href="#文件和目录操作相关的命令" class="headerlink" title="文件和目录操作相关的命令"></a>文件和目录操作相关的命令</h2><h3 id="tree-命令"><a href="#tree-命令" class="headerlink" title="tree 命令"></a>tree 命令</h3><pre><code class="hljs">以树状星蚀查看指定目录内容，使用该命令需要安装软件tree</code></pre><p>命令使用方法：</p><ul><li>tree – 树状结构显示当前目录下的文件信息</li><li>tree 目录 – 树状结构显示指定目录下的文件信息</li></ul><h3 id="ls-命令"><a href="#ls-命令" class="headerlink" title="ls 命令"></a>ls 命令</h3><ul><li>查看指定目录下的文件信息</li><li>使用方法：<ul><li>ls – 显示当前目录下的文件信息</li><li>ls 目录 – 显示指定目录下的文件信息</li></ul></li><li>相关参数<ul><li>-a: 显示所有文件和目录<ul><li>. 当前目录</li><li>.. 当前目录的额上一级目录</li><li>隐藏文件，以 . 开头的文件，如.bashrc</li><li>普通文件</li></ul></li><li>-R: 递归显示指定目录下的文件信息</li><li>-l: 列出文件的详细信息，7部分内容<br><img src="/2025/03/03/linux_base/ls-l.png"></li><li>参数之间可以结合使用：<ul><li>ls -la: 列出当前目录下所有文件的相关信息，包括隐藏文件</li><li>ls -ltr: 列出当前目录下的文件，按照时间你想排序</li></ul></li></ul></li></ul><h3 id="cd-命令"><a href="#cd-命令" class="headerlink" title="cd 命令"></a>cd 命令</h3><pre><code class="hljs">切换目录(change directory)，命令使用方式：cd + 目录路径可以使用相对路径或者绝对路径</code></pre><ul><li>切换到家目录<ul><li>cd</li><li>cd ~</li><li>cd &#x2F;home&#x2F;user_name</li><li>cd $HOME</li></ul></li><li>临近两个目录切换<ul><li>cd -</li></ul></li></ul><h3 id="pwd-命令"><a href="#pwd-命令" class="headerlink" title="pwd 命令"></a>pwd 命令</h3><pre><code class="hljs">查看用户当前所处的工作目录，print working directory</code></pre><h3 id="which-命令"><a href="#which-命令" class="headerlink" title="which 命令"></a>which 命令</h3><pre><code class="hljs">显示命令所在的目录, 如 which ls， which cp</code></pre><h3 id="touch-命令"><a href="#touch-命令" class="headerlink" title="touch 命令"></a>touch 命令</h3><pre><code class="hljs">如果文件不存在，创建新文件，如果文件存在，更新最后修改时间命令使用方式：touch 文件名</code></pre><h3 id="mkdir-命令"><a href="#mkdir-命令" class="headerlink" title="mkdir 命令"></a>mkdir 命令</h3><pre><code class="hljs">创建新目录，make directory创建方式：mkdir 目录名如果创建多级目录需要添加参数 -p：  在当前目录下创建目录： mkdir mydir  在宿主目录下创建多级目录： mkdir -p ~/test/hello/world/aa</code></pre><h3 id="rmdir-命令"><a href="#rmdir-命令" class="headerlink" title="rmdir 命令"></a>rmdir 命令</h3><pre><code class="hljs">删除空目录，只能删除空目录 ，使用方式：rmdir 目录名</code></pre><h3 id="rm-命令"><a href="#rm-命令" class="headerlink" title="rm 命令"></a>rm 命令</h3><ul><li>删除文件： rm 文件名</li><li>删除目录： rm -r 目录名</li><li>参数：<ul><li>-r： 递归删除目录，删除目录碧玺添加此参数</li><li>-i： 提示用户是否删除文件或目录</li><li>-f： 强制删除</li></ul></li><li>注意事项：<ul><li>使用 rm 命令删除的文件或目录不会放入回收站中，数据不易回复。</li></ul></li></ul><h3 id="cp-命令"><a href="#cp-命令" class="headerlink" title="cp 命令"></a>cp 命令</h3><p>命令使用方式： cp 源目录或文件 目标目录或文件</p><p>若有目录的拷贝需要使用 -r 参数</p><ul><li>cp 要拷贝的文件(file1) file(不存在)<ul><li>创建 file，将 file1 中的内容拷贝到 file</li></ul></li><li>cp file1 file(存在)<ul><li>file1 覆盖 file</li></ul></li><li>cp file dir(存在)<ul><li>拷贝 file 到 dir 目录</li></ul></li><li>cp -r dir(存在) dir1(存在)<ul><li>将 dir 目录拷贝到 dir1 目录中</li><li>包括 dir 目录</li></ul></li><li>cp -r dir(存在) dir1(不存在)<ul><li>创建 dir1</li><li>将 dir 目录拷贝到 dir1 中，不包括 dir 目录</li></ul></li><li>cp 拷贝目录也可以用 -a 参数，这样可以保留被拷贝的文件的一些属性信息</li></ul><h3 id="mv-命令"><a href="#mv-命令" class="headerlink" title="mv 命令"></a>mv 命令</h3><ul><li>改名或者移动文件 mv file1 file2<ul><li>改名：<ul><li>mv file(存在) file1(不存在)</li><li>mv dir(存在) dir1(不存在)</li><li>mv file(存在) file1(存在)<ul><li>file 文件覆盖 file1 文件，file 改名为 file1</li></ul></li></ul></li><li>移动(第二个参数一定是目录文件)<ul><li>mv file(文件) dir(存在目录)<ul><li>将 file 文件移动到 dir 中</li></ul></li><li>mv dir(目录) dir1(存在目录)<ul><li>将 dir 目录移动到 dir1 中，dir 就会作为 dir1 的子目录而存在</li></ul></li></ul></li></ul></li></ul><h3 id="cat-命令"><a href="#cat-命令" class="headerlink" title="cat 命令"></a>cat 命令</h3><ul><li>将文件内容一次性输出到终端。</li><li>使用方式： cat 文件名</li><li>缺点：终端显示的内容有限，如果文件太长无法显示全部。</li><li>可用于文件重定向：cat file1 &gt; file2， 相当于 cp file1 file2</li></ul><h3 id="more-命令"><a href="#more-命令" class="headerlink" title="more 命令"></a>more 命令</h3><ul><li>文件内容分页显示到终端，但是智能一直向下浏览，不能回退</li><li>使用方式：more + 文件名</li><li>相关操作：<ul><li>显示下一行：回车</li><li>显示下一页：空格</li><li>退出：q(ctrl + c)</li></ul></li></ul><h3 id="less-命令"><a href="#less-命令" class="headerlink" title="less 命令"></a>less 命令</h3><ul><li>文件内容分页显示到终端，可以上下浏览</li><li>使用方式：less + 文件名</li><li>相关操作：<ul><li>显示下一行：回车、ctrl + p、方向键上</li><li>显示上一行：ctrl + n、方向键下</li><li>显示下一页：空格、PageDown</li><li>显示上一页：PageUp</li><li>退出：q</li></ul></li></ul><h3 id="head-命令"><a href="#head-命令" class="headerlink" title="head 命令"></a>head 命令</h3><ul><li>从文件头部开始查看前 n 行的内容</li><li>使用方式： head -n[行数] 文件名<ul><li>head -20 hello.txt’</li></ul></li><li>如果没有指定行数，默认显示前10行内容</li></ul><h3 id="tail-命令"><a href="#tail-命令" class="headerlink" title="tail 命令"></a>tail 命令</h3><ul><li>从文件尾部向上查看最后 n 行的内容</li><li>使用方式： tail -n[行数] 文件名</li><li>如果未指定行数，默认显示最后10行内容</li><li>一个比较重要的应用：显示日志：<code>tail -f test.log</code>，可以实时显示日志内容，当有新的日志产生时，会自动显示在终端上</li></ul><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><ul><li>软链接类似于 windows 下的快捷方式</li><li>如何创建软链接<ul><li><p>ln -s 文件名 快捷方式的名字</p><p>例如：ln -s aa aa.soft</p></li><li><p>目录也可以创建软链接</p><p>例如：ln -s tmp tmp.link</p></li></ul></li><li>创建软链接应注意事项<ul><li>ln 创建软链接要用绝对路径，因为如果不使用绝对路径，一旦这个链接文件发生位置变动，就不能找到那个文件了。</li><li>软链接文件的大小是：路径 + 文件名的总字节数</li></ul></li></ul><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><ul><li>ln 文件名 硬链接的名字<ul><li>ln test.log test.log.hard</li></ul></li><li>使用硬链接应注意事项<ul><li><p>硬链接不能建立在目录上</p></li><li><p>硬链接对绝对路径没有要求</p></li><li><p>硬链接不能跨文件系统</p><p>硬链接文件和源文件的 inode 是相同的，文件系统的 inode 要求唯一，跨文件系统可能会使 inode不同，所以硬链接不能跨文件系统</p></li></ul></li><li>硬链接的本质<ul><li>硬链接的本质使不同的文件名所在 inode 节点是相同的，相同的 inode 节点指向了相同的数据块，所以它们的文件内容是一样的，文件内容会同步。<ul><li><p>ls -i 文件名 —–&gt; 可以查看文件的 i 节点</p></li><li><p>stat 文件名 —–&gt; 可以查看文件的详细信息，包括 inode 节点</p></li><li><p>如下图，file.hard 是 file 的硬链接，这两个文件指向同一个 inode，同一个 inode 指向了相同的数据块(文件内容)。<br><img src="/2025/03/03/linux_base/hardlink.png"></p><ul><li>当新创建了一个文件，硬链接计数为1</li><li>给文件创建了一个硬链接后，硬链接计数加1</li><li>删除一个硬链接后，硬链接计数减1</li><li>如果删除硬链接后，硬链接技术为0，则该文件会被删除</li></ul></li></ul></li></ul></li><li>硬链接应用场合<ul><li><p>可以起到文件同步的作用</p><p>修改 file 内容，会在其余几个硬链接文件上同步</p></li><li><p>可以起到保护文件的作用</p><p>删除文件的时候，只要硬链接技术不为0，不会真正删除，起到保护文件的作用。</p></li></ul></li></ul><h3 id="wc-命令"><a href="#wc-命令" class="headerlink" title="wc 命令"></a>wc 命令</h3><ul><li>显示文件行数，字节数，单词数<ul><li>wc -l file 显示文件的总行数</li><li>wc -c file 显示文件的总字节数</li><li>wc -w file 显示文件的总单词数</li><li>wc file 显示文件的总行数，总字节数，总单词数</li></ul></li></ul><h3 id="whoami-命令"><a href="#whoami-命令" class="headerlink" title="whoami 命令"></a>whoami 命令</h3><ul><li>显示当前用户名</li></ul><h2 id="用户权限、用户、用户组"><a href="#用户权限、用户、用户组" class="headerlink" title="用户权限、用户、用户组"></a>用户权限、用户、用户组</h2><h3 id="修改文件权限-chmod"><a href="#修改文件权限-chmod" class="headerlink" title="修改文件权限 chmod"></a>修改文件权限 chmod</h3><pre><code class="hljs">linux 是通过权限对文件进行控制的，通过使用 chmod 命令可以修改文件相关的权限</code></pre><ul><li>文字设定法<ul><li>命令：chmod [+|-|&#x3D;] 文件名<ul><li>操作对象 [who]<ul><li>u – 用户(user)</li><li>g – 同组用户(group)</li><li>o – 其他用户(other)</li><li>a – 所有用户(all)</li></ul></li><li>操作符 [+|-|&#x3D;]<ul><li>+ – 添加权限</li><li>- – 删除权限</li><li>&#x3D; – 赋予给定权限并取消其他权限</li></ul></li><li>权限 [mode]<ul><li>r – 读权限</li><li>w – 写权限</li><li>x – 执行权限</li></ul></li></ul></li><li>示例：给文件 file.txt 的所有者和所属组添加读写权限<ul><li>chmod ug+wr file.txt</li></ul></li></ul></li><li>数字设定法<ul><li>命令：chmod [who] [+|-|&#x3D;] 文件名<ul><li>操作符 [+|-|&#x3D;]<ul><li>\ – 添加权限</li><li>- – 删除权限</li><li>&#x3D; – 赋予给定权限并取消其他权限</li></ul></li><li>数字表示的含义<ul><li>0 – 没有权限(-)</li><li>1 – 执行权限(x)</li><li>2 – 写权限(w)</li><li>4 – 读权限(r)</li></ul></li><li>例：给 file.txt 文件设置 rw-rw-r–<ul><li>chmod 664 file.txt</li></ul></li></ul></li></ul></li></ul><p>注意点：使用数字设定发，一定要使用3位的8进制数：如066</p><h3 id="修改文件所有者和所属组"><a href="#修改文件所有者和所属组" class="headerlink" title="修改文件所有者和所属组"></a>修改文件所有者和所属组</h3><ul><li>修改文件所有者 chown<ul><li>用法：chown 文件所有者 文件名<ul><li>sudo chown user file.txt</li></ul></li></ul></li><li>修改文件所有者和所属组 chown<ul><li>用法：chown 文件所有者：文件所属组 文件名<ul><li>sudo chown user:group file.txt</li></ul></li></ul></li><li>注意：普通用户需要使用管理员用户权限执行该命令</li><li>注意：若系统没有其他用法，可以使用 <code>sudo adduser 用户名</code> 创建一个新用户</li></ul><h3 id="修改文件所属组"><a href="#修改文件所属组" class="headerlink" title="修改文件所属组"></a>修改文件所属组</h3><ul><li>chgrp 命令<ul><li>使用方法：chgrp 用户组 文件或目录名<ul><li>示例：修改文件所属组位 group1</li><li>sudo chgrp group1 file.txt</li></ul></li><li>普通用户需要使用管理员用户权限执行该命令</li></ul></li></ul><h2 id="find-命令"><a href="#find-命令" class="headerlink" title="find 命令"></a>find 命令</h2><h3 id="按文件名查询：使用参数-name"><a href="#按文件名查询：使用参数-name" class="headerlink" title="按文件名查询：使用参数 -name"></a>按文件名查询：使用参数 -name</h3><ul><li>命令：find 路径 -name “文件名”</li><li>示例：find &#x2F;home -name “*.c”</li></ul><h3 id="按文件类型查询：使用参数-type"><a href="#按文件类型查询：使用参数-type" class="headerlink" title="按文件类型查询：使用参数 -type"></a>按文件类型查询：使用参数 -type</h3><ul><li>命令：find 路径 -type 类型<ul><li>普通文件类型用 f 表示而不是 -</li><li>d -&gt; 目录</li><li>l -&gt; 符号链接</li><li>b -&gt; 块设备</li><li>c -&gt; 字符设备</li><li>s -&gt; socket 文件</li><li>p -&gt; 管道文件</li></ul></li><li>查找指定目录下的普通文件： find 路径 -type f</li></ul><h3 id="按文件大小查询：使用参数-size"><a href="#按文件大小查询：使用参数-size" class="headerlink" title="按文件大小查询：使用参数 -size"></a>按文件大小查询：使用参数 -size</h3><ul><li>命令：find 路径 -size 范围<ul><li>范围：<ul><li>大于：+ 表示 – +100k</li><li>小于：- 表示 – -100k</li><li>等于：无符号表示 – 100k</li></ul></li><li>大小：<ul><li>M 必须大写(10M)</li><li>k 必须小写(10k)</li><li>c 表示字节数</li></ul></li><li>例子：查询目录为家目录<ul><li>等于 100k 的文件：find ~&#x2F; -size 100k</li><li>大于 100k 的文件：find ~&#x2F; -size +100k</li><li>大于 50k，小于 100k 的文件：find ~&#x2F; -size +50k -size -100k</li></ul></li></ul></li></ul><h3 id="按文件日期"><a href="#按文件日期" class="headerlink" title="按文件日期"></a>按文件日期</h3><ul><li>创建日期：-ctime -n&#x2F;+n</li><li>修改日期：-mtime -n&#x2F;+n</li><li>访问日期：-atime -n&#x2F;+n</li></ul><h3 id="按深度"><a href="#按深度" class="headerlink" title="按深度"></a>按深度</h3><ul><li>maxdepth n(层数)<ul><li>搜索 n 层以下的目录，搜索的层数不超过 n 层</li></ul></li><li>mindepth n(层数)<ul><li>搜索 n 层以上的目录，搜索的层数不能小于 n 层</li></ul></li></ul><h3 id="高级查找"><a href="#高级查找" class="headerlink" title="高级查找"></a>高级查找</h3><ul><li>例：查找指定目录下所有目录，并列出目录中文件详细信息<ul><li>find .&#x2F; -type d -exec shell 命令 {} ;<ul><li>find .&#x2F; -type d -exec ls -l {} ;</li></ul></li><li>find .&#x2F; -type d -ok shell 命令 {} ;<ul><li>find .&#x2F; -type d -ok ls -l {} ;</li></ul></li></ul></li><li>注意：{}中间不能又空格</li><li>ok 比较安全，特别是在执行 rm 删除文件的时候<ul><li>find .&#x2F; -type d | xargs shell 命令<ul><li>find .&#x2F; -type d | xargs ls -l</li></ul></li></ul></li></ul><h2 id="grep-命令"><a href="#grep-命令" class="headerlink" title="grep 命令"></a>grep 命令</h2><h3 id="grep-r-有目录-“查找的内容”-搜索路径"><a href="#grep-r-有目录-“查找的内容”-搜索路径" class="headerlink" title="grep -r(有目录) “查找的内容” 搜索路径"></a>grep -r(有目录) “查找的内容” 搜索路径</h3><ul><li>-r 参数，若是目录，则可以递归搜索</li><li>-n 参数可以显示该查找内容所在的行号</li><li>-i 参数可以忽略大小写进行查找</li><li>-v 参数不显示含有某字符串</li></ul><h3 id="搜索当前目录下包含-hello-world-字符串的文件"><a href="#搜索当前目录下包含-hello-world-字符串的文件" class="headerlink" title="搜索当前目录下包含 hello world 字符串的文件"></a>搜索当前目录下包含 hello world 字符串的文件</h3><ul><li><code>grep -r -n &quot;hello world&quot; ./</code>    —-显示行号</li><li><code>grep -r -n -i &quot;HELLO world&quot; ./</code>    —-忽略大小写查找</li></ul><h2 id="find-和-grep-命令结合使用"><a href="#find-和-grep-命令结合使用" class="headerlink" title="find 和 grep 命令结合使用"></a>find 和 grep 命令结合使用</h2><h3 id="先使用-find-命令查找文件，然后使用-grep-命令查找那些文件包含某个字符串"><a href="#先使用-find-命令查找文件，然后使用-grep-命令查找那些文件包含某个字符串" class="headerlink" title="先使用 find 命令查找文件，然后使用 grep 命令查找那些文件包含某个字符串"></a>先使用 find 命令查找文件，然后使用 grep 命令查找那些文件包含某个字符串</h3><ul><li>find . -name “*.c” | xargs grep -n “main”</li></ul><h2 id="Linux-中常用的压缩工具"><a href="#Linux-中常用的压缩工具" class="headerlink" title="Linux 中常用的压缩工具"></a>Linux 中常用的压缩工具</h2><h3 id="gzip-和-bzip2"><a href="#gzip-和-bzip2" class="headerlink" title="gzip 和 bzip2"></a>gzip 和 bzip2</h3><ul><li>不能压缩目录，只能一个一个文件进行压缩，压缩之后会使源文件消失</li><li>gzip * 压缩当前目录下所有的文件，但是目录不能压缩</li><li>gunzip * 解压当前目录下所有的 .gz 文件</li><li>bzip2 * 压缩当前目录下所有的文件，但是目录不能压缩</li><li>bunzip2 * 解压当前目录下所有的 .bz2 文件</li></ul><h3 id="tar-工具"><a href="#tar-工具" class="headerlink" title="tar 工具"></a>tar 工具</h3><ul><li>相关参数说明<ul><li>z：用 gzip 来压缩&#x2F;解压文件</li><li>j：用 bzip2 来压缩&#x2F;解压文件</li><li>c：create，创建新的压缩文件，与 x 互斥使用</li><li>x：从压缩文件中释放文件，与 c 互斥使用</li><li>f：指定压缩文件的名字</li><li>t：查看压缩包中有哪些文件</li></ul></li><li>压缩：<ul><li>tar -cvf 压缩包名.tar 要压缩的文件或目录</li><li>tar -cvzf 压缩包名.tar.gz 要压缩的文件或目录</li><li>tar -cvjf 压缩包名.tar.bz2 要压缩的文件或目录</li></ul></li><li>解压缩<ul><li>tar -xvf 压缩包名.tar</li><li>tar -xzvf 压缩包名.tar.gz</li><li>tar -xjvf 压缩包名.tar.bz2</li><li>解压到指定目录：添加参数 -C(大写)<ul><li>tar -xzvf 压缩包名.tar.gz -C 指定目录</li></ul></li></ul></li><li>查看压缩包中有哪些文件<ul><li>tar -tvf 压缩包名.tar</li></ul></li></ul><h3 id="rar-工具"><a href="#rar-工具" class="headerlink" title="rar 工具"></a>rar 工具</h3><ul><li>使用前需要安装 rar 工具<ul><li>安装命令：sudo apt-get install rar</li></ul></li><li>压缩：<ul><li>命令： rar a -r 压缩包名 要压缩的文件<ul><li>压缩目录需要使用参数： -R</li><li>rar a -r my aa bb dir —-将 aa bb dir 三个文件压缩到 my.rar 中</li></ul></li><li>打包的生成的新文件不需要指定后缀</li></ul></li><li>解压缩：<ul><li>命令：rar x xxx.rar 压缩目录<ul><li>rar x my.rar —-将 my.rar 中的文件解压到当前目录</li></ul></li><li>解压到指定目录，直接指定解压目录即可<ul><li>rar x xxx.rar 目录</li><li>rar x my.rar TAR —-将 my.rar 中的文件解压到 TAR 目录</li><li>注意：若解压目录不存在则会报错</li></ul></li></ul></li></ul><h3 id="zip-工具"><a href="#zip-工具" class="headerlink" title="zip 工具"></a>zip 工具</h3><ul><li>压缩：zip -r 压缩包名 要压缩的文件或目录<ul><li>压缩目录需要使用参数 -R</li><li>使用该命令不需要指定压缩包后缀</li><li>zip -r xxx file dir —-将 file dir 两个文件压缩到 xxx.zip 中</li></ul></li><li>解压缩：unzip 压缩包名<ul><li>解压缩到指定目录：添加参数 -d 解压目录</li><li>unzip xxx.zip -d &#x2F;home</li><li>注意：若解压目录不存在则会创建</li></ul></li></ul><h2 id="软件的安装和卸载"><a href="#软件的安装和卸载" class="headerlink" title="软件的安装和卸载"></a>软件的安装和卸载</h2><h3 id="在线安装"><a href="#在线安装" class="headerlink" title="在线安装"></a>在线安装</h3><ul><li>软件安装：sudo apt-get install 软件名</li><li>软件卸载：sudo apt-get remove 软件名</li><li>更新软件列表：sudo apt-get update</li><li>清理安装包：sudo apt-get clean</li></ul><h3 id="安装包安装"><a href="#安装包安装" class="headerlink" title="安装包安装"></a>安装包安装</h3><ul><li>在 Ubuntu 系统下必须有 deb 格式的安装包</li><li>软件安装：sudo dpkg -i xxx.deb</li><li>软件卸载：sudo dpkg -r xxx.deb</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
