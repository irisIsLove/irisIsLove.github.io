<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>文件IO</title>
    <link href="/2025/03/21/file-io/"/>
    <url>/2025/03/21/file-io/</url>
    
    <content type="html"><![CDATA[<h1 id="文件-IO"><a href="#文件-IO" class="headerlink" title="文件 IO"></a>文件 IO</h1><h2 id="C-库-IO-函数的工作流程"><a href="#C-库-IO-函数的工作流程" class="headerlink" title="C 库 IO 函数的工作流程"></a>C 库 IO 函数的工作流程</h2><p><img src="/2025/03/21/file-io/c_library_io_function_workflow1.png"></p><p><img src="/2025/03/21/file-io/c_library_io_function_workflow2.png"></p><p>c 语言操作文件相关问题：</p><p>使用 fopen 函数打开一个文件，返回一个 FILE* fp，这个指针指向的结构体有三个重要的成员。</p><ul><li>文件描述符：通过文件描述符可以找到文件的 inode，通过 inode 可以找到对应的数据块</li><li>文件指针：读和写共享一个文件指针，读或者写都会引起文件指针的变化。</li><li>文件缓冲区：读或者写会先通过文件缓冲区，主要目的是为了减少对磁盘的读写次数，提高读写磁盘的效率。</li></ul><p>备注：</p><ul><li>头文件 stdio.h 的第 48 行处：<code>typedef struct_IO_FILE FILE</code>;</li><li>头文件 libio.h 的第 241 行处：<code>struct_IO_FILE</code>，这个接头文件定义中有一个 <code>_fileno_</code>成员，这个就是文件描述符。</li></ul><h2 id="C-库函数与系统函数的关系"><a href="#C-库函数与系统函数的关系" class="headerlink" title="C 库函数与系统函数的关系"></a>C 库函数与系统函数的关系</h2><p><img src="/2025/03/21/file-io/c_function_with_system_function.png"></p><p>系统调用：由操作系统实现并提供给外部应用程序的编程接口，(Application Programming Interfact, API)，是应用程序与系统之间数据交互的桥梁。</p><h2 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h2><p><img src="/2025/03/21/file-io/virtual_address.png"></p><p>进程的虚拟地址空间分为用户区和内核区，其中内核区是受保护的，用户是不能够对其进行读写操作的。</p><p>内核区中很重要的一个就是进程管理，进程管理中有一个区域就是 PCB(本质是一个结构体)。</p><p>PCB 中有文件描述符表，文件描述符表中存放着打开的文件描述符，涉及到文件的 IO 操作都会用到这个文件描述符。</p><h2 id="PCB-和文件描述符表"><a href="#PCB-和文件描述符表" class="headerlink" title="PCB 和文件描述符表"></a>PCB 和文件描述符表</h2><p><img src="/2025/03/21/file-io/pdb_and_file_descriptor_table.png"></p><p>备注：</p><p>pcb：结构体：<code>task_struct</code>，该结构体在：<code>/usr/src/linux-headers-4.4.0-97/include/linux/sched.h:1390</code></p><p>一个进程有一个文件描述符表：1024</p><ul><li>前三个被占用，分别是<code>STDIN_FILENO</code>，<code>STDOUT_FILENO</code>，<code>STDERR_FILENO</code></li><li>文件描述符作用：通过文件描述符找到 inode，通过 inode 找到磁盘数据块</li></ul><p>虚拟地址空间 -&gt; 内核区 -&gt; PCB -&gt; 文件描述符表 -&gt; 文件描述符 -&gt; 文件 IO 操作使用文件描述符</p><h2 id="open-close"><a href="#open-close" class="headerlink" title="open&#x2F;close"></a>open&#x2F;close</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>一个进程启动之后，默认打开三个文件描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STDIO_FILENO    0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STDOUT_FILENO   1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STDERR_FILENO   2</span><br></code></pre></td></tr></table></figure><p>新打开文件返回文件描述符中未使用的最小文件描述符，调用 open 函数可以打开或创建一个问及那，得到一个文件描述符。</p><h3 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a>open 函数</h3><ul><li>函数描述：打开或者新建一个文件</li><li>函数原型：<ul><li><code>int open(const char* pathname, int flags);</code></li><li><code>int open(const char* pathname, int flags, mode_t mode);</code></li></ul></li><li>函数参数：<ul><li>pathname 参数是要开打或创建的文件名，和 fopen 一样，pathname 既可以是相对路劲也可以是绝对路径</li><li>flags 参数有一系列常数值可供选择，可以同时选择多个常熟用按位或运算连接起来，所以这些常熟的共定义都已 O_ 开头，表示 or。<ul><li>必选项：以下三个常数中必须指定一个，且仅允许指定一个。<ul><li><code>O_RDONLY</code> 只读打开</li><li><code>O_WROBLY</code> 只写打开</li><li><code>O_RDWR</code> 可读可写打开</li></ul></li><li>以下可选项可以同时指定 0 个或多个，和必选项按位或起来作为 flags 参数。以下为常用项：<ul><li><code>O_APPEND</code> 表示追加。如果文件已有内容，这次打开文件所写的数据附加到文件的末尾而不是覆盖原来的内容。</li><li><code>O_CERAT</code> 若此文件不存在则创建它。使用此选项时需要提供第三个参数 mode，表示该文件的访问权限。<ul><li>文件最终权限：<code>mode&amp;~umask</code></li></ul></li><li><code>O_EXCL</code> 如果同时指定了 O_CREAT，并且文件已存在，则出错返回</li><li><code>O_TRUNC</code> 如果文件已存在，将其长度截断为 0 字节</li><li><code>O_NONBLOCK</code> 对于设备文件，以 O_NONBLOCK 方式打开可以做非阻塞 I&#x2F;O(Nonblock I&#x2F;O)</li></ul></li></ul></li></ul></li><li>函数返回值：<ul><li>成功：返回一个最小且未被占用的文件描述符</li><li>失败：返回 -1，并设置 errno 值</li></ul></li></ul><h3 id="close-函数"><a href="#close-函数" class="headerlink" title="close 函数"></a>close 函数</h3><ul><li>函数描述：关闭文件</li><li>函数原型：<code>int close(int fd);</code></li><li>函数参数：fd 文件描述符</li><li>函数返回值：<ul><li>成功返回 0</li><li>失败返回 -1，并设置 errno 值</li></ul></li></ul><p>需要说明的是，当一个进程终止时，内核对该进程所有尚未关闭的文件描述符调用 close 关闭，所以即使用户程序不调用 close，在终止时也会自动关闭它打开的所有文件。但是对于一个长年累月云心过的程序（比如网络服务器），打开的文件描述符一定要记得关闭，否则随着打开的文件越来越多，会占用大量文件描述符和系统资源。</p><h2 id="read-write"><a href="#read-write" class="headerlink" title="read&#x2F;write"></a>read&#x2F;write</h2><h3 id="read-函数"><a href="#read-函数" class="headerlink" title="read 函数"></a>read 函数</h3><ul><li>函数描述：从打开的设备或文件中读取数据</li><li>函数原型：<code>ssize_t read(int fd, void *buf, size_t count);</code></li><li>函数参数：<ul><li>fd：文件描述符</li><li>buf：读上来的数据保存在缓冲区 buf 中</li><li>count：buf 缓冲区存放的最大字节数</li></ul></li><li>函数返回值<ul><li>&gt;0：读取到的字节数</li><li>&#x3D;0：文件读取完毕</li><li>-1：出错，并设置 errno</li></ul></li></ul><h3 id="write-函数"><a href="#write-函数" class="headerlink" title="write 函数"></a>write 函数</h3><ul><li>函数描述：向打开的设备或文件中写数据</li><li>函数原型：<code> ssize_t write(int fd, const void *buf, size_t count);</code></li><li>函数参数：<ul><li>fd：文件描述符</li><li>buf：缓冲区，要写入文件或设备的数据</li><li>count：buf 中数据的长度</li></ul></li><li>函数返回值：<ul><li>成功：返回写入的字节数</li><li>错误：返回 -1 并设置 errno</li></ul></li></ul><h2 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h2><p>所有打开的文件都有一个当前文件偏移量(current file offset)，一下简称为 cfo。cfo通常是一个非负整数，用于表明文件开始处到文件当前位置的字节数。读写操作通常开始于 cfo，并且使 cfo 增大，增量为读写的字节数，文件被打开时，cfo 会被初始化为 0，除非使用了 O_APPEND。</p><p>使用 lseek 函数可以改变文件的 cfo。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">off_t</span> <span class="hljs-title function_">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset, <span class="hljs-type">int</span> whence)</span>;<br></code></pre></td></tr></table></figure><ul><li>函数描述：移动文件指针</li><li>函数原型：<code>off_t lseek(int fd, off_t offset, int whence);</code></li><li>函数参数：<ul><li>fd：文件描述符</li><li>参数 offset的含义取决于参数 whence<ul><li>如果 whence 是 SEEK_SET，文件偏移量将设置为 offset</li><li>如果 whence 是 SEEK_CUR，文件偏移量将被设置为 cfo 加上 offset，offset 可以为正也可以为负</li><li>如果 whence 是 SEEK_END，文件偏移量将被设置为文件长度加上 offset，offset 可以为正也可以为负</li></ul></li></ul></li><li>函数返回值：若 lseek 成功执行，则返回新的偏移量</li><li>lseek 函数常用操作：<ul><li>文件指针移动到头部：<code>lseek(fd, 0, SEEK_SET)</code></li><li>获取文件指针当前位置：<code>int len = lseek(fd, 0, SEEK_CUR)</code></li><li>获取文件长度：<code>int len = lseek(fd, 0, SEEK_END)</code></li><li>lseek 实现文件拓展：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 从文件尾部开始向后拓展 1000 个字节</span><br><span class="hljs-type">off_t</span> curpos = lseek(fd, <span class="hljs-number">1000</span>, SEEK_END);<br><span class="hljs-comment">// 额外执行一次写操作，否则文件无法完成拓展</span><br>write(fd, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="perror-和-errno"><a href="#perror-和-errno" class="headerlink" title="perror 和 errno"></a>perror 和 errno</h2><p>errno 是一个全局变量，当系统调用后出错将会将 errno 进行设置，perror 可以将 errno 对应的描述信息打印出来。</p><p>如：<code>perror(&quot;open&quot;)</code>；如果报错的话打印：open：错误信息</p><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><ul><li>普通文件：hello.c<ul><li>默认是非阻塞的</li></ul></li><li>终端设备：如 &#x2F;dev&#x2F;tty<ul><li>默认阻塞</li></ul></li><li>管道和套接字<ul><li>默认阻塞</li></ul></li></ul><h2 id="文件操作相关函数"><a href="#文件操作相关函数" class="headerlink" title="文件操作相关函数"></a>文件操作相关函数</h2><h3 id="stat-lstate-函数"><a href="#stat-lstate-函数" class="headerlink" title="stat&#x2F;lstate 函数"></a>stat&#x2F;lstate 函数</h3><ul><li>函数描述：获取文件属性</li><li>函数原型：<code>int stat(const char* pathname, struct stat* buf);</code><br><code>int lstat(const char* pathname, struct stat* buf);</code></li><li>函数返回值：<ul><li>成功返回 0</li><li>失败返回 -1</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> &#123;</span><br>  <span class="hljs-type">dev_t</span>     st_dev;       <span class="hljs-comment">// 文件的谁被编号</span><br>  <span class="hljs-type">ino_t</span>     st_ino;       <span class="hljs-comment">// 节点</span><br>  <span class="hljs-type">mode_t</span>    st_mode;      <span class="hljs-comment">// 文件的类型和存取权限</span><br>  <span class="hljs-type">nlink_t</span>   st_nlink;     <span class="hljs-comment">// 连到该文件的硬链接数目，刚建立的文件值为 1</span><br>  <span class="hljs-type">uid_t</span>     st_uid;       <span class="hljs-comment">// 用户 ID</span><br>  <span class="hljs-type">gid_t</span>     st_gid;       <span class="hljs-comment">// 组 ID</span><br>  <span class="hljs-type">dev_t</span>     st_rdev       <span class="hljs-comment">// (设备类型)若此文件为设备文件，则为设备编号</span><br>  <span class="hljs-type">off_t</span>     st_size       <span class="hljs-comment">// 文件字节数(文件大小)</span><br>  <span class="hljs-type">blksize_t</span> st_blksize;   <span class="hljs-comment">// 块大小(文件系统的 I/O 缓冲区大小)</span><br>  <span class="hljs-type">blkcnt_t</span>  st_blocks;    <span class="hljs-comment">// 块数</span><br>  <span class="hljs-type">time_t</span>    st_atime;     <span class="hljs-comment">// 最后一次访问时间</span><br>  <span class="hljs-type">time_t</span>    st_mtine;     <span class="hljs-comment">// 最后一次修改时间</span><br>  <span class="hljs-type">time_t</span>    st_ctime;     <span class="hljs-comment">// 最后一次改变时间(指属性)</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>st_mode</code> – 16 位整数<ul><li><p>0 - 2 bit – 其他人权限</p><ul><li><code>S_IROTH</code> 00004 读权限</li><li><code>S_IWOTH</code> 00002 写权限</li><li><code>S_IXOTH</code> 00001 执行权限</li><li><code>S_IRWXO</code> 00007 掩码，过滤 st_mode 中除其他人权限以外的信息</li></ul></li><li><p>3 - 5 bit – 所属组权限</p><ul><li><code>S_IRGRP</code> 00004 读权限</li><li><code>S_IWGRP</code> 00002 写权限</li><li><code>S_IXGRP</code> 00001 执行权限</li><li><code>S_IRWXG</code> 00007 掩码，过滤 st_mode 中除其他人权限以外的信息</li></ul></li><li><p>6 - 8 bit – 文件所有者权限</p><ul><li><code>S_IRUSR</code> 00004 读权限</li><li><code>S_IWUSR</code> 00002 写权限</li><li><code>S_IXUSR</code> 00001 执行权限</li><li><code>S_IRWXU</code> 00007 掩码，过滤 st_mode 中除其他人权限以外的信息</li><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (st_mode &amp; S_IRUSR) ---- 为真表明可读<br><span class="hljs-keyword">if</span> (st_mode &amp; S_IWUSR) ---- 为真表明可写<br><span class="hljs-keyword">if</span> (st_mode &amp; S_IXUSR) ---- 为真表明可执行<br></code></pre></td></tr></table></figure></li></ul></li><li><p>12 - 15 bit – 文件类型</p><ul><li>S_IFSOCK    0140000 套接字</li><li>S_IFLNK     0120000 符号链接(软链接)</li><li>S_IFREG     0100000 普通文件</li><li>S_IFBLK     0060000 块设备</li><li>S_IFDIR     0040000 目录</li><li>S_IFCHR     0020000 字符设备</li><li>S_IFIFO     0010000 管道</li><li>S_IFMT      0170000 掩码，过滤 st_mode 中除文件类以外的信息</li><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((st_mode &amp; S_IFMT) == S_IFREG) -- 为真普通文件<br><span class="hljs-keyword">if</span> (S_ISREG(st_mode)) ---- 为真表示普通文件<br><span class="hljs-keyword">if</span> (S_ISDIR(st_mode)) ---- 为真表示目录文件<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>stat 函数 和 lstat 函数的区别：</p><ul><li>对于普通文件，这两个函数没有区别，是一样的。</li><li>而对于链接文件，调用 lstat 函数获取的是链接文本本身的属性信息；而 stat 函数获取的是链接文件指向的文件的属性信息。</li></ul><h2 id="目录操作相关函数"><a href="#目录操作相关函数" class="headerlink" title="目录操作相关函数"></a>目录操作相关函数</h2><h3 id="opendir-函数"><a href="#opendir-函数" class="headerlink" title="opendir 函数"></a>opendir 函数</h3><ul><li>函数描述：打开一个目录</li><li>函数原型：<code>DIR* opendir(const char* name);</code></li><li>函数返回值：指向目录的指针</li><li>函数参数：要便利的目录(相对路径或者绝对路径)</li></ul><h3 id="readdir-函数"><a href="#readdir-函数" class="headerlink" title="readdir 函数"></a>readdir 函数</h3><ul><li>函数描述：读取目录内容 – 目录项</li><li>函数原型：<code>struct dirent* readdir(DIR* dirp);</code></li><li>函数返回值：读取的目录项指针</li><li>函数参数：opendir 函数的返回值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> &#123;</span><br>  <span class="hljs-type">ino_t</span>             d_ino;        <span class="hljs-comment">// 此目录进入点的 inode</span><br>  <span class="hljs-type">off_t</span>             d_off;        <span class="hljs-comment">// 目录文件开头至此目录进入点的位移</span><br>  <span class="hljs-type">signed</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span>  d_reclen;     <span class="hljs-comment">// d_name 的长度，不包含 NULL 字符</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>     d_type;       <span class="hljs-comment">// d_name 所指的文件类型</span><br>  <span class="hljs-type">char</span>              d_name[<span class="hljs-number">256</span>];  <span class="hljs-comment">// 文件名</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>d_type 的取值：</p><ul><li>DT_BLK - 块设备</li><li>DT_CHR - 字符设备</li><li>DT_DIR - 目录</li><li>DT_LNK - 软链接</li><li>DT_FIFO - 管道</li><li>DT_REG - 普通文件</li><li>DT_SOCK - 套接字</li><li>DT_UNKNOWN - 未知</li></ul><p><img src="/2025/03/21/file-io/directory.png"></p><h3 id="closedir-函数"><a href="#closedir-函数" class="headerlink" title="closedir 函数"></a>closedir 函数</h3><ul><li>函数描述：关闭目录</li><li>函数原型：<code>int closedir(DIR* dirp);</code></li><li>函数返回值：成功返回 0，失败返回 -1</li><li>函数参数：opendir 函数的返回值</li></ul><h3 id="读取目录内容过的一般步骤"><a href="#读取目录内容过的一般步骤" class="headerlink" title="读取目录内容过的一般步骤"></a>读取目录内容过的一般步骤</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">DIR* pDir = opendir(<span class="hljs-string">&quot;dir&quot;</span>) <span class="hljs-comment">// 1. 打开目录</span><br><span class="hljs-keyword">while</span> ((p == readdir(pDir)) != <span class="hljs-literal">NULL</span>) &#123;&#125; <span class="hljs-comment">// 2. 循环读取文件</span><br>closedir(pDir) <span class="hljs-comment">// 3. 关闭目录</span><br></code></pre></td></tr></table></figure><h2 id="dup-dup2-fcntl"><a href="#dup-dup2-fcntl" class="headerlink" title="dup &#x2F; dup2 &#x2F; fcntl"></a>dup &#x2F; dup2 &#x2F; fcntl</h2><p><img src="/2025/03/21/file-io/dup_dup2.png"></p><h3 id="dup-函数"><a href="#dup-函数" class="headerlink" title="dup 函数"></a>dup 函数</h3><ul><li>函数描述：复制文件描述符</li><li>函数原型：<code>int dup(int oldfd);</code></li><li>函数参数：oldfd - 要复制的文件描述符</li><li>函数返回值<ul><li>成功：返回最小且没被占用的文件描述符</li><li>失败：返回 -1，设置 errno 值</li></ul></li></ul><h3 id="dup2-函数"><a href="#dup2-函数" class="headerlink" title="dup2 函数"></a>dup2 函数</h3><ul><li>函数描述：复制文件描述符</li><li>函数原型：<code>int dup2(int oldfd, int newfd);</code></li><li>函数参数：<ul><li>oldfd - 原来的文件描述符</li><li>newfd - 复制成功的新的文件描述符</li></ul></li><li>函数返回值：<ul><li>成功：将 oldfd 复制给 newfd，两个文件描述符指向同一个文件</li><li>失败：返回 -1，设置 errno 值</li></ul></li><li>假设 newfd 已经指向了一个文件，首先 close 原来打开的文件，然后 newfd 指向 oldfd 指向的文件。<br>若 newfd 没有被占用，newfd 指向 oldfd 指向的文件</li></ul><p><img src="/2025/03/21/file-io/dup_dup2_function_principal.png"></p><h3 id="fcntl-函数"><a href="#fcntl-函数" class="headerlink" title="fcntl 函数"></a>fcntl 函数</h3><ul><li>函数描述：改变已经打开的文件的属性</li><li>函数原型：<code>int fcntl(int fd, int cmd, ... /* arg */ );</code><ul><li>若 cmd 为 F_DUPFD，复制文件描述符，与 dup 相同</li><li>若 cmd 为 F_GETFL，获取文件描述符的 flag 属性值</li><li>若 cmd 为 F_SETFL，设置文件描述符的 flag 属性</li></ul></li><li>函数返回值：返回值取决于 cmd<ul><li>成功：<ul><li>若 cmd 为 F_DUPFD，返回一个新的文件描述符</li><li>若 cmd 为 F_GETFL，返回文件描述的 flags 值</li><li>若 cmd 为 F_SETFL，返回 0</li></ul></li><li>失败返回 -1，并设置 errno 值</li></ul></li><li>fcntl 函数常用的操作：<ol><li>复制一个新的文件描述符 <br> <code>int newfd = fcntl(fd, F_DUPFD, 0);</code> </li><li>获取文件的属性标志 <br> <code>int flag = fcntl(fd, F_GETFL, 0);</code></li><li>设置文件状态标志 <br> <code>flag = flag | O_APPEND;</code> <br> <code>fcntl(fd, F_SETFL, flag);</code></li><li>常用的属性标志：<ul><li>O_APPEND —- 设置文件打开为末尾添加</li><li>O_NONBLOCK —- 设置打开的文件描述符为非阻塞</li></ul></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gdb调试</title>
    <link href="/2025/03/07/gdb-debug/"/>
    <url>/2025/03/07/gdb-debug/</url>
    
    <content type="html"><![CDATA[<h1 id="gdb-调试"><a href="#gdb-调试" class="headerlink" title="gdb 调试"></a>gdb 调试</h1><h2 id="gdb-介绍"><a href="#gdb-介绍" class="headerlink" title="gdb 介绍"></a>gdb 介绍</h2><p>GBD (DBU Debugger) 是 GCC 的调试工具。其功能强大，现描述如下：</p><p>GDB 主要帮忙你完成下面四个方面的功能：</p><ul><li>启动程序，可以按照你的自定义的要求随心所欲的运行程序。</li><li>可让被调试的程序在你所指的断点处听出。(断点可以是条件表达式)</li><li>当程序被停住时，可以检查此时你的程序中所发生的事。</li><li>动态的改变你程序的执行环境。</li></ul><h2 id="生成调试信息"><a href="#生成调试信息" class="headerlink" title="生成调试信息"></a>生成调试信息</h2><p>一般来说 GDB 主要调试的是 C&#x2F;C++ 的程序。要调试 C&#x2F;C++ 的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器 (cc&#x2F;gcc&#x2F;g++) 的 -g 参数可以做到这一点。如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -<span class="hljs-selector-tag">g</span> hello<span class="hljs-selector-class">.c</span> -o hello<br></code></pre></td></tr></table></figure><p>如果没有 -g，你将看不到程序的函数名、变量名，所代替的全是运行时的内存地址。当你用 -g 把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用 gbd 调试它。</p><h2 id="启动-gdb"><a href="#启动-gdb" class="headerlink" title="启动 gdb"></a>启动 gdb</h2><ul><li><p>启动 gdb：<code>gdb program</code></p><ul><li>program 也就是你的大执行文件，一般在当前目录下。</li></ul></li><li><p>设置运行参数</p><ul><li><code>set args</code> 可以指定运行时参数。(如：set args 10 20 30 40 50)</li><li><code>show args</code> 命令可以查看设置好的运行参数</li></ul></li><li><p>启动程序</p><ul><li><code>run</code>：程序开始执行，如果有断电，停在第一个断点处</li><li><code>start</code>：程序向下执行一行。(在第一条语句处停止)</li></ul></li></ul><h2 id="显示源代码"><a href="#显示源代码" class="headerlink" title="显示源代码"></a>显示源代码</h2><p>GBD 可以打印出所调试程序的源代码，当然，在程序编译时一定要加上 -g 参数，把源程序信息编译到执行文件中华。不然就看不到源程序了。当程序停下来后，GDB 会报告程序停在了哪个文件的第几行上。你可以用 list 命令来打印程序的源代码，默认打印 10 行，list命令的用法如下所示：</p><ul><li><code>list linenum</code>：打印第 linenum 行的上下文内容</li><li><code>list function</code>：显示函数名为 function 的函数的源程序</li><li><code>list</code>：显示当前行后面的源程序</li><li><code>list -</code>：显示当前文件开始处的源程序</li><li><code>list file:linenum</code>：显示 file 文件下第 linenum 行</li><li><code>list file:function</code>：显示 file 文件的函数名为 function 的函数的源程序</li></ul><p>一般时打印当前行上 5 行和下 5 行，如果显示函数时上 2 行下 8 行，默认是 10 行，当然，你也可以定制显示范围，使用下面命令可以设置一次显示源程序的行数。</p><ul><li><code>set listsize count</code>：设置一次显示源代码的行数</li><li><code>show listsize</code>：查看当前 listsize 的设置</li></ul><h2 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h2><h3 id="简单断点-–-当前文件"><a href="#简单断点-–-当前文件" class="headerlink" title="简单断点 – 当前文件"></a>简单断点 – 当前文件</h3><ul><li>break 设置断点，可以简写为 b<ul><li><code>b 10</code>设置断点，在源程序第 10 行</li><li><code>b func</code>设置断点，在 func 函数入口处</li></ul></li></ul><h3 id="多文件设置断点-–-其他文件"><a href="#多文件设置断点-–-其他文件" class="headerlink" title="多文件设置断点 – 其他文件"></a>多文件设置断点 – 其他文件</h3><ul><li><p>在进入指定函数时停住：</p><ul><li><code>b filename:linenum</code> – 在源文件 filename 的 linenum 行处停住</li><li><code>b filename:function</code> – 在源文件 filename 的 function 函数的入口处停住</li></ul></li><li><p>查询所有断点</p><ul><li><code>info b == info break == i break == i b</code></li></ul></li><li><p>条件断点</p><p>  一般来说，为断点设置一个条件，我们使用 if 关键字，后面跟其断点条件。设置一个条件断点：</p><ul><li><code>b test.c:8 if intValue == 5</code></li></ul></li><li><p>维护断点</p><ul><li><p><code>delete [range...]</code>删除指定的断点，其简写命令为 d。</p><ul><li>如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围<ul><li>删除某个断点：<code>delete num</code></li><li>删除多个断点：<code>delete num1 num2</code></li><li>删除连续多个断点：<code>delete m-n</code></li><li>删除所有断点：<code>delete</code></li></ul></li><li>比删除更高的一种方法是 disable 停止点，disable 了的停止点，GDB 不会删除，当你还需要时，enable 即可，就好像回收站一样。</li></ul></li><li><p><code>disable/enable [range...]</code> 使指定断点无效，简写命令使 dis&#x2F;ena。</p><p>如果什么都不指定，表示 diable 所有的停止点。</p><ul><li>使一个断点无效&#x2F;有效：<code>disable/enable num</code></li><li>使多个断点无效&#x2F;有效：<code>disable/enable num1 num2</code></li><li>使多个连续的断点无效&#x2F;有效：<code>disbale/enable m-n</code></li><li>使所有断点无效&#x2F;有效:<code>disable/enable</code></li></ul></li></ul></li></ul><h2 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h2><ul><li><code>run</code> 运行程序，可简写为 r</li><li><code>next</code> 单步跟踪，函数调用当作一条简单执行语句执行，可简写为 n</li><li><code>step</code> 单步跟踪，函数调用会进入被调用函数体内，可简写为 s</li><li><code>finish</code> 退出进入的函数，如果出不去，看一下函数体中的循环中是否由断点，如果有删掉，或者设置无效。</li><li><code>until</code> 在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体，可简写为 u，如果出不去，看一下函数体中的循环中是否由断点，如果有删掉，或者设置无效。</li><li><code>continue</code> 继续运行程序，可简写为 c (若有断点，则跳到下一个断点处)</li></ul><h2 id="查看变量的值"><a href="#查看变量的值" class="headerlink" title="查看变量的值"></a>查看变量的值</h2><h3 id="查看运行时变量的值"><a href="#查看运行时变量的值" class="headerlink" title="查看运行时变量的值"></a>查看运行时变量的值</h3><p>print 打印变量、字符串、表达式等的值，可简写为 p</p><ul><li><code>p count</code> —- 打印 count 的值</li></ul><h3 id="自动显示变量的值"><a href="#自动显示变量的值" class="headerlink" title="自动显示变量的值"></a>自动显示变量的值</h3><p>你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的 GDB 命令时 display。</p><ul><li><code>display 变量名</code></li><li><code>info display</code> – 查看 display 设置的自动显示的信息。</li><li><code>undisplay num</code> (info display 时显示的编号)</li><li><code>delete display dnums...</code> – 删除自动显示，dnums 意为所设置好了的自动显示的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示<ul><li>删除某个自动显示：<code>undisplay num</code> 或者 &#96;&#96;delete display num&#96;</li><li>删除多个: <code>delete display num1 num2</code></li><li>删除一个范围：<code>delete display m-n</code></li></ul></li><li><code>disable/enable display dnums</code><ul><li>使一个自动显示无效&#x2F;有效：<code>disable/enable display num</code></li><li>使多个自动显示无效&#x2F;有效: <code>disable/enable display num1 num2</code></li><li>使一个范围的自动显示无效&#x2F;有效：<code>disable/enable display m-n</code></li></ul></li></ul><h3 id="查看修改变量的值"><a href="#查看修改变量的值" class="headerlink" title="查看修改变量的值"></a>查看修改变量的值</h3><ul><li><code>ptype width</code> – 查看变量 width 的类型<ul><li><code>type == double</code></li></ul></li><li><code>p width</code> – 打印变量 width 的值<ul><li><code>$4 = 13</code></li></ul></li><li>你可以使用 <code>set var</code> 命令来告诉 GDB，width 不是你 GDB 的参数，而是程序的变量名，如：<ul><li><code>set var width = 47</code> – 将变量 var 的值设置为 47</li></ul></li><li>在你改变程序变量取值时，最好都是用 set var 格式的 GDB 命令</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>gcc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>makefile</title>
    <link href="/2025/03/06/makefile/"/>
    <url>/2025/03/06/makefile/</url>
    
    <content type="html"><![CDATA[<h1 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h1><p>makefile 文件中定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile 就像一个 shell 脚本一样，其中也可以执行操作系统的命令。makefile 带来的好处就是 — “自动化编译”，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p><p>make 是一个命令工具，是一个解释 makefile 中指令的命令工具，一般来说，大多数的 IDE 都有这个命令，比如：Visual C++ 的 nmake，Linux 下的 make。可见，makefile 都成为了一种在工程方面的编译方法。</p><p>makefile 文件中会使用 gcc 编译器对源代码进行编译，最终生成可执行文件或者库文件。</p><p>makefile 文件的命名：makefile 或者 Makefile</p><h2 id="makefile-的基本规则"><a href="#makefile-的基本规则" class="headerlink" title="makefile 的基本规则"></a>makefile 的基本规则</h2><p>makefile 由一组规则组成，规则如下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">目标：依赖<br>(<span class="hljs-literal">Tab</span>) 命令<br></code></pre></td></tr></table></figure><p>makefile 基本规则三要素：</p><ul><li>目标：要生成的目标文件</li><li>依赖：目标文件由哪些文件生成</li><li>命令：通过执行该命令由依赖文件生成目标</li></ul><p>下面以具体的例子讲解：</p><p>当前目录下由 main.c fun1.c fun2.c sum.c，根据这个基本规则编写一个简单的 makefile文件，生成可执行文件 main。</p><p>第一个版本的 makefile 文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">main: main.c fun1.c fun2.c sum.c</span><br>gcc -o main main.c fun1.c fun2.c sum.cls <br></code></pre></td></tr></table></figure><p>缺点：效率低，修改一个文件，所有的文件会全部重新编译。</p><h2 id="makfile-工作原理"><a href="#makfile-工作原理" class="headerlink" title="makfile 工作原理"></a>makfile 工作原理</h2><h3 id="基本原则："><a href="#基本原则：" class="headerlink" title="基本原则："></a>基本原则：</h3><p><strong>若想生成目标，检查规则中的所有的依赖文件是否都存在：</strong></p><ul><li><p>如果有的依赖文件不存在，则向下搜索规则，看是否由生成该依赖文件的规则：</p><p>  如果有规则用来生成该依赖文件，则执行规则中的命令生成依赖文件；如果没有规则用来生成该依赖文件，则报错。<br>  <img src="/2025/03/06/makefile/makefile1.png"></p></li><li><p>如果所有依赖都存在，检查规则中的目标是否需要更新，必须先检查它的所有依赖，依赖中有任何一个被更新，则目标必须更新。(检查的规则是哪个时间大，哪个最新)</p><ul><li><p>若目标的时间 &gt; 依赖的时间，不更新</p></li><li><p>若目标的时间 &lt; 依赖的时间，更新</p><p><img src="/2025/03/06/makefile/makefile2.png"></p></li></ul></li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li>分析各个目标和依赖之间的关系</li><li>根据依赖关系自底向上执行命令</li><li>根据依赖文件得到时间和目标文件的时间确定是否需要更新</li><li>如果目标不依赖任何条件，则执行对应命令，以示更新(如：伪目标)</li></ul><p>第二个版本：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">main: main.o fun1.o fun2.o sum.o</span><br>gcc -o main main.o fun1.o fun2.o sum.o<br><br><span class="hljs-section">main.o: main.c</span><br>gcc -c main.c -I./<br><br><span class="hljs-section">fun1.o: fun1.c</span><br>gcc -c fun1.c<br><br><span class="hljs-section">fun2.o: fun2.c</span><br>gcc -c fun2.c<br><br><span class="hljs-section">sum.o: sum.c</span><br>gcc -c sum.c<br></code></pre></td></tr></table></figure><p>缺点：冗余，若 .c 文件数量很多，编写起来比较麻烦</p><h2 id="makefile-中的变量"><a href="#makefile-中的变量" class="headerlink" title="makefile 中的变量"></a>makefile 中的变量</h2><p>在 makefile 中使用变量有点类似于 C 语言中的宏定义，使用该变量相当于内容替换，使用变量可以使 makefile 易于维护，修改起来变得简单。</p><p>makefile 有三种类型的变量：</p><ul><li>普通变量</li><li>自带变量</li><li>自动变量</li></ul><h3 id="普通变量"><a href="#普通变量" class="headerlink" title="普通变量"></a>普通变量</h3><ul><li>变量定义直接用 &#x3D;</li><li>使用变量值用 $(变量名)  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">如：下面是变量的定义和使用：<br>    foo = abc       // 定义变量并赋值<br>    bar = <span class="hljs-variable">$(foo)</span>    // 使用变量<br></code></pre></td></tr></table></figure>  定义了两个变量：foo、bar，其中 bar 的值是 foo 变量值的引用。</li></ul><h3 id="自带变量"><a href="#自带变量" class="headerlink" title="自带变量"></a>自带变量</h3><p>除了用户自定义变量，makefile 中也提供了一些变量(变量名大写)供用户直接使用，我们可以直接对其进行赋值：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CC = gcc <span class="hljs-comment">#arm-linux-gcc</span><br>CPPFLAGS：C 预处理的选项 -I<br>CFLAGS：C 编译器的选项 -Wall -g -c<br>LDFLAGS：链接器的选项 -L -l<br></code></pre></td></tr></table></figure><h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><ul><li>$@：表示规则中的目标</li><li>$&lt;：表示规则中的第一个条件</li><li>$^：表示规则中的所有条件，组成一个列表，以空格隔开，如果这个列表中有重复的项则消除重复项。</li><li>特别注意：自动变量只能在规则的命令中使用</li></ul><h3 id="规则模式"><a href="#规则模式" class="headerlink" title="规则模式"></a>规则模式</h3><p>至少在规则的目标定义中要包含 ‘%’ ，’%’ 表示一个或多个，在以来条件中同样可以使用 ‘%’，依赖条件中的 ‘%’ 的取值却决于其目标：</p><p>比如：main.o : main.c fun1.o : fun1.c fun2.o : fun2.c sum.o : sum.c，说的简单点就是：xxx.o : xxx.c</p><p>makefile 的第三个版本：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">target = main<br>objects = main.o fun1.o fun2.o sum.o<br>CC = gcc<br>CPPFLAGS = -I./<br><br><span class="hljs-variable">$(target)</span> : <span class="hljs-variable">$(objects)</span><br><span class="hljs-variable">$(CC)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><br><br>%.o : %.c<br><span class="hljs-variable">$(CC)</span> -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span> <span class="hljs-variable">$(CPPFLAGS)</span><br></code></pre></td></tr></table></figure><h2 id="makefile-中的函数"><a href="#makefile-中的函数" class="headerlink" title="makefile 中的函数"></a>makefile 中的函数</h2><p>makefile 中的函数有很多，在这里给打架介绍两个最常用的。</p><ol><li><p>wildcard - 查找指定目录下的指定类型的文件</p><p> <code>src = $(wildcard ./*.c)</code>     &#x2F;&#x2F; 找到当前目录下所有后缀为 .c 的文件，赋值给src</p></li><li><p>patsubst - 匹配替换</p><p> <code>obj = $(patsubst %.c,%.o,$(src))</code>    &#x2F;&#x2F; 将 src 中所有后缀为 .c 的文件替换为 .o</p></li></ol><p>在 makefile 中所有的函数都是由返回值的。</p><p>当前目录下由 main.c fun1.c fun2.c sum.c</p><p><code>src = $(wildcard ./*.c)</code> 等价于 src &#x3D; main.c fun1.c fun2.c sum.c</p><p><code>obj = $(patsubst %.c,%.o,$(src))</code> 等价于 obj &#x3D; main.o fun1.o fun2.o sum.o</p><p>makefile 的第四个版本：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile">src = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> ./*.c)</span><br>objects = <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %.o <span class="hljs-variable">$(src)</span>)</span><br>target = main<br>CC = gcc<br>CPPFLAGS = -I./<br><br><span class="hljs-variable">$(target)</span> : <span class="hljs-variable">$(objects)</span><br><span class="hljs-variable">$(CC)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><br><br>%.o : %.c<br><span class="hljs-variable">$(CC)</span> -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span> <span class="hljs-variable">$(CPPFLAGS)</span><br></code></pre></td></tr></table></figure><p>缺点：每次重新编译都需要手工清理中间文件和最终目标文件</p><h2 id="makefile-的清理操作"><a href="#makefile-的清理操作" class="headerlink" title="makefile 的清理操作"></a>makefile 的清理操作</h2><p>用途：清楚编译生成的中间文件和最终目标文件。</p><p>make clean 如果当前目录下由同名 clean 文件，则不执行 clean 对应的命令，解决方案：</p><ul><li><p>伪目标声明：</p><ul><li><code>.PHONY : clean</code></li><li>声明目标为伪目标之后，makefile 将不会检查该目标是否存在或者该目标是否需要更新。</li></ul></li><li><p>clean 命令中的特殊符号：</p><ul><li><p>“-“ 此命令出错，make 也会继续执行后续的命令。如：<code>-rm main.o</code></p><p>rm -f：将之执行，比如若要删除的文件不存在使用 -f 不会报错</p></li></ul></li><li><p>其他：</p><ul><li>make 默认执行第一个出现的目标，可通过 make dest 指定要执行的目标</li><li>make -f：-f执行第一个 makefile 文件名称，使用 make 执行指定的 makefile：make -f mainmak</li></ul></li></ul><p>makefile 的第五个版本：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile">src = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> ./*.c)</span><br>objects = <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %.o, <span class="hljs-variable">$(src)</span>)</span><br>target = main<br>CC = gcc<br>CPPFLAGS = -I./<br><br><span class="hljs-variable">$(target)</span> : <span class="hljs-variable">$(objects)</span><br><span class="hljs-variable">$(CC)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><br><br>%.o : %.c<br><span class="hljs-variable">$(CC)</span> -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span> <span class="hljs-variable">$(CPPFLAGS)</span><br><br>.PHONY : clean<br><span class="hljs-section">clean:</span><br>rm -f <span class="hljs-variable">$(objects)</span> <span class="hljs-variable">$(target)</span><br></code></pre></td></tr></table></figure><p>在 makefile 的第五个版本中，综合使用了变量，函数，规则模式和清理命令，是一个比较完善的版本。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>gcc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态库和共享（动态）库</title>
    <link href="/2025/03/04/lib-and-so/"/>
    <url>/2025/03/04/lib-and-so/</url>
    
    <content type="html"><![CDATA[<h1 id="静态库和共享（动态）库"><a href="#静态库和共享（动态）库" class="headerlink" title="静态库和共享（动态）库"></a>静态库和共享（动态）库</h1><h2 id="库的介绍"><a href="#库的介绍" class="headerlink" title="库的介绍"></a>库的介绍</h2><h3 id="什么是库"><a href="#什么是库" class="headerlink" title="什么是库"></a>什么是库</h3><p>库是二进制文件，是源代码文件的另一种表现形式，是加了密的源代码；是喜喜呃功能相近或者是相似的函数的集合体。</p><h3 id="使用库有什么好处"><a href="#使用库有什么好处" class="headerlink" title="使用库有什么好处"></a>使用库有什么好处</h3><ul><li>提高代码的可重用性，而且还可以提高程序的健壮性；</li><li>可以减少开发者的代码开发量，缩短开发周期。</li></ul><h3 id="库制作完成后，如何给用户使用"><a href="#库制作完成后，如何给用户使用" class="headerlink" title="库制作完成后，如何给用户使用"></a>库制作完成后，如何给用户使用</h3><ul><li>头文件 — 包含了库函数的声明</li><li>库文件 — 包含了库函数的代码实现</li><li>注意：库不能单独使用，只能作为其他执行程序的额一部分完成某些功能，也就是说只能被其他程序调用才能使用。</li><li>库可分静态库(static library)和共享库(shared library)两种。</li></ul><h2 id="静态库-static-library"><a href="#静态库-static-library" class="headerlink" title="静态库(static library)"></a>静态库(static library)</h2><p>静态库可以认为是一些目标代码的集合，是在可执行程序运行前就已经加入到执行码中，成为执行程序的一部分。按照习惯，一般以 .a 作为文件后缀名。</p><p>静态库的命名一般分为三个部分：</p><ul><li>前缀：lib</li><li>库名称：自定义即可，如：test</li><li>后缀：.a</li></ul><p>座椅最终的静态库的名字应该是：libtest.a</p><h3 id="静态库的制作"><a href="#静态库的制作" class="headerlink" title="静态库的制作"></a>静态库的制作</h3><p>下面以 func1.c、func2.c 和 head.h 三个文件为例讲述静态库的制作和使用，其中 head.h 文件中有函数的声明，func1.c 和 func2.c 文件中有函数的实现。</p><p>步骤一：将 c 源文件生成对应的 .o 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -c func1.c func2.c<br></code></pre></td></tr></table></figure><p>步骤二：使用打包工具与 ar 将准备好的 .o 文件打包为 .a 文件</p><ul><li>在使用 ar 工具的时候需要添加参数 rcs<ul><li>r：表示将文件插入（replace）到库中</li><li>c：表示创建（create）库</li><li>s：表示生成索引（symbol）表</li></ul></li><li>命令： ar rcs 静态库名 .o 文件<ul><li><code>ar rcs libtest.a func1.o func2.o</code></li></ul></li></ul><p><img src="/2025/03/04/lib-and-so/static_create.png" alt="创建静态库的过程"></p><h3 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a>静态库的使用</h3><p>静态库制作完成之后，需要将 .a 文件和头文件一定发布给用户。假设测试文件为 main.c，静态库文件为 libtest.a，头文件为 head.h。</p><p>用到的参数：</p><ul><li>-L：指定要链接的库的所在目录</li><li>-l：指定链接时需要的静态库，去掉前缀和后缀</li><li>-I：指定 main.c 文件用到的头文件 head.h 所在的路径</li><li><code>gcc -o main main.c -L./ -ltest -I./</code></li></ul><h3 id="静态库的优缺点"><a href="#静态库的优缺点" class="headerlink" title="静态库的优缺点"></a>静态库的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>库函数最终被打包到应用程序中，实现时函数本地化，寻址方便、速度快。(库函数调用效率 &#x3D;&#x3D; 自定义函数使用效率)</li><li>程序在运行时与函数库再无瓜葛，移植方便。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p>消耗系统资源较大，每个进程使用静态库都要复制一份，无端浪费内存。<br><img src="/2025/03/04/lib-and-so/static_disvantage.png"></p></li><li><p>静态库会给程序更新、部署喝发布带来麻烦。如果静态库 libxxx.a 更新了，所有使用它的程序都需要重新编译、发布给用户(对于用户来说，可能是一个很小的改动，却导致整个程序重新下载)。</p></li></ul><h2 id="共享库-shared-library-动态库"><a href="#共享库-shared-library-动态库" class="headerlink" title="共享库(shared library)&#x2F;动态库"></a>共享库(shared library)&#x2F;动态库</h2><p>共享库在程序编译时并不会被链接到目标代码中，二十在程序运行时才被载入。不容的应用如果调用相同的库，那么在内存里只需要有一份该共享库的拷贝，规避了空间浪费问题。动态库在程序运行时才被载入，也解决了静态库对程序的更行、部署和发布带来的麻烦。用户只需要更新动态库即可，增量更新。为什么需要动态库，其实也是静态库的特点导致的。</p><p>按照习惯，一般以 .so 作为文件后缀名。共享库的命名一般分为三个部分：</p><ul><li>前缀：lib</li><li>库名称：自定义即可，如：test</li><li>后缀：.so</li></ul><p>所以最终的动态库名称应该为：libtest.so</p><p><img src="/2025/03/04/lib-and-so/shared_create.png"></p><h3 id="共享库的制作"><a href="#共享库的制作" class="headerlink" title="共享库的制作"></a>共享库的制作</h3><ol><li><p>生成目标文件 .o，此时要加编译选项：-fPIC(fpic)’</p><p> gcc -fpic -c func1.c func2.c</p><p> 参数：-fpic 创建于地址无关的编译程序(pic，position independent code)，目的就是为了能够在多个应用程序间共享。</p></li><li><p>生成共享库，此时要加链接器选项：-shared(指定生成动态链接库)</p><p>gcc -shared func1.o func2.o -o libtest.so</p></li></ol><h3 id="共享库的使用"><a href="#共享库的使用" class="headerlink" title="共享库的使用"></a>共享库的使用</h3><p>引用动态库编译成可执行文件(跟静态库方式一样)：</p><p>用到的参数：</p><ul><li>-L：指定要链接的库的所在目录</li><li>-l：指定链接时需要的动态库，去掉前缀和后缀</li><li>-I：指定 main.c 文件用到的头文件 head.h 所在的路径</li><li><code>gcc -o main main.c -L./ -ltest -I./</code></li></ul><p>然后运行：.&#x2F;main，发现竟然报错了。<br><img src="/2025/03/04/lib-and-so/shared_error.png"></p><h4 id="分析为什么在执行的时候找不到-libtest-so-库"><a href="#分析为什么在执行的时候找不到-libtest-so-库" class="headerlink" title="分析为什么在执行的时候找不到 libtest.so 库"></a>分析为什么在执行的时候找不到 libtest.so 库</h4><ul><li><p>当系统加载可执行代码的时候，能够知道其所依赖库的名字，但是还需要知道所依赖的库的绝对路径。此时就需要系统动态载入器(dynamic linker&#x2F;loader)。</p><p>ldd 命令可以查看可执行文件依赖的库文件，执行 <code>ldd main</code>，就可发现 libtest.so 找不到<br><img src="/2025/03/04/lib-and-so/ldd_main.png"></p></li><li><p>对于 elf 格式的可执行文件，是由 ld-linux.so* 来完成的，它先后搜索 elf 文件的 DT_RPATH 段 – 环境变量 LD_LIBRARY_PATH – &#x2F;etc&#x2F;ld.so.cache 文件列表 – &#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib&#x2F; 目录找到库文件后将其载入内存。</p><p>使用 file 命令可以查看文件的类型：<code>file main</code><br><img src="/2025/03/04/lib-and-so/file_main.png"></p></li></ul><h3 id="如何让系统找到共享库"><a href="#如何让系统找到共享库" class="headerlink" title="如何让系统找到共享库"></a>如何让系统找到共享库</h3><ul><li>拷贝自己制作的共享库到 &#x2F;lib 或者 &#x2F;usr&#x2F;lib</li><li>临时设置 LD_LIBRARY_PATH：<ul><li><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径</code></li></ul></li><li>永久设置，把 <code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径</code> 设置到 ~&#x2F;.bashrc 文件中，然后在执行下列三种办法之一：<ul><li>执行 <code>. ~/.bashrc</code> 使配置文件生效</li><li>执行 <code>source ~/.bashrc</code> 使配置文件生效</li><li>退出当前终端，然后再次登录也可以使配置文件生效</li></ul></li><li>永久设置，把 <code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径</code> 设置到 &#x2F;etc&#x2F;profile 文件中。</li><li>将其添加到 &#x2F;etc&#x2F;ld.so.cache 文件中<ul><li>编辑 &#x2F;etc&#x2F;ld.so.conf 文件，加入库文件所在的目录的路径</li><li>运行 <code>sudo ldconfig -v</code>，该指令会重建 &#x2F;etc&#x2F;ld.so.cache 文件</li></ul></li></ul><p>解决了库的路径问题之后，再次 ldd 命令可以查看可执行文件依赖的库文件，<code>ldd main</code><br><img src="/2025/03/04/lib-and-so/ldd_main_ok.png"></p><h3 id="共享库的特点"><a href="#共享库的特点" class="headerlink" title="共享库的特点"></a>共享库的特点</h3><ul><li>动态库把对一些库函数的链接载入推迟到程序运行的时期。</li><li>可以实现进程之间的资源共享(因此动态库也称为共享库)。</li><li>将一些程序升级变得简单。</li><li>甚至可以真正做到链接载入完全由程序员在代码中控制(显式调用)。</li></ul><h2 id="比较静态库和动态库的优缺点"><a href="#比较静态库和动态库的优缺点" class="headerlink" title="比较静态库和动态库的优缺点"></a>比较静态库和动态库的优缺点</h2><h3 id="静态库的有点"><a href="#静态库的有点" class="headerlink" title="静态库的有点"></a>静态库的有点</h3><ol><li>执行速度快，是因为静态库已经编译到可执行文件内部了。</li><li>移植方便，不依赖于其他的库文件</li></ol><h3 id="静态库的缺点"><a href="#静态库的缺点" class="headerlink" title="静态库的缺点"></a>静态库的缺点</h3><ol><li>耗费内存，是由于每一个静态库的可执行程序都会加载一次。</li><li>部署更新麻烦，因为静态库修改以后所有的调用到这个静态库的可执行文件都需要重新编译。</li></ol><h3 id="动态库的优点"><a href="#动态库的优点" class="headerlink" title="动态库的优点"></a>动态库的优点</h3><ol><li>节省内存。</li><li>部署升级更新方便，只需替换动态库即可，然后再重启服务。</li></ol><h3 id="动态库的缺点"><a href="#动态库的缺点" class="headerlink" title="动态库的缺点"></a>动态库的缺点</h3><ol><li>加载速度比静态库慢。</li><li>移植性差，需要把所有用到的动态库都移植。</li></ol><p>由于由静态库生成的可执行文件是把静态库加载到了其内部，所以静态库生成的可执行文件一般会比动态库大。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc编译器</title>
    <link href="/2025/03/04/gcc-compiler/"/>
    <url>/2025/03/04/gcc-compiler/</url>
    
    <content type="html"><![CDATA[<h1 id="gcc-编译器"><a href="#gcc-编译器" class="headerlink" title="gcc 编译器"></a>gcc 编译器</h1><h2 id="gcc-的工作流程"><a href="#gcc-的工作流程" class="headerlink" title="gcc 的工作流程"></a>gcc 的工作流程</h2><p>gcc 编译器将 c 源文件到生成一个可执行程序，中间一共经历了四个步骤：<br><img src="/2025/03/04/gcc-compiler/gcc_compile_flow.png"></p><p>四个步骤并不是 gcc 独立完成的，而是在内部调用了其他工具，从而完成了整个工作流程，其中编译最耗时，因为要逐行检查语法。<br><img src="/2025/03/04/gcc-compiler/gcc_tool_chain.png"></p><p>下面以 test.c 为例介绍 gcc 的四个步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -E test.c -o test.i<br>gcc -S test.i -o test.s<br>gcc -c test.s -o test.o<br>gcc test.o -o test<br></code></pre></td></tr></table></figure><p>一步生成最终可执行程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc test.c -o test<br></code></pre></td></tr></table></figure><h2 id="gcc-常用参数"><a href="#gcc-常用参数" class="headerlink" title="gcc 常用参数"></a>gcc 常用参数</h2><ul><li>-v 查看 gcc 版本号， –version 也可以</li><li>-E 生成预处理文件</li><li>-S 生成汇编文件</li><li>-c 只编译，生成 .o 文件，通常称为目标文件</li><li>-I 指定头文件所在的路径</li><li>-L 指定库文件所在的路径</li><li>-l 指定库的名字</li><li>-o 指定生成的目标文件的名字</li><li>-g 包含调试信息，使用 gdb 调试需要添加 -g 参数</li><li>-On n&#x3D;0~3 编译优化，n 越大优化程度越高，但编译时间越长</li></ul><p>例如：下面代码片段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = a;<br><span class="hljs-type">int</span> c = b;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, c);<br></code></pre></td></tr></table></figure><p>上面的代码可能会被编译器优化成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> c = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><ul><li>-Wall 提示更多警告信息</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br><span class="hljs-type">int</span> c = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d]\n&quot;</span>, c);<br></code></pre></td></tr></table></figure><p>编译如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -o test -Wall test.c<br>warning: unused variable &#x27;a&#x27; [-Wunused-variable]<br>warning: unused variable &#x27;b&#x27; [-Wunused-variable]<br></code></pre></td></tr></table></figure><ul><li>-D 编译时定义宏<br>test.c 文件中的代码片段：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max==[%d]&quot;</span>, MAX);<br></code></pre></td></tr></table></figure><p>编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -o test test.c -D MAX=10<br>gcc -o test test.c -DMAX=10<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>gcc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础命令</title>
    <link href="/2025/03/03/linux_base/"/>
    <url>/2025/03/03/linux_base/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h1><h2 id="Shell-相关"><a href="#Shell-相关" class="headerlink" title="Shell 相关"></a>Shell 相关</h2><pre><code class="hljs">概念： Shell就是命令解析器，Shell将用户输入的命令解释成内核能够识别的指令，Shell就相当于翻译。查看当前系统使用的shell:    echo $SHELL查看当前系统支持的shell:    cat /etc/shells</code></pre><h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><pre><code class="hljs">是一个倒立的树状结构。</code></pre><ul><li>&#x2F;bin: binary，二进制文件，可执行程序，shell命令<ul><li>如：ls, rm, mv, cp等常用命令</li></ul></li><li>&#x2F;sbin: s是Super User的意思，这里存放的是系统管理员使用的系统管理程序。<ul><li>如ifconfig, halt, shutdown, reboot等系统命令</li></ul></li><li>&#x2F;dev: device，在linux下一切皆文件<ul><li>硬盘, 显卡, 显示器</li><li>字符设备文件、块设备文件<ul><li>如: 在input目录下执行: sudo cat mouse0, 移动鼠标会显示有输入.</li></ul></li></ul></li><li>&#x2F;lib: linux运行的时候需要加载的一些动态库<ul><li>如: libc.so、libpthread.so等</li></ul></li><li>&#x2F;mnt: 手动的挂载目录, 如U盘等</li><li>&#x2F;media: 外设的自动挂载目录, 如光驱等</li><li>&#x2F;root: linux的超级用户root的家目录</li><li>&#x2F;usr: unix system resource–类似于WINDOWS的programe files目录<ul><li>include目录里存放头文件, 如: stdio.h、stdlib.h、string.h、pthread.h</li><li>games目录下的小游戏-如: sl小火车游戏</li></ul></li><li>&#x2F;etc: 存放配置文件<ul><li>&#x2F;etc&#x2F;passwd<ul><li>man 5 passwd可以查看passwd文件的格式信息</li></ul></li><li>&#x2F;etc&#x2F;group<ul><li>man 5 group可以查看group文件的格式信息</li></ul></li><li>&#x2F;etc&#x2F;profile<ul><li>系统的配置文件, 修改该文件会影响这个系统下面的所有的用户</li></ul></li></ul></li><li>&#x2F;opt: 安装第三方应用程序<ul><li>比如安装oracle数据库可以在这个目录下</li></ul></li><li>&#x2F;home: linux操作系统所有用户的家目录<ul><li>用户家目录：(宿主目录或者主目录)<ul><li>&#x2F;home&#x2F;itcast</li></ul></li></ul></li><li>&#x2F;tmp: 存放临时文件<ul><li>新建在这个目录下的文件会在系统重启后自动清除</li></ul></li></ul><h2 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h2><ul><li>绝对路径: 从&#x2F;目录开始表示的目录.</li><li>相对路径: 从当前目录开始表示的目录.<ul><li>从当前所处的目录开始表示的路径。</li><li>. 表示当前目录</li><li>.. 表示当前目录的上一级目录</li></ul></li></ul><h2 id="文件和目录操作相关的命令"><a href="#文件和目录操作相关的命令" class="headerlink" title="文件和目录操作相关的命令"></a>文件和目录操作相关的命令</h2><h3 id="tree-命令"><a href="#tree-命令" class="headerlink" title="tree 命令"></a>tree 命令</h3><pre><code class="hljs">以树状星蚀查看指定目录内容，使用该命令需要安装软件tree</code></pre><p>命令使用方法：</p><ul><li>tree – 树状结构显示当前目录下的文件信息</li><li>tree 目录 – 树状结构显示指定目录下的文件信息</li></ul><h3 id="ls-命令"><a href="#ls-命令" class="headerlink" title="ls 命令"></a>ls 命令</h3><ul><li>查看指定目录下的文件信息</li><li>使用方法：<ul><li>ls – 显示当前目录下的文件信息</li><li>ls 目录 – 显示指定目录下的文件信息</li></ul></li><li>相关参数<ul><li>-a: 显示所有文件和目录<ul><li>. 当前目录</li><li>.. 当前目录的额上一级目录</li><li>隐藏文件，以 . 开头的文件，如.bashrc</li><li>普通文件</li></ul></li><li>-R: 递归显示指定目录下的文件信息</li><li>-l: 列出文件的详细信息，7部分内容<br><img src="/2025/03/03/linux_base/ls-l.png"></li><li>参数之间可以结合使用：<ul><li>ls -la: 列出当前目录下所有文件的相关信息，包括隐藏文件</li><li>ls -ltr: 列出当前目录下的文件，按照时间你想排序</li></ul></li></ul></li></ul><h3 id="cd-命令"><a href="#cd-命令" class="headerlink" title="cd 命令"></a>cd 命令</h3><pre><code class="hljs">切换目录(change directory)，命令使用方式：cd + 目录路径可以使用相对路径或者绝对路径</code></pre><ul><li>切换到家目录<ul><li>cd</li><li>cd ~</li><li>cd &#x2F;home&#x2F;user_name</li><li>cd $HOME</li></ul></li><li>临近两个目录切换<ul><li>cd -</li></ul></li></ul><h3 id="pwd-命令"><a href="#pwd-命令" class="headerlink" title="pwd 命令"></a>pwd 命令</h3><pre><code class="hljs">查看用户当前所处的工作目录，print working directory</code></pre><h3 id="which-命令"><a href="#which-命令" class="headerlink" title="which 命令"></a>which 命令</h3><pre><code class="hljs">显示命令所在的目录, 如 which ls， which cp</code></pre><h3 id="touch-命令"><a href="#touch-命令" class="headerlink" title="touch 命令"></a>touch 命令</h3><pre><code class="hljs">如果文件不存在，创建新文件，如果文件存在，更新最后修改时间命令使用方式：touch 文件名</code></pre><h3 id="mkdir-命令"><a href="#mkdir-命令" class="headerlink" title="mkdir 命令"></a>mkdir 命令</h3><pre><code class="hljs">创建新目录，make directory创建方式：mkdir 目录名如果创建多级目录需要添加参数 -p：  在当前目录下创建目录： mkdir mydir  在宿主目录下创建多级目录： mkdir -p ~/test/hello/world/aa</code></pre><h3 id="rmdir-命令"><a href="#rmdir-命令" class="headerlink" title="rmdir 命令"></a>rmdir 命令</h3><pre><code class="hljs">删除空目录，只能删除空目录 ，使用方式：rmdir 目录名</code></pre><h3 id="rm-命令"><a href="#rm-命令" class="headerlink" title="rm 命令"></a>rm 命令</h3><ul><li>删除文件： rm 文件名</li><li>删除目录： rm -r 目录名</li><li>参数：<ul><li>-r： 递归删除目录，删除目录碧玺添加此参数</li><li>-i： 提示用户是否删除文件或目录</li><li>-f： 强制删除</li></ul></li><li>注意事项：<ul><li>使用 rm 命令删除的文件或目录不会放入回收站中，数据不易回复。</li></ul></li></ul><h3 id="cp-命令"><a href="#cp-命令" class="headerlink" title="cp 命令"></a>cp 命令</h3><p>命令使用方式： cp 源目录或文件 目标目录或文件</p><p>若有目录的拷贝需要使用 -r 参数</p><ul><li>cp 要拷贝的文件(file1) file(不存在)<ul><li>创建 file，将 file1 中的内容拷贝到 file</li></ul></li><li>cp file1 file(存在)<ul><li>file1 覆盖 file</li></ul></li><li>cp file dir(存在)<ul><li>拷贝 file 到 dir 目录</li></ul></li><li>cp -r dir(存在) dir1(存在)<ul><li>将 dir 目录拷贝到 dir1 目录中</li><li>包括 dir 目录</li></ul></li><li>cp -r dir(存在) dir1(不存在)<ul><li>创建 dir1</li><li>将 dir 目录拷贝到 dir1 中，不包括 dir 目录</li></ul></li><li>cp 拷贝目录也可以用 -a 参数，这样可以保留被拷贝的文件的一些属性信息</li></ul><h3 id="mv-命令"><a href="#mv-命令" class="headerlink" title="mv 命令"></a>mv 命令</h3><ul><li>改名或者移动文件 mv file1 file2<ul><li>改名：<ul><li>mv file(存在) file1(不存在)</li><li>mv dir(存在) dir1(不存在)</li><li>mv file(存在) file1(存在)<ul><li>file 文件覆盖 file1 文件，file 改名为 file1</li></ul></li></ul></li><li>移动(第二个参数一定是目录文件)<ul><li>mv file(文件) dir(存在目录)<ul><li>将 file 文件移动到 dir 中</li></ul></li><li>mv dir(目录) dir1(存在目录)<ul><li>将 dir 目录移动到 dir1 中，dir 就会作为 dir1 的子目录而存在</li></ul></li></ul></li></ul></li></ul><h3 id="cat-命令"><a href="#cat-命令" class="headerlink" title="cat 命令"></a>cat 命令</h3><ul><li>将文件内容一次性输出到终端。</li><li>使用方式： cat 文件名</li><li>缺点：终端显示的内容有限，如果文件太长无法显示全部。</li><li>可用于文件重定向：cat file1 &gt; file2， 相当于 cp file1 file2</li></ul><h3 id="more-命令"><a href="#more-命令" class="headerlink" title="more 命令"></a>more 命令</h3><ul><li>文件内容分页显示到终端，但是智能一直向下浏览，不能回退</li><li>使用方式：more + 文件名</li><li>相关操作：<ul><li>显示下一行：回车</li><li>显示下一页：空格</li><li>退出：q(ctrl + c)</li></ul></li></ul><h3 id="less-命令"><a href="#less-命令" class="headerlink" title="less 命令"></a>less 命令</h3><ul><li>文件内容分页显示到终端，可以上下浏览</li><li>使用方式：less + 文件名</li><li>相关操作：<ul><li>显示下一行：回车、ctrl + p、方向键上</li><li>显示上一行：ctrl + n、方向键下</li><li>显示下一页：空格、PageDown</li><li>显示上一页：PageUp</li><li>退出：q</li></ul></li></ul><h3 id="head-命令"><a href="#head-命令" class="headerlink" title="head 命令"></a>head 命令</h3><ul><li>从文件头部开始查看前 n 行的内容</li><li>使用方式： head -n[行数] 文件名<ul><li>head -20 hello.txt’</li></ul></li><li>如果没有指定行数，默认显示前10行内容</li></ul><h3 id="tail-命令"><a href="#tail-命令" class="headerlink" title="tail 命令"></a>tail 命令</h3><ul><li>从文件尾部向上查看最后 n 行的内容</li><li>使用方式： tail -n[行数] 文件名</li><li>如果未指定行数，默认显示最后10行内容</li><li>一个比较重要的应用：显示日志：<code>tail -f test.log</code>，可以实时显示日志内容，当有新的日志产生时，会自动显示在终端上</li></ul><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><ul><li>软链接类似于 windows 下的快捷方式</li><li>如何创建软链接<ul><li><p>ln -s 文件名 快捷方式的名字</p><p>例如：ln -s aa aa.soft</p></li><li><p>目录也可以创建软链接</p><p>例如：ln -s tmp tmp.link</p></li></ul></li><li>创建软链接应注意事项<ul><li>ln 创建软链接要用绝对路径，因为如果不使用绝对路径，一旦这个链接文件发生位置变动，就不能找到那个文件了。</li><li>软链接文件的大小是：路径 + 文件名的总字节数</li></ul></li></ul><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><ul><li>ln 文件名 硬链接的名字<ul><li>ln test.log test.log.hard</li></ul></li><li>使用硬链接应注意事项<ul><li><p>硬链接不能建立在目录上</p></li><li><p>硬链接对绝对路径没有要求</p></li><li><p>硬链接不能跨文件系统</p><p>硬链接文件和源文件的 inode 是相同的，文件系统的 inode 要求唯一，跨文件系统可能会使 inode不同，所以硬链接不能跨文件系统</p></li></ul></li><li>硬链接的本质<ul><li>硬链接的本质使不同的文件名所在 inode 节点是相同的，相同的 inode 节点指向了相同的数据块，所以它们的文件内容是一样的，文件内容会同步。<ul><li><p>ls -i 文件名 —–&gt; 可以查看文件的 i 节点</p></li><li><p>stat 文件名 —–&gt; 可以查看文件的详细信息，包括 inode 节点</p></li><li><p>如下图，file.hard 是 file 的硬链接，这两个文件指向同一个 inode，同一个 inode 指向了相同的数据块(文件内容)。<br><img src="/2025/03/03/linux_base/hardlink.png"></p><ul><li>当新创建了一个文件，硬链接计数为1</li><li>给文件创建了一个硬链接后，硬链接计数加1</li><li>删除一个硬链接后，硬链接计数减1</li><li>如果删除硬链接后，硬链接技术为0，则该文件会被删除</li></ul></li></ul></li></ul></li><li>硬链接应用场合<ul><li><p>可以起到文件同步的作用</p><p>修改 file 内容，会在其余几个硬链接文件上同步</p></li><li><p>可以起到保护文件的作用</p><p>删除文件的时候，只要硬链接技术不为0，不会真正删除，起到保护文件的作用。</p></li></ul></li></ul><h3 id="wc-命令"><a href="#wc-命令" class="headerlink" title="wc 命令"></a>wc 命令</h3><ul><li>显示文件行数，字节数，单词数<ul><li>wc -l file 显示文件的总行数</li><li>wc -c file 显示文件的总字节数</li><li>wc -w file 显示文件的总单词数</li><li>wc file 显示文件的总行数，总字节数，总单词数</li></ul></li></ul><h3 id="whoami-命令"><a href="#whoami-命令" class="headerlink" title="whoami 命令"></a>whoami 命令</h3><ul><li>显示当前用户名</li></ul><h2 id="用户权限、用户、用户组"><a href="#用户权限、用户、用户组" class="headerlink" title="用户权限、用户、用户组"></a>用户权限、用户、用户组</h2><h3 id="修改文件权限-chmod"><a href="#修改文件权限-chmod" class="headerlink" title="修改文件权限 chmod"></a>修改文件权限 chmod</h3><pre><code class="hljs">linux 是通过权限对文件进行控制的，通过使用 chmod 命令可以修改文件相关的权限</code></pre><ul><li>文字设定法<ul><li>命令：chmod [+|-|&#x3D;] 文件名<ul><li>操作对象 [who]<ul><li>u – 用户(user)</li><li>g – 同组用户(group)</li><li>o – 其他用户(other)</li><li>a – 所有用户(all)</li></ul></li><li>操作符 [+|-|&#x3D;]<ul><li>+ – 添加权限</li><li>- – 删除权限</li><li>&#x3D; – 赋予给定权限并取消其他权限</li></ul></li><li>权限 [mode]<ul><li>r – 读权限</li><li>w – 写权限</li><li>x – 执行权限</li></ul></li></ul></li><li>示例：给文件 file.txt 的所有者和所属组添加读写权限<ul><li>chmod ug+wr file.txt</li></ul></li></ul></li><li>数字设定法<ul><li>命令：chmod [who] [+|-|&#x3D;] 文件名<ul><li>操作符 [+|-|&#x3D;]<ul><li>\ – 添加权限</li><li>- – 删除权限</li><li>&#x3D; – 赋予给定权限并取消其他权限</li></ul></li><li>数字表示的含义<ul><li>0 – 没有权限(-)</li><li>1 – 执行权限(x)</li><li>2 – 写权限(w)</li><li>4 – 读权限(r)</li></ul></li><li>例：给 file.txt 文件设置 rw-rw-r–<ul><li>chmod 664 file.txt</li></ul></li></ul></li></ul></li></ul><p>注意点：使用数字设定发，一定要使用3位的8进制数：如066</p><h3 id="修改文件所有者和所属组"><a href="#修改文件所有者和所属组" class="headerlink" title="修改文件所有者和所属组"></a>修改文件所有者和所属组</h3><ul><li>修改文件所有者 chown<ul><li>用法：chown 文件所有者 文件名<ul><li>sudo chown user file.txt</li></ul></li></ul></li><li>修改文件所有者和所属组 chown<ul><li>用法：chown 文件所有者：文件所属组 文件名<ul><li>sudo chown user:group file.txt</li></ul></li></ul></li><li>注意：普通用户需要使用管理员用户权限执行该命令</li><li>注意：若系统没有其他用法，可以使用 <code>sudo adduser 用户名</code> 创建一个新用户</li></ul><h3 id="修改文件所属组"><a href="#修改文件所属组" class="headerlink" title="修改文件所属组"></a>修改文件所属组</h3><ul><li>chgrp 命令<ul><li>使用方法：chgrp 用户组 文件或目录名<ul><li>示例：修改文件所属组位 group1</li><li>sudo chgrp group1 file.txt</li></ul></li><li>普通用户需要使用管理员用户权限执行该命令</li></ul></li></ul><h2 id="find-命令"><a href="#find-命令" class="headerlink" title="find 命令"></a>find 命令</h2><h3 id="按文件名查询：使用参数-name"><a href="#按文件名查询：使用参数-name" class="headerlink" title="按文件名查询：使用参数 -name"></a>按文件名查询：使用参数 -name</h3><ul><li>命令：find 路径 -name “文件名”</li><li>示例：find &#x2F;home -name “*.c”</li></ul><h3 id="按文件类型查询：使用参数-type"><a href="#按文件类型查询：使用参数-type" class="headerlink" title="按文件类型查询：使用参数 -type"></a>按文件类型查询：使用参数 -type</h3><ul><li>命令：find 路径 -type 类型<ul><li>普通文件类型用 f 表示而不是 -</li><li>d -&gt; 目录</li><li>l -&gt; 符号链接</li><li>b -&gt; 块设备</li><li>c -&gt; 字符设备</li><li>s -&gt; socket 文件</li><li>p -&gt; 管道文件</li></ul></li><li>查找指定目录下的普通文件： find 路径 -type f</li></ul><h3 id="按文件大小查询：使用参数-size"><a href="#按文件大小查询：使用参数-size" class="headerlink" title="按文件大小查询：使用参数 -size"></a>按文件大小查询：使用参数 -size</h3><ul><li>命令：find 路径 -size 范围<ul><li>范围：<ul><li>大于：+ 表示 – +100k</li><li>小于：- 表示 – -100k</li><li>等于：无符号表示 – 100k</li></ul></li><li>大小：<ul><li>M 必须大写(10M)</li><li>k 必须小写(10k)</li><li>c 表示字节数</li></ul></li><li>例子：查询目录为家目录<ul><li>等于 100k 的文件：find ~&#x2F; -size 100k</li><li>大于 100k 的文件：find ~&#x2F; -size +100k</li><li>大于 50k，小于 100k 的文件：find ~&#x2F; -size +50k -size -100k</li></ul></li></ul></li></ul><h3 id="按文件日期"><a href="#按文件日期" class="headerlink" title="按文件日期"></a>按文件日期</h3><ul><li>创建日期：-ctime -n&#x2F;+n</li><li>修改日期：-mtime -n&#x2F;+n</li><li>访问日期：-atime -n&#x2F;+n</li></ul><h3 id="按深度"><a href="#按深度" class="headerlink" title="按深度"></a>按深度</h3><ul><li>maxdepth n(层数)<ul><li>搜索 n 层以下的目录，搜索的层数不超过 n 层</li></ul></li><li>mindepth n(层数)<ul><li>搜索 n 层以上的目录，搜索的层数不能小于 n 层</li></ul></li></ul><h3 id="高级查找"><a href="#高级查找" class="headerlink" title="高级查找"></a>高级查找</h3><ul><li>例：查找指定目录下所有目录，并列出目录中文件详细信息<ul><li>find .&#x2F; -type d -exec shell 命令 {} ;<ul><li>find .&#x2F; -type d -exec ls -l {} ;</li></ul></li><li>find .&#x2F; -type d -ok shell 命令 {} ;<ul><li>find .&#x2F; -type d -ok ls -l {} ;</li></ul></li></ul></li><li>注意：{}中间不能又空格</li><li>ok 比较安全，特别是在执行 rm 删除文件的时候<ul><li>find .&#x2F; -type d | xargs shell 命令<ul><li>find .&#x2F; -type d | xargs ls -l</li></ul></li></ul></li></ul><h2 id="grep-命令"><a href="#grep-命令" class="headerlink" title="grep 命令"></a>grep 命令</h2><h3 id="grep-r-有目录-“查找的内容”-搜索路径"><a href="#grep-r-有目录-“查找的内容”-搜索路径" class="headerlink" title="grep -r(有目录) “查找的内容” 搜索路径"></a>grep -r(有目录) “查找的内容” 搜索路径</h3><ul><li>-r 参数，若是目录，则可以递归搜索</li><li>-n 参数可以显示该查找内容所在的行号</li><li>-i 参数可以忽略大小写进行查找</li><li>-v 参数不显示含有某字符串</li></ul><h3 id="搜索当前目录下包含-hello-world-字符串的文件"><a href="#搜索当前目录下包含-hello-world-字符串的文件" class="headerlink" title="搜索当前目录下包含 hello world 字符串的文件"></a>搜索当前目录下包含 hello world 字符串的文件</h3><ul><li><code>grep -r -n &quot;hello world&quot; ./</code>    —-显示行号</li><li><code>grep -r -n -i &quot;HELLO world&quot; ./</code>    —-忽略大小写查找</li></ul><h2 id="find-和-grep-命令结合使用"><a href="#find-和-grep-命令结合使用" class="headerlink" title="find 和 grep 命令结合使用"></a>find 和 grep 命令结合使用</h2><h3 id="先使用-find-命令查找文件，然后使用-grep-命令查找那些文件包含某个字符串"><a href="#先使用-find-命令查找文件，然后使用-grep-命令查找那些文件包含某个字符串" class="headerlink" title="先使用 find 命令查找文件，然后使用 grep 命令查找那些文件包含某个字符串"></a>先使用 find 命令查找文件，然后使用 grep 命令查找那些文件包含某个字符串</h3><ul><li>find . -name “*.c” | xargs grep -n “main”</li></ul><h2 id="Linux-中常用的压缩工具"><a href="#Linux-中常用的压缩工具" class="headerlink" title="Linux 中常用的压缩工具"></a>Linux 中常用的压缩工具</h2><h3 id="gzip-和-bzip2"><a href="#gzip-和-bzip2" class="headerlink" title="gzip 和 bzip2"></a>gzip 和 bzip2</h3><ul><li>不能压缩目录，只能一个一个文件进行压缩，压缩之后会使源文件消失</li><li>gzip * 压缩当前目录下所有的文件，但是目录不能压缩</li><li>gunzip * 解压当前目录下所有的 .gz 文件</li><li>bzip2 * 压缩当前目录下所有的文件，但是目录不能压缩</li><li>bunzip2 * 解压当前目录下所有的 .bz2 文件</li></ul><h3 id="tar-工具"><a href="#tar-工具" class="headerlink" title="tar 工具"></a>tar 工具</h3><ul><li>相关参数说明<ul><li>z：用 gzip 来压缩&#x2F;解压文件</li><li>j：用 bzip2 来压缩&#x2F;解压文件</li><li>c：create，创建新的压缩文件，与 x 互斥使用</li><li>x：从压缩文件中释放文件，与 c 互斥使用</li><li>f：指定压缩文件的名字</li><li>t：查看压缩包中有哪些文件</li></ul></li><li>压缩：<ul><li>tar -cvf 压缩包名.tar 要压缩的文件或目录</li><li>tar -cvzf 压缩包名.tar.gz 要压缩的文件或目录</li><li>tar -cvjf 压缩包名.tar.bz2 要压缩的文件或目录</li></ul></li><li>解压缩<ul><li>tar -xvf 压缩包名.tar</li><li>tar -xzvf 压缩包名.tar.gz</li><li>tar -xjvf 压缩包名.tar.bz2</li><li>解压到指定目录：添加参数 -C(大写)<ul><li>tar -xzvf 压缩包名.tar.gz -C 指定目录</li></ul></li></ul></li><li>查看压缩包中有哪些文件<ul><li>tar -tvf 压缩包名.tar</li></ul></li></ul><h3 id="rar-工具"><a href="#rar-工具" class="headerlink" title="rar 工具"></a>rar 工具</h3><ul><li>使用前需要安装 rar 工具<ul><li>安装命令：sudo apt-get install rar</li></ul></li><li>压缩：<ul><li>命令： rar a -r 压缩包名 要压缩的文件<ul><li>压缩目录需要使用参数： -R</li><li>rar a -r my aa bb dir —-将 aa bb dir 三个文件压缩到 my.rar 中</li></ul></li><li>打包的生成的新文件不需要指定后缀</li></ul></li><li>解压缩：<ul><li>命令：rar x xxx.rar 压缩目录<ul><li>rar x my.rar —-将 my.rar 中的文件解压到当前目录</li></ul></li><li>解压到指定目录，直接指定解压目录即可<ul><li>rar x xxx.rar 目录</li><li>rar x my.rar TAR —-将 my.rar 中的文件解压到 TAR 目录</li><li>注意：若解压目录不存在则会报错</li></ul></li></ul></li></ul><h3 id="zip-工具"><a href="#zip-工具" class="headerlink" title="zip 工具"></a>zip 工具</h3><ul><li>压缩：zip -r 压缩包名 要压缩的文件或目录<ul><li>压缩目录需要使用参数 -R</li><li>使用该命令不需要指定压缩包后缀</li><li>zip -r xxx file dir —-将 file dir 两个文件压缩到 xxx.zip 中</li></ul></li><li>解压缩：unzip 压缩包名<ul><li>解压缩到指定目录：添加参数 -d 解压目录</li><li>unzip xxx.zip -d &#x2F;home</li><li>注意：若解压目录不存在则会创建</li></ul></li></ul><h2 id="软件的安装和卸载"><a href="#软件的安装和卸载" class="headerlink" title="软件的安装和卸载"></a>软件的安装和卸载</h2><h3 id="在线安装"><a href="#在线安装" class="headerlink" title="在线安装"></a>在线安装</h3><ul><li>软件安装：sudo apt-get install 软件名</li><li>软件卸载：sudo apt-get remove 软件名</li><li>更新软件列表：sudo apt-get update</li><li>清理安装包：sudo apt-get clean</li></ul><h3 id="安装包安装"><a href="#安装包安装" class="headerlink" title="安装包安装"></a>安装包安装</h3><ul><li>在 Ubuntu 系统下必须有 deb 格式的安装包</li><li>软件安装：sudo dpkg -i xxx.deb</li><li>软件卸载：sudo dpkg -r xxx.deb</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
